/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fnode_modules%2Freact-toastify%2Fdist%2Freact-toastify.esm.mjs&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fglobals.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fstyle.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fsrc%2Fredux-toolkit%2Fprovider.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fnode_modules%2Freact-toastify%2Fdist%2Freact-toastify.esm.mjs&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fglobals.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fstyle.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fsrc%2Fredux-toolkit%2Fprovider.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/react-toastify/dist/react-toastify.esm.mjs */ \"(app-pages-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/assets/scss/globals.scss */ \"(app-pages-browser)/./public/assets/scss/globals.scss\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./public/assets/scss/style.scss */ \"(app-pages-browser)/./public/assets/scss/style.scss\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/redux-toolkit/provider.tsx */ \"(app-pages-browser)/./src/redux-toolkit/provider.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRm1pY2hlbGFuZ2Vsb2dlbGFyZGklMkZEb2N1bWVudHMlMkZXb3JrJTJGRGV2JTJGdGltZS12b3lhZ2UlMkZub2RlX21vZHVsZXMlMkZyZWFjdC10b2FzdGlmeSUyRmRpc3QlMkZyZWFjdC10b2FzdGlmeS5lc20ubWpzJm1vZHVsZXM9JTJGVXNlcnMlMkZtaWNoZWxhbmdlbG9nZWxhcmRpJTJGRG9jdW1lbnRzJTJGV29yayUyRkRldiUyRnRpbWUtdm95YWdlJTJGcHVibGljJTJGYXNzZXRzJTJGc2NzcyUyRmdsb2JhbHMuc2NzcyZtb2R1bGVzPSUyRlVzZXJzJTJGbWljaGVsYW5nZWxvZ2VsYXJkaSUyRkRvY3VtZW50cyUyRldvcmslMkZEZXYlMkZ0aW1lLXZveWFnZSUyRnB1YmxpYyUyRmFzc2V0cyUyRnNjc3MlMkZzdHlsZS5zY3NzJm1vZHVsZXM9JTJGVXNlcnMlMkZtaWNoZWxhbmdlbG9nZWxhcmRpJTJGRG9jdW1lbnRzJTJGV29yayUyRkRldiUyRnRpbWUtdm95YWdlJTJGc3JjJTJGcmVkdXgtdG9vbGtpdCUyRnByb3ZpZGVyLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDRPQUFzSjtBQUN0Siw0TEFBOEg7QUFDOUgsd0xBQTRIO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NjQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9taWNoZWxhbmdlbG9nZWxhcmRpL0RvY3VtZW50cy9Xb3JrL0Rldi90aW1lLXZveWFnZS9ub2RlX21vZHVsZXMvcmVhY3QtdG9hc3RpZnkvZGlzdC9yZWFjdC10b2FzdGlmeS5lc20ubWpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvbWljaGVsYW5nZWxvZ2VsYXJkaS9Eb2N1bWVudHMvV29yay9EZXYvdGltZS12b3lhZ2UvcHVibGljL2Fzc2V0cy9zY3NzL2dsb2JhbHMuc2Nzc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL21pY2hlbGFuZ2Vsb2dlbGFyZGkvRG9jdW1lbnRzL1dvcmsvRGV2L3RpbWUtdm95YWdlL3B1YmxpYy9hc3NldHMvc2Nzcy9zdHlsZS5zY3NzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvbWljaGVsYW5nZWxvZ2VsYXJkaS9Eb2N1bWVudHMvV29yay9EZXYvdGltZS12b3lhZ2Uvc3JjL3JlZHV4LXRvb2xraXQvcHJvdmlkZXIudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fnode_modules%2Freact-toastify%2Fdist%2Freact-toastify.esm.mjs&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fglobals.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fstyle.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fsrc%2Fredux-toolkit%2Fprovider.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __generator = this && this.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = this && this.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _j = 0, _k = __getOwnPropSymbols(b); _j < _k.length; _j++){\n        var prop = _k[_j];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __markAsModule = function(target) {\n    return __defProp(target, \"__esModule\", {\n        value: true\n    });\n};\nvar __objRest = function(source, exclude) {\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for(var _j = 0, _k = __getOwnPropSymbols(source); _j < _k.length; _j++){\n        var prop = _k[_j];\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\nvar __export = function(target, all) {\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __reExport = function(target, module2, desc) {\n    if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n        var _loop_1 = function(key) {\n            if (!__hasOwnProp.call(target, key) && key !== \"default\") __defProp(target, key, {\n                get: function() {\n                    return module2[key];\n                },\n                enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n            });\n        };\n        for(var _j = 0, _k = __getOwnPropNames(module2); _j < _k.length; _j++){\n            var key = _k[_j];\n            _loop_1(key);\n        }\n    }\n    return target;\n};\nvar __toModule = function(module2) {\n    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {\n        get: function() {\n            return module2.default;\n        },\n        enumerable: true\n    } : {\n        value: module2,\n        enumerable: true\n    })), module2);\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/query/index.ts\n__markAsModule(exports);\n__export(exports, {\n    QueryStatus: function() {\n        return QueryStatus;\n    },\n    buildCreateApi: function() {\n        return buildCreateApi;\n    },\n    copyWithStructuralSharing: function() {\n        return copyWithStructuralSharing;\n    },\n    coreModule: function() {\n        return coreModule;\n    },\n    coreModuleName: function() {\n        return coreModuleName;\n    },\n    createApi: function() {\n        return createApi;\n    },\n    defaultSerializeQueryArgs: function() {\n        return defaultSerializeQueryArgs;\n    },\n    fakeBaseQuery: function() {\n        return fakeBaseQuery;\n    },\n    fetchBaseQuery: function() {\n        return fetchBaseQuery;\n    },\n    retry: function() {\n        return retry;\n    },\n    setupListeners: function() {\n        return setupListeners;\n    },\n    skipSelector: function() {\n        return skipSelector;\n    },\n    skipToken: function() {\n        return skipToken;\n    }\n});\n// src/query/core/apiState.ts\nvar QueryStatus;\n(function(QueryStatus2) {\n    QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n    QueryStatus2[\"pending\"] = \"pending\";\n    QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n    QueryStatus2[\"rejected\"] = \"rejected\";\n})(QueryStatus || (QueryStatus = {}));\nfunction getRequestStatusFlags(status) {\n    return {\n        status: status,\n        isUninitialized: status === QueryStatus.uninitialized,\n        isLoading: status === QueryStatus.pending,\n        isSuccess: status === QueryStatus.fulfilled,\n        isError: status === QueryStatus.rejected\n    };\n}\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n    return new RegExp(\"(^|:)//\").test(url);\n}\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = function(url) {\n    return url.replace(/\\/$/, \"\");\n};\nvar withoutLeadingSlash = function(url) {\n    return url.replace(/^\\//, \"\");\n};\nfunction joinUrls(base, url) {\n    if (!base) {\n        return url;\n    }\n    if (!url) {\n        return base;\n    }\n    if (isAbsoluteUrl(url)) {\n        return url;\n    }\n    var delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n    base = withoutTrailingSlash(base);\n    url = withoutLeadingSlash(url);\n    return \"\" + base + delimiter + url;\n}\n// src/query/utils/flatten.ts\nvar flatten = function(arr) {\n    return [].concat.apply([], arr);\n};\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n    return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    return document.visibilityState !== \"hidden\";\n}\n// src/query/utils/copyWithStructuralSharing.ts\nvar import_toolkit = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar isPlainObject = import_toolkit.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n    if (oldObj === newObj || !(isPlainObject(oldObj) && isPlainObject(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n        return newObj;\n    }\n    var newKeys = Object.keys(newObj);\n    var oldKeys = Object.keys(oldObj);\n    var isSameObject = newKeys.length === oldKeys.length;\n    var mergeObj = Array.isArray(newObj) ? [] : {};\n    for(var _j = 0, newKeys_1 = newKeys; _j < newKeys_1.length; _j++){\n        var key = newKeys_1[_j];\n        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n    }\n    return isSameObject ? oldObj : mergeObj;\n}\n// src/query/fetchBaseQuery.ts\nvar import_toolkit2 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar defaultFetchFn = function() {\n    var args = [];\n    for(var _j = 0; _j < arguments.length; _j++){\n        args[_j] = arguments[_j];\n    }\n    return fetch.apply(void 0, args);\n};\nvar defaultValidateStatus = function(response) {\n    return response.status >= 200 && response.status <= 299;\n};\nvar defaultIsJsonContentType = function(headers) {\n    return /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\");\n};\nfunction stripUndefined(obj) {\n    if (!(0, import_toolkit2.isPlainObject)(obj)) {\n        return obj;\n    }\n    var copy = __spreadValues({}, obj);\n    for(var _j = 0, _k = Object.entries(copy); _j < _k.length; _j++){\n        var _l = _k[_j], k = _l[0], v = _l[1];\n        if (v === void 0) delete copy[k];\n    }\n    return copy;\n}\nfunction fetchBaseQuery(_a) {\n    var _this = this;\n    if (_a === void 0) {\n        _a = {};\n    }\n    var _b = _a, baseUrl = _b.baseUrl, _j = _b.prepareHeaders, prepareHeaders = _j === void 0 ? function(x) {\n        return x;\n    } : _j, _k = _b.fetchFn, fetchFn = _k === void 0 ? defaultFetchFn : _k, paramsSerializer = _b.paramsSerializer, _l = _b.isJsonContentType, isJsonContentType = _l === void 0 ? defaultIsJsonContentType : _l, _m = _b.jsonContentType, jsonContentType = _m === void 0 ? \"application/json\" : _m, jsonReplacer = _b.jsonReplacer, defaultTimeout = _b.timeout, globalResponseHandler = _b.responseHandler, globalValidateStatus = _b.validateStatus, baseFetchOptions = __objRest(_b, [\n        \"baseUrl\",\n        \"prepareHeaders\",\n        \"fetchFn\",\n        \"paramsSerializer\",\n        \"isJsonContentType\",\n        \"jsonContentType\",\n        \"jsonReplacer\",\n        \"timeout\",\n        \"responseHandler\",\n        \"validateStatus\"\n    ]);\n    if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n        console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n    }\n    return function(arg, api) {\n        return __async(_this, null, function() {\n            var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _j, headers, _k, params, _l, responseHandler, _m, validateStatus, _o, timeout, rest, config, _p, isJsonifiable, divider, query, request, requestClone, response, timedOut, timeoutId, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;\n            return __generator(this, function(_q) {\n                switch(_q.label){\n                    case 0:\n                        signal = api.signal, getState = api.getState, extra = api.extra, endpoint = api.endpoint, forced = api.forced, type = api.type;\n                        _a2 = typeof arg == \"string\" ? {\n                            url: arg\n                        } : arg, url = _a2.url, _j = _a2.headers, headers = _j === void 0 ? new Headers(baseFetchOptions.headers) : _j, _k = _a2.params, params = _k === void 0 ? void 0 : _k, _l = _a2.responseHandler, responseHandler = _l === void 0 ? globalResponseHandler != null ? globalResponseHandler : \"json\" : _l, _m = _a2.validateStatus, validateStatus = _m === void 0 ? globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus : _m, _o = _a2.timeout, timeout = _o === void 0 ? defaultTimeout : _o, rest = __objRest(_a2, [\n                            \"url\",\n                            \"headers\",\n                            \"params\",\n                            \"responseHandler\",\n                            \"validateStatus\",\n                            \"timeout\"\n                        ]);\n                        config = __spreadValues(__spreadProps(__spreadValues({}, baseFetchOptions), {\n                            signal: signal\n                        }), rest);\n                        headers = new Headers(stripUndefined(headers));\n                        _p = config;\n                        return [\n                            4 /*yield*/ ,\n                            prepareHeaders(headers, {\n                                getState: getState,\n                                extra: extra,\n                                endpoint: endpoint,\n                                forced: forced,\n                                type: type\n                            })\n                        ];\n                    case 1:\n                        _p.headers = _q.sent() || headers;\n                        isJsonifiable = function(body) {\n                            return typeof body === \"object\" && ((0, import_toolkit2.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n                        };\n                        if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n                            config.headers.set(\"content-type\", jsonContentType);\n                        }\n                        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n                            config.body = JSON.stringify(config.body, jsonReplacer);\n                        }\n                        if (params) {\n                            divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n                            query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n                            url += divider + query;\n                        }\n                        url = joinUrls(baseUrl, url);\n                        request = new Request(url, config);\n                        requestClone = new Request(url, config);\n                        meta = {\n                            request: requestClone\n                        };\n                        timedOut = false, timeoutId = timeout && setTimeout(function() {\n                            timedOut = true;\n                            api.abort();\n                        }, timeout);\n                        _q.label = 2;\n                    case 2:\n                        _q.trys.push([\n                            2,\n                            4,\n                            5,\n                            6\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            fetchFn(request)\n                        ];\n                    case 3:\n                        response = _q.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        e_1 = _q.sent();\n                        return [\n                            2 /*return*/ ,\n                            {\n                                error: {\n                                    status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n                                    error: String(e_1)\n                                },\n                                meta: meta\n                            }\n                        ];\n                    case 5:\n                        if (timeoutId) clearTimeout(timeoutId);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        responseClone = response.clone();\n                        meta.response = responseClone;\n                        responseText = \"\";\n                        _q.label = 7;\n                    case 7:\n                        _q.trys.push([\n                            7,\n                            9,\n                            ,\n                            10\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.all([\n                                handleResponse(response, responseHandler).then(function(r) {\n                                    return resultData = r;\n                                }, function(e) {\n                                    return handleResponseError_1 = e;\n                                }),\n                                responseClone.text().then(function(r) {\n                                    return responseText = r;\n                                }, function() {})\n                            ])\n                        ];\n                    case 8:\n                        _q.sent();\n                        if (handleResponseError_1) throw handleResponseError_1;\n                        return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                    case 9:\n                        e_2 = _q.sent();\n                        return [\n                            2 /*return*/ ,\n                            {\n                                error: {\n                                    status: \"PARSING_ERROR\",\n                                    originalStatus: response.status,\n                                    data: responseText,\n                                    error: String(e_2)\n                                },\n                                meta: meta\n                            }\n                        ];\n                    case 10:\n                        return [\n                            2 /*return*/ ,\n                            validateStatus(response, resultData) ? {\n                                data: resultData,\n                                meta: meta\n                            } : {\n                                error: {\n                                    status: response.status,\n                                    data: resultData\n                                },\n                                meta: meta\n                            }\n                        ];\n                }\n            });\n        });\n    };\n    function handleResponse(response, responseHandler) {\n        return __async(this, null, function() {\n            var text;\n            return __generator(this, function(_j) {\n                switch(_j.label){\n                    case 0:\n                        if (typeof responseHandler === \"function\") {\n                            return [\n                                2 /*return*/ ,\n                                responseHandler(response)\n                            ];\n                        }\n                        if (responseHandler === \"content-type\") {\n                            responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n                        }\n                        if (!(responseHandler === \"json\")) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            response.text()\n                        ];\n                    case 1:\n                        text = _j.sent();\n                        return [\n                            2 /*return*/ ,\n                            text.length ? JSON.parse(text) : null\n                        ];\n                    case 2:\n                        return [\n                            2 /*return*/ ,\n                            response.text()\n                        ];\n                }\n            });\n        });\n    }\n}\n// src/query/HandledError.ts\nvar HandledError = /** @class */ function() {\n    function HandledError(value, meta) {\n        if (meta === void 0) {\n            meta = void 0;\n        }\n        this.value = value;\n        this.meta = meta;\n    }\n    return HandledError;\n}();\n// src/query/retry.ts\nfunction defaultBackoff(attempt, maxRetries) {\n    if (attempt === void 0) {\n        attempt = 0;\n    }\n    if (maxRetries === void 0) {\n        maxRetries = 5;\n    }\n    return __async(this, null, function() {\n        var attempts, timeout;\n        return __generator(this, function(_j) {\n            switch(_j.label){\n                case 0:\n                    attempts = Math.min(attempt, maxRetries);\n                    timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n                    return [\n                        4 /*yield*/ ,\n                        new Promise(function(resolve) {\n                            return setTimeout(function(res) {\n                                return resolve(res);\n                            }, timeout);\n                        })\n                    ];\n                case 1:\n                    _j.sent();\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n}\nfunction fail(e) {\n    throw Object.assign(new HandledError({\n        error: e\n    }), {\n        throwImmediately: true\n    });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = function(baseQuery, defaultOptions) {\n    return function(args, api, extraOptions) {\n        return __async(void 0, null, function() {\n            var possibleMaxRetries, maxRetries, defaultRetryCondition, options, retry2, result, e_3;\n            return __generator(this, function(_j) {\n                switch(_j.label){\n                    case 0:\n                        possibleMaxRetries = [\n                            5,\n                            (defaultOptions || EMPTY_OPTIONS).maxRetries,\n                            (extraOptions || EMPTY_OPTIONS).maxRetries\n                        ].filter(function(x) {\n                            return x !== void 0;\n                        });\n                        maxRetries = possibleMaxRetries.slice(-1)[0];\n                        defaultRetryCondition = function(_, __, _j) {\n                            var attempt = _j.attempt;\n                            return attempt <= maxRetries;\n                        };\n                        options = __spreadValues(__spreadValues({\n                            maxRetries: maxRetries,\n                            backoff: defaultBackoff,\n                            retryCondition: defaultRetryCondition\n                        }, defaultOptions), extraOptions);\n                        retry2 = 0;\n                        _j.label = 1;\n                    case 1:\n                        if (false) {}\n                        _j.label = 2;\n                    case 2:\n                        _j.trys.push([\n                            2,\n                            4,\n                            ,\n                            6\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            baseQuery(args, api, extraOptions)\n                        ];\n                    case 3:\n                        result = _j.sent();\n                        if (result.error) {\n                            throw new HandledError(result);\n                        }\n                        return [\n                            2 /*return*/ ,\n                            result\n                        ];\n                    case 4:\n                        e_3 = _j.sent();\n                        retry2++;\n                        if (e_3.throwImmediately) {\n                            if (e_3 instanceof HandledError) {\n                                return [\n                                    2 /*return*/ ,\n                                    e_3.value\n                                ];\n                            }\n                            throw e_3;\n                        }\n                        if (e_3 instanceof HandledError && !options.retryCondition(e_3.value.error, args, {\n                            attempt: retry2,\n                            baseQueryApi: api,\n                            extraOptions: extraOptions\n                        })) {\n                            return [\n                                2 /*return*/ ,\n                                e_3.value\n                            ];\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            options.backoff(retry2, options.maxRetries)\n                        ];\n                    case 5:\n                        _j.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n    fail: fail\n});\n// src/query/core/setupListeners.ts\nvar import_toolkit3 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar onFocus = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n    function defaultHandler() {\n        var handleFocus = function() {\n            return dispatch(onFocus());\n        };\n        var handleFocusLost = function() {\n            return dispatch(onFocusLost());\n        };\n        var handleOnline = function() {\n            return dispatch(onOnline());\n        };\n        var handleOffline = function() {\n            return dispatch(onOffline());\n        };\n        var handleVisibilityChange = function() {\n            if (window.document.visibilityState === \"visible\") {\n                handleFocus();\n            } else {\n                handleFocusLost();\n            }\n        };\n        if (!initialized) {\n            if ( true && window.addEventListener) {\n                window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n                window.addEventListener(\"focus\", handleFocus, false);\n                window.addEventListener(\"online\", handleOnline, false);\n                window.addEventListener(\"offline\", handleOffline, false);\n                initialized = true;\n            }\n        }\n        var unsubscribe = function() {\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n            initialized = false;\n        };\n        return unsubscribe;\n    }\n    return customHandler ? customHandler(dispatch, {\n        onFocus: onFocus,\n        onFocusLost: onFocusLost,\n        onOffline: onOffline,\n        onOnline: onOnline\n    }) : defaultHandler();\n}\n// src/query/core/buildSelectors.ts\nvar import_toolkit7 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/endpointDefinitions.ts\nvar DefinitionType;\n(function(DefinitionType2) {\n    DefinitionType2[\"query\"] = \"query\";\n    DefinitionType2[\"mutation\"] = \"mutation\";\n})(DefinitionType || (DefinitionType = {}));\nfunction isQueryDefinition(e) {\n    return e.type === DefinitionType.query;\n}\nfunction isMutationDefinition(e) {\n    return e.type === DefinitionType.mutation;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n    if (isFunction(description)) {\n        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n    }\n    if (Array.isArray(description)) {\n        return description.map(expandTagDescription).map(assertTagTypes);\n    }\n    return [];\n}\nfunction isFunction(t) {\n    return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n    return typeof description === \"string\" ? {\n        type: description\n    } : description;\n}\n// src/query/core/buildSlice.ts\nvar import_toolkit6 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n    return v != null;\n}\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = function(arg) {\n    return typeof arg[forceQueryFnSymbol] === \"function\";\n};\nfunction buildInitiate(_j) {\n    var serializeQueryArgs = _j.serializeQueryArgs, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, api = _j.api, context = _j.context;\n    var runningQueries = new Map();\n    var runningMutations = new Map();\n    var _k = api.internalActions, unsubscribeQueryResult = _k.unsubscribeQueryResult, removeMutationResult = _k.removeMutationResult, updateSubscriptionOptions = _k.updateSubscriptionOptions;\n    return {\n        buildInitiateQuery: buildInitiateQuery,\n        buildInitiateMutation: buildInitiateMutation,\n        getRunningQueryThunk: getRunningQueryThunk,\n        getRunningMutationThunk: getRunningMutationThunk,\n        getRunningQueriesThunk: getRunningQueriesThunk,\n        getRunningMutationsThunk: getRunningMutationsThunk,\n        getRunningOperationPromises: getRunningOperationPromises,\n        removalWarning: removalWarning\n    };\n    function removalWarning() {\n        throw new Error(\"This method had to be removed due to a conceptual bug in RTK.\\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.\");\n    }\n    function getRunningOperationPromises() {\n        if (typeof process !== \"undefined\" && true) {\n            removalWarning();\n        } else {\n            var extract = function(v) {\n                return Array.from(v.values()).flatMap(function(queriesForStore) {\n                    return queriesForStore ? Object.values(queriesForStore) : [];\n                });\n            };\n            return __spreadArray(__spreadArray([], extract(runningQueries)), extract(runningMutations)).filter(isNotNullish);\n        }\n    }\n    function getRunningQueryThunk(endpointName, queryArgs) {\n        return function(dispatch) {\n            var _a;\n            var endpointDefinition = context.endpointDefinitions[endpointName];\n            var queryCacheKey = serializeQueryArgs({\n                queryArgs: queryArgs,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n        };\n    }\n    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n        return function(dispatch) {\n            var _a;\n            return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];\n        };\n    }\n    function getRunningQueriesThunk() {\n        return function(dispatch) {\n            return Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n        };\n    }\n    function getRunningMutationsThunk() {\n        return function(dispatch) {\n            return Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n        };\n    }\n    function middlewareWarning(dispatch) {\n        if (true) {\n            if (middlewareWarning.triggered) return;\n            var registered = dispatch(api.internalActions.internal_probeSubscription({\n                queryCacheKey: \"DOES_NOT_EXIST\",\n                requestId: \"DUMMY_REQUEST_ID\"\n            }));\n            middlewareWarning.triggered = true;\n            if (typeof registered !== \"boolean\") {\n                throw new Error('Warning: Middleware for RTK-Query API at reducerPath \"' + api.reducerPath + '\" has not been added to the store.\\nYou must add the middleware for RTK-Query to function correctly!');\n            }\n        }\n    }\n    function buildInitiateQuery(endpointName, endpointDefinition) {\n        var queryAction = function(arg, _j) {\n            var _k = _j === void 0 ? {} : _j, _l = _k.subscribe, subscribe = _l === void 0 ? true : _l, forceRefetch = _k.forceRefetch, subscriptionOptions = _k.subscriptionOptions, _m = forceQueryFnSymbol, forceQueryFn = _k[_m];\n            return function(dispatch, getState) {\n                var _j;\n                var _a;\n                var queryCacheKey = serializeQueryArgs({\n                    queryArgs: arg,\n                    endpointDefinition: endpointDefinition,\n                    endpointName: endpointName\n                });\n                var thunk = queryThunk((_j = {\n                    type: \"query\",\n                    subscribe: subscribe,\n                    forceRefetch: forceRefetch,\n                    subscriptionOptions: subscriptionOptions,\n                    endpointName: endpointName,\n                    originalArgs: arg,\n                    queryCacheKey: queryCacheKey\n                }, _j[forceQueryFnSymbol] = forceQueryFn, _j));\n                var selector = api.endpoints[endpointName].select(arg);\n                var thunkResult = dispatch(thunk);\n                var stateAfter = selector(getState());\n                middlewareWarning(dispatch);\n                var requestId = thunkResult.requestId, abort = thunkResult.abort;\n                var skippedSynchronously = stateAfter.requestId !== requestId;\n                var runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n                var selectFromState = function() {\n                    return selector(getState());\n                };\n                var statePromise = Object.assign(forceQueryFn ? thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? Promise.resolve(stateAfter) : Promise.all([\n                    runningQuery,\n                    thunkResult\n                ]).then(selectFromState), {\n                    arg: arg,\n                    requestId: requestId,\n                    subscriptionOptions: subscriptionOptions,\n                    queryCacheKey: queryCacheKey,\n                    abort: abort,\n                    unwrap: function() {\n                        return __async(this, null, function() {\n                            var result;\n                            return __generator(this, function(_j) {\n                                switch(_j.label){\n                                    case 0:\n                                        return [\n                                            4 /*yield*/ ,\n                                            statePromise\n                                        ];\n                                    case 1:\n                                        result = _j.sent();\n                                        if (result.isError) {\n                                            throw result.error;\n                                        }\n                                        return [\n                                            2 /*return*/ ,\n                                            result.data\n                                        ];\n                                }\n                            });\n                        });\n                    },\n                    refetch: function() {\n                        return dispatch(queryAction(arg, {\n                            subscribe: false,\n                            forceRefetch: true\n                        }));\n                    },\n                    unsubscribe: function() {\n                        if (subscribe) dispatch(unsubscribeQueryResult({\n                            queryCacheKey: queryCacheKey,\n                            requestId: requestId\n                        }));\n                    },\n                    updateSubscriptionOptions: function(options) {\n                        statePromise.subscriptionOptions = options;\n                        dispatch(updateSubscriptionOptions({\n                            endpointName: endpointName,\n                            requestId: requestId,\n                            queryCacheKey: queryCacheKey,\n                            options: options\n                        }));\n                    }\n                });\n                if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n                    var running_1 = runningQueries.get(dispatch) || {};\n                    running_1[queryCacheKey] = statePromise;\n                    runningQueries.set(dispatch, running_1);\n                    statePromise.then(function() {\n                        delete running_1[queryCacheKey];\n                        if (!Object.keys(running_1).length) {\n                            runningQueries.delete(dispatch);\n                        }\n                    });\n                }\n                return statePromise;\n            };\n        };\n        return queryAction;\n    }\n    function buildInitiateMutation(endpointName) {\n        return function(arg, _j) {\n            var _k = _j === void 0 ? {} : _j, _l = _k.track, track = _l === void 0 ? true : _l, fixedCacheKey = _k.fixedCacheKey;\n            return function(dispatch, getState) {\n                var thunk = mutationThunk({\n                    type: \"mutation\",\n                    endpointName: endpointName,\n                    originalArgs: arg,\n                    track: track,\n                    fixedCacheKey: fixedCacheKey\n                });\n                var thunkResult = dispatch(thunk);\n                middlewareWarning(dispatch);\n                var requestId = thunkResult.requestId, abort = thunkResult.abort, unwrap = thunkResult.unwrap;\n                var returnValuePromise = thunkResult.unwrap().then(function(data) {\n                    return {\n                        data: data\n                    };\n                }).catch(function(error) {\n                    return {\n                        error: error\n                    };\n                });\n                var reset = function() {\n                    dispatch(removeMutationResult({\n                        requestId: requestId,\n                        fixedCacheKey: fixedCacheKey\n                    }));\n                };\n                var ret = Object.assign(returnValuePromise, {\n                    arg: thunkResult.arg,\n                    requestId: requestId,\n                    abort: abort,\n                    unwrap: unwrap,\n                    unsubscribe: reset,\n                    reset: reset\n                });\n                var running = runningMutations.get(dispatch) || {};\n                runningMutations.set(dispatch, running);\n                running[requestId] = ret;\n                ret.then(function() {\n                    delete running[requestId];\n                    if (!Object.keys(running).length) {\n                        runningMutations.delete(dispatch);\n                    }\n                });\n                if (fixedCacheKey) {\n                    running[fixedCacheKey] = ret;\n                    ret.then(function() {\n                        if (running[fixedCacheKey] === ret) {\n                            delete running[fixedCacheKey];\n                            if (!Object.keys(running).length) {\n                                runningMutations.delete(dispatch);\n                            }\n                        }\n                    });\n                }\n                return ret;\n            };\n        };\n    }\n}\n// src/query/core/buildThunks.ts\nvar import_toolkit4 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar import_immer = __toModule(__webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/index.js\"));\nvar import_toolkit5 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nfunction defaultTransformResponse(baseQueryReturnValue) {\n    return baseQueryReturnValue;\n}\nfunction buildThunks(_j) {\n    var _this = this;\n    var reducerPath = _j.reducerPath, baseQuery = _j.baseQuery, endpointDefinitions = _j.context.endpointDefinitions, serializeQueryArgs = _j.serializeQueryArgs, api = _j.api, assertTagType = _j.assertTagType;\n    var patchQueryData = function(endpointName, args, patches, updateProvided) {\n        return function(dispatch, getState) {\n            var endpointDefinition = endpointDefinitions[endpointName];\n            var queryCacheKey = serializeQueryArgs({\n                queryArgs: args,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            dispatch(api.internalActions.queryResultPatched({\n                queryCacheKey: queryCacheKey,\n                patches: patches\n            }));\n            if (!updateProvided) {\n                return;\n            }\n            var newValue = api.endpoints[endpointName].select(args)(getState());\n            var providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n            dispatch(api.internalActions.updateProvidedBy({\n                queryCacheKey: queryCacheKey,\n                providedTags: providedTags\n            }));\n        };\n    };\n    var updateQueryData = function(endpointName, args, updateRecipe, updateProvided) {\n        if (updateProvided === void 0) {\n            updateProvided = true;\n        }\n        return function(dispatch, getState) {\n            var _j, _k;\n            var endpointDefinition = api.endpoints[endpointName];\n            var currentState = endpointDefinition.select(args)(getState());\n            var ret = {\n                patches: [],\n                inversePatches: [],\n                undo: function() {\n                    return dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided));\n                }\n            };\n            if (currentState.status === QueryStatus.uninitialized) {\n                return ret;\n            }\n            var newValue;\n            if (\"data\" in currentState) {\n                if ((0, import_immer.isDraftable)(currentState.data)) {\n                    var _l = (0, import_immer.produceWithPatches)(currentState.data, updateRecipe), value = _l[0], patches = _l[1], inversePatches = _l[2];\n                    (_j = ret.patches).push.apply(_j, patches);\n                    (_k = ret.inversePatches).push.apply(_k, inversePatches);\n                    newValue = value;\n                } else {\n                    newValue = updateRecipe(currentState.data);\n                    ret.patches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: newValue\n                    });\n                    ret.inversePatches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: currentState.data\n                    });\n                }\n            }\n            dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n            return ret;\n        };\n    };\n    var upsertQueryData = function(endpointName, args, value) {\n        return function(dispatch) {\n            var _j;\n            return dispatch(api.endpoints[endpointName].initiate(args, (_j = {\n                subscribe: false,\n                forceRefetch: true\n            }, _j[forceQueryFnSymbol] = function() {\n                return {\n                    data: value\n                };\n            }, _j)));\n        };\n    };\n    var executeEndpoint = function(_0, _1) {\n        return __async(_this, [\n            _0,\n            _1\n        ], function(arg, _j) {\n            var endpointDefinition, transformResponse, result, baseQueryApi_1, forceQueryFn, what, err, _k, _l, key, _m, error_1, catchedError, transformErrorResponse, _o, e_4;\n            var _p, _q;\n            var signal = _j.signal, abort = _j.abort, rejectWithValue = _j.rejectWithValue, fulfillWithValue = _j.fulfillWithValue, dispatch = _j.dispatch, getState = _j.getState, extra = _j.extra;\n            return __generator(this, function(_r) {\n                switch(_r.label){\n                    case 0:\n                        endpointDefinition = endpointDefinitions[arg.endpointName];\n                        _r.label = 1;\n                    case 1:\n                        _r.trys.push([\n                            1,\n                            8,\n                            ,\n                            13\n                        ]);\n                        transformResponse = defaultTransformResponse;\n                        result = void 0;\n                        baseQueryApi_1 = {\n                            signal: signal,\n                            abort: abort,\n                            dispatch: dispatch,\n                            getState: getState,\n                            extra: extra,\n                            endpoint: arg.endpointName,\n                            type: arg.type,\n                            forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n                        };\n                        forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n                        if (!forceQueryFn) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        result = forceQueryFn();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 2:\n                        if (!endpointDefinition.query) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)\n                        ];\n                    case 3:\n                        result = _r.sent();\n                        if (endpointDefinition.transformResponse) {\n                            transformResponse = endpointDefinition.transformResponse;\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function(arg2) {\n                                return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);\n                            })\n                        ];\n                    case 5:\n                        result = _r.sent();\n                        _r.label = 6;\n                    case 6:\n                        if (typeof process !== \"undefined\" && true) {\n                            what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n                            err = void 0;\n                            if (!result) {\n                                err = what + \" did not return anything.\";\n                            } else if (typeof result !== \"object\") {\n                                err = what + \" did not return an object.\";\n                            } else if (result.error && result.data) {\n                                err = what + \" returned an object containing both `error` and `result`.\";\n                            } else if (result.error === void 0 && result.data === void 0) {\n                                err = what + \" returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`\";\n                            } else {\n                                for(_k = 0, _l = Object.keys(result); _k < _l.length; _k++){\n                                    key = _l[_k];\n                                    if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                                        err = \"The object returned by \" + what + \" has the unknown property \" + key + \".\";\n                                        break;\n                                    }\n                                }\n                            }\n                            if (err) {\n                                console.error(\"Error encountered handling the endpoint \" + arg.endpointName + \".\\n              \" + err + \"\\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\\n              Object returned was:\", result);\n                            }\n                        }\n                        if (result.error) throw new HandledError(result.error, result.meta);\n                        _m = fulfillWithValue;\n                        return [\n                            4 /*yield*/ ,\n                            transformResponse(result.data, result.meta, arg.originalArgs)\n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ ,\n                            _m.apply(void 0, [\n                                _r.sent(),\n                                (_p = {\n                                    fulfilledTimeStamp: Date.now(),\n                                    baseQueryMeta: result.meta\n                                }, _p[import_toolkit5.SHOULD_AUTOBATCH] = true, _p)\n                            ])\n                        ];\n                    case 8:\n                        error_1 = _r.sent();\n                        catchedError = error_1;\n                        if (!(catchedError instanceof HandledError)) return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                        transformErrorResponse = defaultTransformResponse;\n                        if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n                            transformErrorResponse = endpointDefinition.transformErrorResponse;\n                        }\n                        _r.label = 9;\n                    case 9:\n                        _r.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        _o = rejectWithValue;\n                        return [\n                            4 /*yield*/ ,\n                            transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs)\n                        ];\n                    case 10:\n                        return [\n                            2 /*return*/ ,\n                            _o.apply(void 0, [\n                                _r.sent(),\n                                (_q = {\n                                    baseQueryMeta: catchedError.meta\n                                }, _q[import_toolkit5.SHOULD_AUTOBATCH] = true, _q)\n                            ])\n                        ];\n                    case 11:\n                        e_4 = _r.sent();\n                        catchedError = e_4;\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 12:\n                        if (typeof process !== \"undefined\" && true) {\n                            console.error('An unhandled error occurred processing a request for the endpoint \"' + arg.endpointName + '\".\\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".', catchedError);\n                        } else {\n                            console.error(catchedError);\n                        }\n                        throw catchedError;\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    function isForcedQuery(arg, state) {\n        var _a, _b, _c, _d;\n        var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];\n        var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;\n        var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n        var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;\n        if (refetchVal) {\n            return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n        }\n        return false;\n    }\n    var queryThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + \"/executeQuery\", executeEndpoint, {\n        getPendingMeta: function() {\n            var _j;\n            return _j = {\n                startedTimeStamp: Date.now()\n            }, _j[import_toolkit5.SHOULD_AUTOBATCH] = true, _j;\n        },\n        condition: function(queryThunkArgs, _j) {\n            var getState = _j.getState;\n            var _a, _b, _c;\n            var state = getState();\n            var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[queryThunkArgs.queryCacheKey];\n            var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n            var currentArg = queryThunkArgs.originalArgs;\n            var previousArg = requestState == null ? void 0 : requestState.originalArgs;\n            var endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n            if (isUpsertQuery(queryThunkArgs)) {\n                return true;\n            }\n            if ((requestState == null ? void 0 : requestState.status) === \"pending\") {\n                return false;\n            }\n            if (isForcedQuery(queryThunkArgs, state)) {\n                return true;\n            }\n            if (isQueryDefinition(endpointDefinition) && ((_c = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _c.call(endpointDefinition, {\n                currentArg: currentArg,\n                previousArg: previousArg,\n                endpointState: requestState,\n                state: state\n            }))) {\n                return true;\n            }\n            if (fulfilledVal) {\n                return false;\n            }\n            return true;\n        },\n        dispatchConditionRejection: true\n    });\n    var mutationThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + \"/executeMutation\", executeEndpoint, {\n        getPendingMeta: function() {\n            var _j;\n            return _j = {\n                startedTimeStamp: Date.now()\n            }, _j[import_toolkit5.SHOULD_AUTOBATCH] = true, _j;\n        }\n    });\n    var hasTheForce = function(options) {\n        return \"force\" in options;\n    };\n    var hasMaxAge = function(options) {\n        return \"ifOlderThan\" in options;\n    };\n    var prefetch = function(endpointName, arg, options) {\n        return function(dispatch, getState) {\n            var force = hasTheForce(options) && options.force;\n            var maxAge = hasMaxAge(options) && options.ifOlderThan;\n            var queryAction = function(force2) {\n                if (force2 === void 0) {\n                    force2 = true;\n                }\n                return api.endpoints[endpointName].initiate(arg, {\n                    forceRefetch: force2\n                });\n            };\n            var latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n            if (force) {\n                dispatch(queryAction());\n            } else if (maxAge) {\n                var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;\n                if (!lastFulfilledTs) {\n                    dispatch(queryAction());\n                    return;\n                }\n                var shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n                if (shouldRetrigger) {\n                    dispatch(queryAction());\n                }\n            } else {\n                dispatch(queryAction(false));\n            }\n        };\n    };\n    function matchesEndpoint(endpointName) {\n        return function(action) {\n            var _a, _b;\n            return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;\n        };\n    }\n    function buildMatchThunkActions(thunk, endpointName) {\n        return {\n            matchPending: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isPending)(thunk), matchesEndpoint(endpointName)),\n            matchFulfilled: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n            matchRejected: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isRejected)(thunk), matchesEndpoint(endpointName))\n        };\n    }\n    return {\n        queryThunk: queryThunk,\n        mutationThunk: mutationThunk,\n        prefetch: prefetch,\n        updateQueryData: updateQueryData,\n        upsertQueryData: upsertQueryData,\n        patchQueryData: patchQueryData,\n        buildMatchThunkActions: buildMatchThunkActions\n    };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0, import_toolkit4.isFulfilled)(action) ? action.payload : void 0, (0, import_toolkit4.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n// src/query/core/buildSlice.ts\nvar import_immer2 = __toModule(__webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/index.js\"));\nvar import_immer3 = __toModule(__webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/index.js\"));\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n    var substate = state[queryCacheKey];\n    if (substate) {\n        update(substate);\n    }\n}\nfunction getMutationCacheKey(id) {\n    var _a;\n    return (_a = \"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) != null ? _a : id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n    var substate = state[getMutationCacheKey(id)];\n    if (substate) {\n        update(substate);\n    }\n}\nvar initialState = {};\nfunction buildSlice(_j) {\n    var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, _k = _j.context, definitions = _k.endpointDefinitions, apiUid = _k.apiUid, extractRehydrationInfo = _k.extractRehydrationInfo, hasRehydrationInfo = _k.hasRehydrationInfo, assertTagType = _j.assertTagType, config = _j.config;\n    var resetApiState = (0, import_toolkit6.createAction)(reducerPath + \"/resetApiState\");\n    var querySlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/queries\",\n        initialState: initialState,\n        reducers: {\n            removeQueryResult: {\n                reducer: function(draft, _j) {\n                    var queryCacheKey = _j.payload.queryCacheKey;\n                    delete draft[queryCacheKey];\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            },\n            queryResultPatched: {\n                reducer: function(draft, _j) {\n                    var _k = _j.payload, queryCacheKey = _k.queryCacheKey, patches = _k.patches;\n                    updateQuerySubstateIfExists(draft, queryCacheKey, function(substate) {\n                        substate.data = (0, import_immer3.applyPatches)(substate.data, patches.concat());\n                    });\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(queryThunk.pending, function(draft, _j) {\n                var meta = _j.meta, arg = _j.meta.arg;\n                var _a, _b;\n                var upserting = isUpsertQuery(arg);\n                if (arg.subscribe || upserting) {\n                    (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {\n                        status: QueryStatus.uninitialized,\n                        endpointName: arg.endpointName\n                    };\n                }\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {\n                    substate.status = QueryStatus.pending;\n                    substate.requestId = upserting && substate.requestId ? substate.requestId : meta.requestId;\n                    if (arg.originalArgs !== void 0) {\n                        substate.originalArgs = arg.originalArgs;\n                    }\n                    substate.startedTimeStamp = meta.startedTimeStamp;\n                });\n            }).addCase(queryThunk.fulfilled, function(draft, _j) {\n                var meta = _j.meta, payload = _j.payload;\n                updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function(substate) {\n                    var _a;\n                    if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n                    var merge = definitions[meta.arg.endpointName].merge;\n                    substate.status = QueryStatus.fulfilled;\n                    if (merge) {\n                        if (substate.data !== void 0) {\n                            var fulfilledTimeStamp_1 = meta.fulfilledTimeStamp, arg_1 = meta.arg, baseQueryMeta_1 = meta.baseQueryMeta, requestId_1 = meta.requestId;\n                            var newData = (0, import_toolkit6.createNextState)(substate.data, function(draftSubstateData) {\n                                return merge(draftSubstateData, payload, {\n                                    arg: arg_1.originalArgs,\n                                    baseQueryMeta: baseQueryMeta_1,\n                                    fulfilledTimeStamp: fulfilledTimeStamp_1,\n                                    requestId: requestId_1\n                                });\n                            });\n                            substate.data = newData;\n                        } else {\n                            substate.data = payload;\n                        }\n                    } else {\n                        substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing((0, import_immer2.isDraft)(substate.data) ? (0, import_immer3.original)(substate.data) : substate.data, payload) : payload;\n                    }\n                    delete substate.error;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(queryThunk.rejected, function(draft, _j) {\n                var _k = _j.meta, condition = _k.condition, arg = _k.arg, requestId = _k.requestId, error = _j.error, payload = _j.payload;\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {\n                    if (condition) {} else {\n                        if (substate.requestId !== requestId) return;\n                        substate.status = QueryStatus.rejected;\n                        substate.error = payload != null ? payload : error;\n                    }\n                });\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var queries = extractRehydrationInfo(action).queries;\n                for(var _j = 0, _k = Object.entries(queries); _j < _k.length; _j++){\n                    var _l = _k[_j], key = _l[0], entry = _l[1];\n                    if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    var mutationSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/mutations\",\n        initialState: initialState,\n        reducers: {\n            removeMutationResult: {\n                reducer: function(draft, _j) {\n                    var payload = _j.payload;\n                    var cacheKey = getMutationCacheKey(payload);\n                    if (cacheKey in draft) {\n                        delete draft[cacheKey];\n                    }\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(mutationThunk.pending, function(draft, _j) {\n                var meta = _j.meta, _k = _j.meta, requestId = _k.requestId, arg = _k.arg, startedTimeStamp = _k.startedTimeStamp;\n                if (!arg.track) return;\n                draft[getMutationCacheKey(meta)] = {\n                    requestId: requestId,\n                    status: QueryStatus.pending,\n                    endpointName: arg.endpointName,\n                    startedTimeStamp: startedTimeStamp\n                };\n            }).addCase(mutationThunk.fulfilled, function(draft, _j) {\n                var payload = _j.payload, meta = _j.meta;\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, function(substate) {\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = QueryStatus.fulfilled;\n                    substate.data = payload;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(mutationThunk.rejected, function(draft, _j) {\n                var payload = _j.payload, error = _j.error, meta = _j.meta;\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, function(substate) {\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = QueryStatus.rejected;\n                    substate.error = payload != null ? payload : error;\n                });\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var mutations = extractRehydrationInfo(action).mutations;\n                for(var _j = 0, _k = Object.entries(mutations); _j < _k.length; _j++){\n                    var _l = _k[_j], key = _l[0], entry = _l[1];\n                    if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    var invalidationSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/invalidation\",\n        initialState: initialState,\n        reducers: {\n            updateProvidedBy: {\n                reducer: function(draft, action) {\n                    var _a, _b, _c, _d;\n                    var _j = action.payload, queryCacheKey = _j.queryCacheKey, providedTags = _j.providedTags;\n                    for(var _k = 0, _l = Object.values(draft); _k < _l.length; _k++){\n                        var tagTypeSubscriptions = _l[_k];\n                        for(var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++){\n                            var idSubscriptions = _o[_m];\n                            var foundAt = idSubscriptions.indexOf(queryCacheKey);\n                            if (foundAt !== -1) {\n                                idSubscriptions.splice(foundAt, 1);\n                            }\n                        }\n                    }\n                    for(var _p = 0, providedTags_1 = providedTags; _p < providedTags_1.length; _p++){\n                        var _q = providedTags_1[_p], type = _q.type, id = _q.id;\n                        var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n                        var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                        if (!alreadySubscribed) {\n                            subscribedQueries.push(queryCacheKey);\n                        }\n                    }\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(querySlice.actions.removeQueryResult, function(draft, _j) {\n                var queryCacheKey = _j.payload.queryCacheKey;\n                for(var _k = 0, _l = Object.values(draft); _k < _l.length; _k++){\n                    var tagTypeSubscriptions = _l[_k];\n                    for(var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++){\n                        var idSubscriptions = _o[_m];\n                        var foundAt = idSubscriptions.indexOf(queryCacheKey);\n                        if (foundAt !== -1) {\n                            idSubscriptions.splice(foundAt, 1);\n                        }\n                    }\n                }\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var _a, _b, _c, _d;\n                var provided = extractRehydrationInfo(action).provided;\n                for(var _j = 0, _k = Object.entries(provided); _j < _k.length; _j++){\n                    var _l = _k[_j], type = _l[0], incomingTags = _l[1];\n                    for(var _m = 0, _o = Object.entries(incomingTags); _m < _o.length; _m++){\n                        var _p = _o[_m], id = _p[0], cacheKeys = _p[1];\n                        var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n                        for(var _q = 0, cacheKeys_1 = cacheKeys; _q < cacheKeys_1.length; _q++){\n                            var queryCacheKey = cacheKeys_1[_q];\n                            var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                            if (!alreadySubscribed) {\n                                subscribedQueries.push(queryCacheKey);\n                            }\n                        }\n                    }\n                }\n            }).addMatcher((0, import_toolkit6.isAnyOf)((0, import_toolkit6.isFulfilled)(queryThunk), (0, import_toolkit6.isRejectedWithValue)(queryThunk)), function(draft, action) {\n                var providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n                var queryCacheKey = action.meta.arg.queryCacheKey;\n                invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n                    queryCacheKey: queryCacheKey,\n                    providedTags: providedTags\n                }));\n            });\n        }\n    });\n    var subscriptionSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/subscriptions\",\n        initialState: initialState,\n        reducers: {\n            updateSubscriptionOptions: function(d, a) {},\n            unsubscribeQueryResult: function(d, a) {},\n            internal_probeSubscription: function(d, a) {}\n        }\n    });\n    var internalSubscriptionsSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/internalSubscriptions\",\n        initialState: initialState,\n        reducers: {\n            subscriptionsUpdated: {\n                reducer: function(state, action) {\n                    return (0, import_immer3.applyPatches)(state, action.payload);\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        }\n    });\n    var configSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/config\",\n        initialState: __spreadValues({\n            online: isOnline(),\n            focused: isDocumentVisible(),\n            middlewareRegistered: false\n        }, config),\n        reducers: {\n            middlewareRegistered: function(state, _j) {\n                var payload = _j.payload;\n                state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(onOnline, function(state) {\n                state.online = true;\n            }).addCase(onOffline, function(state) {\n                state.online = false;\n            }).addCase(onFocus, function(state) {\n                state.focused = true;\n            }).addCase(onFocusLost, function(state) {\n                state.focused = false;\n            }).addMatcher(hasRehydrationInfo, function(draft) {\n                return __spreadValues({}, draft);\n            });\n        }\n    });\n    var combinedReducer = (0, import_toolkit6.combineReducers)({\n        queries: querySlice.reducer,\n        mutations: mutationSlice.reducer,\n        provided: invalidationSlice.reducer,\n        subscriptions: internalSubscriptionsSlice.reducer,\n        config: configSlice.reducer\n    });\n    var reducer = function(state, action) {\n        return combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n    };\n    var actions = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), internalSubscriptionsSlice.actions), mutationSlice.actions), invalidationSlice.actions), {\n        unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,\n        resetApiState: resetApiState\n    });\n    return {\n        reducer: reducer,\n        actions: actions\n    };\n}\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar skipSelector = skipToken;\nvar initialSubState = {\n    status: QueryStatus.uninitialized\n};\nvar defaultQuerySubState = /* @__PURE__ */ (0, import_toolkit7.createNextState)(initialSubState, function() {});\nvar defaultMutationSubState = /* @__PURE__ */ (0, import_toolkit7.createNextState)(initialSubState, function() {});\nfunction buildSelectors(_j) {\n    var serializeQueryArgs = _j.serializeQueryArgs, reducerPath = _j.reducerPath;\n    var selectSkippedQuery = function(state) {\n        return defaultQuerySubState;\n    };\n    var selectSkippedMutation = function(state) {\n        return defaultMutationSubState;\n    };\n    return {\n        buildQuerySelector: buildQuerySelector,\n        buildMutationSelector: buildMutationSelector,\n        selectInvalidatedBy: selectInvalidatedBy\n    };\n    function withRequestFlags(substate) {\n        return __spreadValues(__spreadValues({}, substate), getRequestStatusFlags(substate.status));\n    }\n    function selectInternalState(rootState) {\n        var state = rootState[reducerPath];\n        if (true) {\n            if (!state) {\n                if (selectInternalState.triggered) return state;\n                selectInternalState.triggered = true;\n                console.error(\"Error: No data found at `state.\" + reducerPath + \"`. Did you forget to add the reducer to the store?\");\n            }\n        }\n        return state;\n    }\n    function buildQuerySelector(endpointName, endpointDefinition) {\n        return function(queryArgs) {\n            var serializedArgs = serializeQueryArgs({\n                queryArgs: queryArgs,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            var selectQuerySubstate = function(state) {\n                var _a, _b, _c;\n                return (_c = (_b = (_a = selectInternalState(state)) == null ? void 0 : _a.queries) == null ? void 0 : _b[serializedArgs]) != null ? _c : defaultQuerySubState;\n            };\n            var finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n            return (0, import_toolkit7.createSelector)(finalSelectQuerySubState, withRequestFlags);\n        };\n    }\n    function buildMutationSelector() {\n        return function(id) {\n            var _a;\n            var mutationId;\n            if (typeof id === \"object\") {\n                mutationId = (_a = getMutationCacheKey(id)) != null ? _a : skipToken;\n            } else {\n                mutationId = id;\n            }\n            var selectMutationSubstate = function(state) {\n                var _a2, _b, _c;\n                return (_c = (_b = (_a2 = selectInternalState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;\n            };\n            var finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n            return (0, import_toolkit7.createSelector)(finalSelectMutationSubstate, withRequestFlags);\n        };\n    }\n    function selectInvalidatedBy(state, tags) {\n        var _a;\n        var apiState = state[reducerPath];\n        var toInvalidate = new Set();\n        for(var _j = 0, _k = tags.map(expandTagDescription); _j < _k.length; _j++){\n            var tag = _k[_j];\n            var provided = apiState.provided[tag.type];\n            if (!provided) {\n                continue;\n            }\n            var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];\n            for(var _l = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _l < invalidateSubscriptions_1.length; _l++){\n                var invalidate = invalidateSubscriptions_1[_l];\n                toInvalidate.add(invalidate);\n            }\n        }\n        return flatten(Array.from(toInvalidate.values()).map(function(queryCacheKey) {\n            var querySubState = apiState.queries[queryCacheKey];\n            return querySubState ? [\n                {\n                    queryCacheKey: queryCacheKey,\n                    endpointName: querySubState.endpointName,\n                    originalArgs: querySubState.originalArgs\n                }\n            ] : [];\n        }));\n    }\n}\n// src/query/defaultSerializeQueryArgs.ts\nvar import_toolkit8 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar cache = WeakMap ? new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = function(_j) {\n    var endpointName = _j.endpointName, queryArgs = _j.queryArgs;\n    var serialized = \"\";\n    var cached = cache == null ? void 0 : cache.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        var stringified = JSON.stringify(queryArgs, function(key, value) {\n            return (0, import_toolkit8.isPlainObject)(value) ? Object.keys(value).sort().reduce(function(acc, key2) {\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value;\n        });\n        if ((0, import_toolkit8.isPlainObject)(queryArgs)) {\n            cache == null ? void 0 : cache.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return endpointName + \"(\" + serialized + \")\";\n};\n// src/query/createApi.ts\nvar import_toolkit9 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar import_reselect = __toModule(__webpack_require__(/*! reselect */ \"(app-pages-browser)/./node_modules/reselect/es/index.js\"));\nfunction buildCreateApi() {\n    var modules = [];\n    for(var _j = 0; _j < arguments.length; _j++){\n        modules[_j] = arguments[_j];\n    }\n    return function baseCreateApi(options) {\n        var extractRehydrationInfo = (0, import_reselect.defaultMemoize)(function(action) {\n            var _a, _b;\n            return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {\n                reducerPath: (_a = options.reducerPath) != null ? _a : \"api\"\n            });\n        });\n        var optionsWithDefaults = __spreadProps(__spreadValues({\n            reducerPath: \"api\",\n            keepUnusedDataFor: 60,\n            refetchOnMountOrArgChange: false,\n            refetchOnFocus: false,\n            refetchOnReconnect: false\n        }, options), {\n            extractRehydrationInfo: extractRehydrationInfo,\n            serializeQueryArgs: function(queryArgsApi) {\n                var finalSerializeQueryArgs = defaultSerializeQueryArgs;\n                if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n                    var endpointSQA_1 = queryArgsApi.endpointDefinition.serializeQueryArgs;\n                    finalSerializeQueryArgs = function(queryArgsApi2) {\n                        var initialResult = endpointSQA_1(queryArgsApi2);\n                        if (typeof initialResult === \"string\") {\n                            return initialResult;\n                        } else {\n                            return defaultSerializeQueryArgs(__spreadProps(__spreadValues({}, queryArgsApi2), {\n                                queryArgs: initialResult\n                            }));\n                        }\n                    };\n                } else if (options.serializeQueryArgs) {\n                    finalSerializeQueryArgs = options.serializeQueryArgs;\n                }\n                return finalSerializeQueryArgs(queryArgsApi);\n            },\n            tagTypes: __spreadArray([], options.tagTypes || [])\n        });\n        var context = {\n            endpointDefinitions: {},\n            batch: function(fn) {\n                fn();\n            },\n            apiUid: (0, import_toolkit9.nanoid)(),\n            extractRehydrationInfo: extractRehydrationInfo,\n            hasRehydrationInfo: (0, import_reselect.defaultMemoize)(function(action) {\n                return extractRehydrationInfo(action) != null;\n            })\n        };\n        var api = {\n            injectEndpoints: injectEndpoints,\n            enhanceEndpoints: function(_j) {\n                var addTagTypes = _j.addTagTypes, endpoints = _j.endpoints;\n                if (addTagTypes) {\n                    for(var _k = 0, addTagTypes_1 = addTagTypes; _k < addTagTypes_1.length; _k++){\n                        var eT = addTagTypes_1[_k];\n                        if (!optionsWithDefaults.tagTypes.includes(eT)) {\n                            ;\n                            optionsWithDefaults.tagTypes.push(eT);\n                        }\n                    }\n                }\n                if (endpoints) {\n                    for(var _l = 0, _m = Object.entries(endpoints); _l < _m.length; _l++){\n                        var _o = _m[_l], endpointName = _o[0], partialDefinition = _o[1];\n                        if (typeof partialDefinition === \"function\") {\n                            partialDefinition(context.endpointDefinitions[endpointName]);\n                        } else {\n                            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n                        }\n                    }\n                }\n                return api;\n            }\n        };\n        var initializedModules = modules.map(function(m) {\n            return m.init(api, optionsWithDefaults, context);\n        });\n        function injectEndpoints(inject) {\n            var evaluatedEndpoints = inject.endpoints({\n                query: function(x) {\n                    return __spreadProps(__spreadValues({}, x), {\n                        type: DefinitionType.query\n                    });\n                },\n                mutation: function(x) {\n                    return __spreadProps(__spreadValues({}, x), {\n                        type: DefinitionType.mutation\n                    });\n                }\n            });\n            for(var _j = 0, _k = Object.entries(evaluatedEndpoints); _j < _k.length; _j++){\n                var _l = _k[_j], endpointName = _l[0], definition = _l[1];\n                if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {\n                    if (typeof process !== \"undefined\" && true) {\n                        console.error(\"called `injectEndpoints` to override already-existing endpointName \" + endpointName + \" without specifying `overrideExisting: true`\");\n                    }\n                    continue;\n                }\n                context.endpointDefinitions[endpointName] = definition;\n                for(var _m = 0, initializedModules_1 = initializedModules; _m < initializedModules_1.length; _m++){\n                    var m = initializedModules_1[_m];\n                    m.injectEndpoint(endpointName, definition);\n                }\n            }\n            return api;\n        }\n        return api.injectEndpoints({\n            endpoints: options.endpoints\n        });\n    };\n}\n// src/query/fakeBaseQuery.ts\nfunction fakeBaseQuery() {\n    return function() {\n        throw new Error(\"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n    };\n}\n// src/query/core/buildMiddleware/index.ts\nvar import_toolkit13 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n    for(var k in obj){\n        return false;\n    }\n    return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = function(_j) {\n    var reducerPath = _j.reducerPath, api = _j.api, context = _j.context, internalState = _j.internalState;\n    var _k = api.internalActions, removeQueryResult = _k.removeQueryResult, unsubscribeQueryResult = _k.unsubscribeQueryResult;\n    function anySubscriptionsRemainingForKey(queryCacheKey) {\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        return !!subscriptions && !isObjectEmpty(subscriptions);\n    }\n    var currentRemovalTimeouts = {};\n    var handler = function(action, mwApi, internalState2) {\n        var _a;\n        if (unsubscribeQueryResult.match(action)) {\n            var state = mwApi.getState()[reducerPath];\n            var queryCacheKey = action.payload.queryCacheKey;\n            handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);\n        }\n        if (api.util.resetApiState.match(action)) {\n            for(var _j = 0, _k = Object.entries(currentRemovalTimeouts); _j < _k.length; _j++){\n                var _l = _k[_j], key = _l[0], timeout = _l[1];\n                if (timeout) clearTimeout(timeout);\n                delete currentRemovalTimeouts[key];\n            }\n        }\n        if (context.hasRehydrationInfo(action)) {\n            var state = mwApi.getState()[reducerPath];\n            var queries = context.extractRehydrationInfo(action).queries;\n            for(var _m = 0, _o = Object.entries(queries); _m < _o.length; _m++){\n                var _p = _o[_m], queryCacheKey = _p[0], queryState = _p[1];\n                handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);\n            }\n        }\n    };\n    function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n        var _a;\n        var endpointDefinition = context.endpointDefinitions[endpointName];\n        var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config.keepUnusedDataFor;\n        if (keepUnusedDataFor === Infinity) {\n            return;\n        }\n        var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n            var currentTimeout = currentRemovalTimeouts[queryCacheKey];\n            if (currentTimeout) {\n                clearTimeout(currentTimeout);\n            }\n            currentRemovalTimeouts[queryCacheKey] = setTimeout(function() {\n                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n                    api2.dispatch(removeQueryResult({\n                        queryCacheKey: queryCacheKey\n                    }));\n                }\n                delete currentRemovalTimeouts[queryCacheKey];\n            }, finalKeepUnusedDataFor * 1e3);\n        }\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar import_toolkit10 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar buildInvalidationByTagsHandler = function(_j) {\n    var reducerPath = _j.reducerPath, context = _j.context, endpointDefinitions = _j.context.endpointDefinitions, mutationThunk = _j.mutationThunk, api = _j.api, assertTagType = _j.assertTagType, refetchQuery = _j.refetchQuery;\n    var removeQueryResult = api.internalActions.removeQueryResult;\n    var isThunkActionWithTags = (0, import_toolkit10.isAnyOf)((0, import_toolkit10.isFulfilled)(mutationThunk), (0, import_toolkit10.isRejectedWithValue)(mutationThunk));\n    var handler = function(action, mwApi) {\n        if (isThunkActionWithTags(action)) {\n            invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n        }\n        if (api.util.invalidateTags.match(action)) {\n            invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n        }\n    };\n    function invalidateTags(tags, mwApi) {\n        var rootState = mwApi.getState();\n        var state = rootState[reducerPath];\n        var toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n        context.batch(function() {\n            var _a;\n            var valuesArray = Array.from(toInvalidate.values());\n            for(var _j = 0, valuesArray_1 = valuesArray; _j < valuesArray_1.length; _j++){\n                var queryCacheKey = valuesArray_1[_j].queryCacheKey;\n                var querySubState = state.queries[queryCacheKey];\n                var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};\n                if (querySubState) {\n                    if (Object.keys(subscriptionSubState).length === 0) {\n                        mwApi.dispatch(removeQueryResult({\n                            queryCacheKey: queryCacheKey\n                        }));\n                    } else if (querySubState.status !== QueryStatus.uninitialized) {\n                        mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = function(_j) {\n    var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, api = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;\n    var currentPolls = {};\n    var handler = function(action, mwApi) {\n        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n            updatePollingInterval(action.payload, mwApi);\n        }\n        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n            updatePollingInterval(action.meta.arg, mwApi);\n        }\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n            startNextPoll(action.meta.arg, mwApi);\n        }\n        if (api.util.resetApiState.match(action)) {\n            clearPolls();\n        }\n    };\n    function startNextPoll(_j, api2) {\n        var queryCacheKey = _j.queryCacheKey;\n        var state = api2.getState()[reducerPath];\n        var querySubState = state.queries[queryCacheKey];\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === QueryStatus.uninitialized) return;\n        var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) return;\n        var currentPoll = currentPolls[queryCacheKey];\n        if (currentPoll == null ? void 0 : currentPoll.timeout) {\n            clearTimeout(currentPoll.timeout);\n            currentPoll.timeout = void 0;\n        }\n        var nextPollTimestamp = Date.now() + lowestPollingInterval;\n        var currentInterval = currentPolls[queryCacheKey] = {\n            nextPollTimestamp: nextPollTimestamp,\n            pollingInterval: lowestPollingInterval,\n            timeout: setTimeout(function() {\n                currentInterval.timeout = void 0;\n                api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n            }, lowestPollingInterval)\n        };\n    }\n    function updatePollingInterval(_j, api2) {\n        var queryCacheKey = _j.queryCacheKey;\n        var state = api2.getState()[reducerPath];\n        var querySubState = state.queries[queryCacheKey];\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === QueryStatus.uninitialized) {\n            return;\n        }\n        var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) {\n            cleanupPollForKey(queryCacheKey);\n            return;\n        }\n        var currentPoll = currentPolls[queryCacheKey];\n        var nextPollTimestamp = Date.now() + lowestPollingInterval;\n        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n            startNextPoll({\n                queryCacheKey: queryCacheKey\n            }, api2);\n        }\n    }\n    function cleanupPollForKey(key) {\n        var existingPoll = currentPolls[key];\n        if (existingPoll == null ? void 0 : existingPoll.timeout) {\n            clearTimeout(existingPoll.timeout);\n        }\n        delete currentPolls[key];\n    }\n    function clearPolls() {\n        for(var _j = 0, _k = Object.keys(currentPolls); _j < _k.length; _j++){\n            var key = _k[_j];\n            cleanupPollForKey(key);\n        }\n    }\n    function findLowestPollingInterval(subscribers) {\n        if (subscribers === void 0) {\n            subscribers = {};\n        }\n        var lowestPollingInterval = Number.POSITIVE_INFINITY;\n        for(var key in subscribers){\n            if (!!subscribers[key].pollingInterval) {\n                lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n            }\n        }\n        return lowestPollingInterval;\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = function(_j) {\n    var reducerPath = _j.reducerPath, context = _j.context, api = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;\n    var removeQueryResult = api.internalActions.removeQueryResult;\n    var handler = function(action, mwApi) {\n        if (onFocus.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnFocus\");\n        }\n        if (onOnline.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnReconnect\");\n        }\n    };\n    function refetchValidQueries(api2, type) {\n        var state = api2.getState()[reducerPath];\n        var queries = state.queries;\n        var subscriptions = internalState.currentSubscriptions;\n        context.batch(function() {\n            for(var _j = 0, _k = Object.keys(subscriptions); _j < _k.length; _j++){\n                var queryCacheKey = _k[_j];\n                var querySubState = queries[queryCacheKey];\n                var subscriptionSubState = subscriptions[queryCacheKey];\n                if (!subscriptionSubState || !querySubState) continue;\n                var shouldRefetch = Object.values(subscriptionSubState).some(function(sub) {\n                    return sub[type] === true;\n                }) || Object.values(subscriptionSubState).every(function(sub) {\n                    return sub[type] === void 0;\n                }) && state.config[type];\n                if (shouldRefetch) {\n                    if (Object.keys(subscriptionSubState).length === 0) {\n                        api2.dispatch(removeQueryResult({\n                            queryCacheKey: queryCacheKey\n                        }));\n                    } else if (querySubState.status !== QueryStatus.uninitialized) {\n                        api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar import_toolkit11 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = function(_j) {\n    var api = _j.api, reducerPath = _j.reducerPath, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, internalState = _j.internalState;\n    var isQueryThunk = (0, import_toolkit11.isAsyncThunkAction)(queryThunk);\n    var isMutationThunk = (0, import_toolkit11.isAsyncThunkAction)(mutationThunk);\n    var isFulfilledThunk = (0, import_toolkit11.isFulfilled)(queryThunk, mutationThunk);\n    var lifecycleMap = {};\n    var handler = function(action, mwApi, stateBefore) {\n        var cacheKey = getCacheKey(action);\n        if (queryThunk.pending.match(action)) {\n            var oldState = stateBefore[reducerPath].queries[cacheKey];\n            var state = mwApi.getState()[reducerPath].queries[cacheKey];\n            if (!oldState && state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (mutationThunk.pending.match(action)) {\n            var state = mwApi.getState()[reducerPath].mutations[cacheKey];\n            if (state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (isFulfilledThunk(action)) {\n            var lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle == null ? void 0 : lifecycle.valueResolved) {\n                lifecycle.valueResolved({\n                    data: action.payload,\n                    meta: action.meta.baseQueryMeta\n                });\n                delete lifecycle.valueResolved;\n            }\n        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n            var lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle) {\n                delete lifecycleMap[cacheKey];\n                lifecycle.cacheEntryRemoved();\n            }\n        } else if (api.util.resetApiState.match(action)) {\n            for(var _j = 0, _k = Object.entries(lifecycleMap); _j < _k.length; _j++){\n                var _l = _k[_j], cacheKey2 = _l[0], lifecycle = _l[1];\n                delete lifecycleMap[cacheKey2];\n                lifecycle.cacheEntryRemoved();\n            }\n        }\n    };\n    function getCacheKey(action) {\n        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n        if (isMutationThunk(action)) return action.meta.requestId;\n        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n        return \"\";\n    }\n    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n        var endpointDefinition = context.endpointDefinitions[endpointName];\n        var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;\n        if (!onCacheEntryAdded) return;\n        var lifecycle = {};\n        var cacheEntryRemoved = new Promise(function(resolve) {\n            lifecycle.cacheEntryRemoved = resolve;\n        });\n        var cacheDataLoaded = Promise.race([\n            new Promise(function(resolve) {\n                lifecycle.valueResolved = resolve;\n            }),\n            cacheEntryRemoved.then(function() {\n                throw neverResolvedError;\n            })\n        ]);\n        cacheDataLoaded.catch(function() {});\n        lifecycleMap[queryCacheKey] = lifecycle;\n        var selector = api.endpoints[endpointName].select(endpointDefinition.type === DefinitionType.query ? originalArgs : queryCacheKey);\n        var extra = mwApi.dispatch(function(_, __, extra2) {\n            return extra2;\n        });\n        var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n            getCacheEntry: function() {\n                return selector(mwApi.getState());\n            },\n            requestId: requestId,\n            extra: extra,\n            updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {\n                return mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe));\n            } : void 0,\n            cacheDataLoaded: cacheDataLoaded,\n            cacheEntryRemoved: cacheEntryRemoved\n        });\n        var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n        Promise.resolve(runningHandler).catch(function(e) {\n            if (e === neverResolvedError) return;\n            throw e;\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar import_toolkit12 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar buildQueryLifecycleHandler = function(_j) {\n    var api = _j.api, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;\n    var isPendingThunk = (0, import_toolkit12.isPending)(queryThunk, mutationThunk);\n    var isRejectedThunk = (0, import_toolkit12.isRejected)(queryThunk, mutationThunk);\n    var isFullfilledThunk = (0, import_toolkit12.isFulfilled)(queryThunk, mutationThunk);\n    var lifecycleMap = {};\n    var handler = function(action, mwApi) {\n        var _a, _b, _c;\n        if (isPendingThunk(action)) {\n            var _j = action.meta, requestId = _j.requestId, _k = _j.arg, endpointName_1 = _k.endpointName, originalArgs_1 = _k.originalArgs;\n            var endpointDefinition = context.endpointDefinitions[endpointName_1];\n            var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;\n            if (onQueryStarted) {\n                var lifecycle_1 = {};\n                var queryFulfilled = new Promise(function(resolve, reject) {\n                    lifecycle_1.resolve = resolve;\n                    lifecycle_1.reject = reject;\n                });\n                queryFulfilled.catch(function() {});\n                lifecycleMap[requestId] = lifecycle_1;\n                var selector_1 = api.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType.query ? originalArgs_1 : requestId);\n                var extra = mwApi.dispatch(function(_, __, extra2) {\n                    return extra2;\n                });\n                var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n                    getCacheEntry: function() {\n                        return selector_1(mwApi.getState());\n                    },\n                    requestId: requestId,\n                    extra: extra,\n                    updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {\n                        return mwApi.dispatch(api.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));\n                    } : void 0,\n                    queryFulfilled: queryFulfilled\n                });\n                onQueryStarted(originalArgs_1, lifecycleApi);\n            }\n        } else if (isFullfilledThunk(action)) {\n            var _l = action.meta, requestId = _l.requestId, baseQueryMeta = _l.baseQueryMeta;\n            (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({\n                data: action.payload,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        } else if (isRejectedThunk(action)) {\n            var _m = action.meta, requestId = _m.requestId, rejectedWithValue = _m.rejectedWithValue, baseQueryMeta = _m.baseQueryMeta;\n            (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({\n                error: (_b = action.payload) != null ? _b : action.error,\n                isUnhandledError: !rejectedWithValue,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        }\n    };\n    return handler;\n};\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = function(_j) {\n    var api = _j.api, apiUid = _j.context.apiUid, reducerPath = _j.reducerPath;\n    return function(action, mwApi) {\n        var _a, _b;\n        if (api.util.resetApiState.match(action)) {\n            mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        if (typeof process !== \"undefined\" && true) {\n            if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === \"conflict\") {\n                console.warn('There is a mismatch between slice and middleware for the reducerPath \"' + reducerPath + '\".\\nYou can only have one api per reducer path, this will lead to crashes in various situations!' + (reducerPath === \"api\" ? \"\\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!\" : \"\"));\n            }\n        }\n    };\n};\n// src/query/core/buildMiddleware/batchActions.ts\nvar import_immer4 = __toModule(__webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/index.js\"));\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( true ? window : 0) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar buildBatchedActionsHandler = function(_j) {\n    var api = _j.api, queryThunk = _j.queryThunk, internalState = _j.internalState;\n    var subscriptionsPrefix = api.reducerPath + \"/subscriptions\";\n    var previousSubscriptions = null;\n    var dispatchQueued = false;\n    var _k = api.internalActions, updateSubscriptionOptions = _k.updateSubscriptionOptions, unsubscribeQueryResult = _k.unsubscribeQueryResult;\n    var actuallyMutateSubscriptions = function(mutableState, action) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n        if (updateSubscriptionOptions.match(action)) {\n            var _j = action.payload, queryCacheKey = _j.queryCacheKey, requestId = _j.requestId, options = _j.options;\n            if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {\n                mutableState[queryCacheKey][requestId] = options;\n            }\n            return true;\n        }\n        if (unsubscribeQueryResult.match(action)) {\n            var _k = action.payload, queryCacheKey = _k.queryCacheKey, requestId = _k.requestId;\n            if (mutableState[queryCacheKey]) {\n                delete mutableState[queryCacheKey][requestId];\n            }\n            return true;\n        }\n        if (api.internalActions.removeQueryResult.match(action)) {\n            delete mutableState[action.payload.queryCacheKey];\n            return true;\n        }\n        if (queryThunk.pending.match(action)) {\n            var _l = action.meta, arg = _l.arg, requestId = _l.requestId;\n            if (arg.subscribe) {\n                var substate = (_c = mutableState[_b = arg.queryCacheKey]) != null ? _c : mutableState[_b] = {};\n                substate[requestId] = (_e = (_d = arg.subscriptionOptions) != null ? _d : substate[requestId]) != null ? _e : {};\n                return true;\n            }\n        }\n        if (queryThunk.rejected.match(action)) {\n            var _m = action.meta, condition = _m.condition, arg = _m.arg, requestId = _m.requestId;\n            if (condition && arg.subscribe) {\n                var substate = (_g = mutableState[_f = arg.queryCacheKey]) != null ? _g : mutableState[_f] = {};\n                substate[requestId] = (_i = (_h = arg.subscriptionOptions) != null ? _h : substate[requestId]) != null ? _i : {};\n                return true;\n            }\n        }\n        return false;\n    };\n    return function(action, mwApi) {\n        var _a, _b;\n        if (!previousSubscriptions) {\n            previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n        }\n        if (api.util.resetApiState.match(action)) {\n            previousSubscriptions = internalState.currentSubscriptions = {};\n            return [\n                true,\n                false\n            ];\n        }\n        if (api.internalActions.internal_probeSubscription.match(action)) {\n            var _j = action.payload, queryCacheKey = _j.queryCacheKey, requestId = _j.requestId;\n            var hasSubscription = !!((_a = internalState.currentSubscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);\n            return [\n                false,\n                hasSubscription\n            ];\n        }\n        var didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n        if (didMutate) {\n            if (!dispatchQueued) {\n                queueMicrotaskShim(function() {\n                    var newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n                    var _j = (0, import_immer4.produceWithPatches)(previousSubscriptions, function() {\n                        return newSubscriptions;\n                    }), patches = _j[1];\n                    mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n                    previousSubscriptions = newSubscriptions;\n                    dispatchQueued = false;\n                });\n                dispatchQueued = true;\n            }\n            var isSubscriptionSliceAction = !!((_b = action.type) == null ? void 0 : _b.startsWith(subscriptionsPrefix));\n            var isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n            var actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n            return [\n                actionShouldContinue,\n                false\n            ];\n        }\n        return [\n            true,\n            false\n        ];\n    };\n};\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n    var reducerPath = input.reducerPath, queryThunk = input.queryThunk, api = input.api, context = input.context;\n    var apiUid = context.apiUid;\n    var actions = {\n        invalidateTags: (0, import_toolkit13.createAction)(reducerPath + \"/invalidateTags\")\n    };\n    var isThisApiSliceAction = function(action) {\n        return !!action && typeof action.type === \"string\" && action.type.startsWith(reducerPath + \"/\");\n    };\n    var handlerBuilders = [\n        buildDevCheckHandler,\n        buildCacheCollectionHandler,\n        buildInvalidationByTagsHandler,\n        buildPollingHandler,\n        buildCacheLifecycleHandler,\n        buildQueryLifecycleHandler\n    ];\n    var middleware = function(mwApi) {\n        var initialized2 = false;\n        var internalState = {\n            currentSubscriptions: {}\n        };\n        var builderArgs = __spreadProps(__spreadValues({}, input), {\n            internalState: internalState,\n            refetchQuery: refetchQuery\n        });\n        var handlers = handlerBuilders.map(function(build) {\n            return build(builderArgs);\n        });\n        var batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n        var windowEventsHandler = buildWindowEventHandler(builderArgs);\n        return function(next) {\n            return function(action) {\n                if (!initialized2) {\n                    initialized2 = true;\n                    mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n                }\n                var mwApiWithNext = __spreadProps(__spreadValues({}, mwApi), {\n                    next: next\n                });\n                var stateBefore = mwApi.getState();\n                var _j = batchedActionsHandler(action, mwApiWithNext, stateBefore), actionShouldContinue = _j[0], hasSubscription = _j[1];\n                var res;\n                if (actionShouldContinue) {\n                    res = next(action);\n                } else {\n                    res = hasSubscription;\n                }\n                if (!!mwApi.getState()[reducerPath]) {\n                    windowEventsHandler(action, mwApiWithNext, stateBefore);\n                    if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n                        for(var _k = 0, handlers_1 = handlers; _k < handlers_1.length; _k++){\n                            var handler = handlers_1[_k];\n                            handler(action, mwApiWithNext, stateBefore);\n                        }\n                    }\n                }\n                return res;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        actions: actions\n    };\n    function refetchQuery(querySubState, queryCacheKey, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        return queryThunk(__spreadValues({\n            type: \"query\",\n            endpointName: querySubState.endpointName,\n            originalArgs: querySubState.originalArgs,\n            subscribe: false,\n            forceRefetch: true,\n            queryCacheKey: queryCacheKey\n        }, override));\n    }\n}\n// src/query/tsHelpers.ts\nfunction assertCast(v) {}\nfunction safeAssign(target) {\n    var args = [];\n    for(var _j = 1; _j < arguments.length; _j++){\n        args[_j - 1] = arguments[_j];\n    }\n    Object.assign.apply(Object, __spreadArray([\n        target\n    ], args));\n}\n// src/query/core/module.ts\nvar import_immer5 = __toModule(__webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/index.js\"));\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = function() {\n    return {\n        name: coreModuleName,\n        init: function(api, _j, context) {\n            var baseQuery = _j.baseQuery, tagTypes = _j.tagTypes, reducerPath = _j.reducerPath, serializeQueryArgs = _j.serializeQueryArgs, keepUnusedDataFor = _j.keepUnusedDataFor, refetchOnMountOrArgChange = _j.refetchOnMountOrArgChange, refetchOnFocus = _j.refetchOnFocus, refetchOnReconnect = _j.refetchOnReconnect;\n            (0, import_immer5.enablePatches)();\n            assertCast(serializeQueryArgs);\n            var assertTagType = function(tag) {\n                if (typeof process !== \"undefined\" && true) {\n                    if (!tagTypes.includes(tag.type)) {\n                        console.error(\"Tag type '\" + tag.type + \"' was used, but not specified in `tagTypes`!\");\n                    }\n                }\n                return tag;\n            };\n            Object.assign(api, {\n                reducerPath: reducerPath,\n                endpoints: {},\n                internalActions: {\n                    onOnline: onOnline,\n                    onOffline: onOffline,\n                    onFocus: onFocus,\n                    onFocusLost: onFocusLost\n                },\n                util: {}\n            });\n            var _k = buildThunks({\n                baseQuery: baseQuery,\n                reducerPath: reducerPath,\n                context: context,\n                api: api,\n                serializeQueryArgs: serializeQueryArgs,\n                assertTagType: assertTagType\n            }), queryThunk = _k.queryThunk, mutationThunk = _k.mutationThunk, patchQueryData = _k.patchQueryData, updateQueryData = _k.updateQueryData, upsertQueryData = _k.upsertQueryData, prefetch = _k.prefetch, buildMatchThunkActions = _k.buildMatchThunkActions;\n            var _l = buildSlice({\n                context: context,\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                reducerPath: reducerPath,\n                assertTagType: assertTagType,\n                config: {\n                    refetchOnFocus: refetchOnFocus,\n                    refetchOnReconnect: refetchOnReconnect,\n                    refetchOnMountOrArgChange: refetchOnMountOrArgChange,\n                    keepUnusedDataFor: keepUnusedDataFor,\n                    reducerPath: reducerPath\n                }\n            }), reducer = _l.reducer, sliceActions = _l.actions;\n            safeAssign(api.util, {\n                patchQueryData: patchQueryData,\n                updateQueryData: updateQueryData,\n                upsertQueryData: upsertQueryData,\n                prefetch: prefetch,\n                resetApiState: sliceActions.resetApiState\n            });\n            safeAssign(api.internalActions, sliceActions);\n            var _m = buildMiddleware({\n                reducerPath: reducerPath,\n                context: context,\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                api: api,\n                assertTagType: assertTagType\n            }), middleware = _m.middleware, middlewareActions = _m.actions;\n            safeAssign(api.util, middlewareActions);\n            safeAssign(api, {\n                reducer: reducer,\n                middleware: middleware\n            });\n            var _o = buildSelectors({\n                serializeQueryArgs: serializeQueryArgs,\n                reducerPath: reducerPath\n            }), buildQuerySelector = _o.buildQuerySelector, buildMutationSelector = _o.buildMutationSelector, selectInvalidatedBy = _o.selectInvalidatedBy;\n            safeAssign(api.util, {\n                selectInvalidatedBy: selectInvalidatedBy\n            });\n            var _p = buildInitiate({\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                api: api,\n                serializeQueryArgs: serializeQueryArgs,\n                context: context\n            }), buildInitiateQuery = _p.buildInitiateQuery, buildInitiateMutation = _p.buildInitiateMutation, getRunningMutationThunk = _p.getRunningMutationThunk, getRunningMutationsThunk = _p.getRunningMutationsThunk, getRunningQueriesThunk = _p.getRunningQueriesThunk, getRunningQueryThunk = _p.getRunningQueryThunk, getRunningOperationPromises = _p.getRunningOperationPromises, removalWarning = _p.removalWarning;\n            safeAssign(api.util, {\n                getRunningOperationPromises: getRunningOperationPromises,\n                getRunningOperationPromise: removalWarning,\n                getRunningMutationThunk: getRunningMutationThunk,\n                getRunningMutationsThunk: getRunningMutationsThunk,\n                getRunningQueryThunk: getRunningQueryThunk,\n                getRunningQueriesThunk: getRunningQueriesThunk\n            });\n            return {\n                name: coreModuleName,\n                injectEndpoint: function(endpointName, definition) {\n                    var _a, _b;\n                    var anyApi = api;\n                    (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};\n                    if (isQueryDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildQuerySelector(endpointName, definition),\n                            initiate: buildInitiateQuery(endpointName, definition)\n                        }, buildMatchThunkActions(queryThunk, endpointName));\n                    } else if (isMutationDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildMutationSelector(),\n                            initiate: buildInitiateMutation(endpointName)\n                        }, buildMatchThunkActions(mutationThunk, endpointName));\n                    }\n                }\n            };\n        }\n    };\n};\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule()); //# sourceMappingURL=rtk-query.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcnRrLXF1ZXJ5LmNqcy5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEsY0FBYyxJQUFLLElBQUksSUFBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMsT0FBTyxFQUFFQyxJQUFJO0lBQ25FLElBQUlDLElBQUk7UUFBRUMsT0FBTztRQUFHQyxNQUFNO1lBQWEsSUFBSUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU1BLENBQUMsQ0FBQyxFQUFFO1lBQUUsT0FBT0EsQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUFHQyxNQUFNLEVBQUU7UUFBRUMsS0FBSyxFQUFFO0lBQUMsR0FBR0MsR0FBR0MsR0FBR0osR0FBR0s7SUFDL0csT0FBT0EsSUFBSTtRQUFFQyxNQUFNQyxLQUFLO1FBQUksU0FBU0EsS0FBSztRQUFJLFVBQVVBLEtBQUs7SUFBRyxHQUFHLE9BQU9DLFdBQVcsY0FBZUgsQ0FBQUEsQ0FBQyxDQUFDRyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUFhLE9BQU8sSUFBSTtJQUFFLElBQUlKO0lBQ3ZKLFNBQVNFLEtBQUtHLENBQUM7UUFBSSxPQUFPLFNBQVVDLENBQUM7WUFBSSxPQUFPQyxLQUFLO2dCQUFDRjtnQkFBR0M7YUFBRTtRQUFHO0lBQUc7SUFDakUsU0FBU0MsS0FBS0MsRUFBRTtRQUNaLElBQUlWLEdBQUcsTUFBTSxJQUFJVyxVQUFVO1FBQzNCLE1BQU9qQixFQUFHLElBQUk7WUFDVixJQUFJTSxJQUFJLEdBQUdDLEtBQU1KLENBQUFBLElBQUlhLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSVQsQ0FBQyxDQUFDLFNBQVMsR0FBR1MsRUFBRSxDQUFDLEVBQUUsR0FBR1QsQ0FBQyxDQUFDLFFBQVEsSUFBSyxFQUFDSixJQUFJSSxDQUFDLENBQUMsU0FBUyxLQUFLSixFQUFFZSxJQUFJLENBQUNYLElBQUksS0FBS0EsRUFB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RSw2QkFBNkJBO2dCQUM3QitaLDRCQUE0QjlaO2dCQUM1QkoseUJBQXlCQTtnQkFDekJFLDBCQUEwQkE7Z0JBQzFCSCxzQkFBc0JBO2dCQUN0QkUsd0JBQXdCQTtZQUM1QjtZQUNBLE9BQU87Z0JBQ0huUCxNQUFNMkI7Z0JBQ05xZixnQkFBZ0IsU0FBVW5SLFlBQVksRUFBRWdSLFVBQVU7b0JBQzlDLElBQUloYixJQUFJRTtvQkFDUixJQUFJc2pCLFNBQVNuaUI7b0JBQ1puQixDQUFBQSxLQUFLLENBQUNGLEtBQUt3akIsT0FBT25ZLFNBQVMsQ0FBQyxDQUFDckIsYUFBYSxLQUFLLE9BQU85SixLQUFLRixFQUFFLENBQUNnSyxhQUFhLEdBQUcsQ0FBQztvQkFDaEYsSUFBSXhDLGtCQUFrQndULGFBQWE7d0JBQy9Ca0ksV0FBV00sT0FBT25ZLFNBQVMsQ0FBQ3JCLGFBQWEsRUFBRTs0QkFDdkM3UCxNQUFNNlA7NEJBQ05zQixRQUFRNEwsbUJBQW1CbE4sY0FBY2dSOzRCQUN6Qy9NLFVBQVUvRSxtQkFBbUJjLGNBQWNnUjt3QkFDL0MsR0FBR3pKLHVCQUF1Qi9JLFlBQVl3QjtvQkFDMUMsT0FDSyxJQUFJdkMscUJBQXFCdVQsYUFBYTt3QkFDdkNrSSxXQUFXTSxPQUFPblksU0FBUyxDQUFDckIsYUFBYSxFQUFFOzRCQUN2QzdQLE1BQU02UDs0QkFDTnNCLFFBQVE2TDs0QkFDUmxKLFVBQVU5RSxzQkFBc0JhO3dCQUNwQyxHQUFHdUgsdUJBQXVCOUksZUFBZXVCO29CQUM3QztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtBQUFJO0FBQ0osMEJBQTBCO0FBQzFCLElBQUlqTyxZQUFZLGFBQWEsR0FBR0osZUFBZUUsZUFDL0MscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcnRrLXF1ZXJ5LmNqcy5kZXZlbG9wbWVudC5qcz9mZjE5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59O1xyXG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xyXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xyXG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xyXG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xyXG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcclxudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xyXG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XHJcbnZhciBfX2RlZk5vcm1hbFByb3AgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7IH07XHJcbnZhciBfX3NwcmVhZFZhbHVlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXHJcbiAgICAgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxyXG4gICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gX19nZXRPd25Qcm9wU3ltYm9scyhiKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBfa1tfal07XHJcbiAgICAgICAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxudmFyIF9fc3ByZWFkUHJvcHMgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7IH07XHJcbnZhciBfX21hcmtBc01vZHVsZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pOyB9O1xyXG52YXIgX19vYmpSZXN0ID0gZnVuY3Rpb24gKHNvdXJjZSwgZXhjbHVkZSkge1xyXG4gICAgdmFyIHRhcmdldCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXHJcbiAgICAgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xyXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBfa1tfal07XHJcbiAgICAgICAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxudmFyIF9fZXhwb3J0ID0gZnVuY3Rpb24gKHRhcmdldCwgYWxsKSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcclxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG59O1xyXG52YXIgX19yZUV4cG9ydCA9IGZ1bmN0aW9uICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpIHtcclxuICAgIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcclxuICAgICAgICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZTJba2V5XTsgfSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMik7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBfa1tfal07XHJcbiAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG52YXIgX190b01vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUyKSB7XHJcbiAgICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUyLmRlZmF1bHQ7IH0sIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcclxufTtcclxudmFyIF9fYXN5bmMgPSBmdW5jdGlvbiAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBmdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9O1xyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvaW5kZXgudHNcclxuX19tYXJrQXNNb2R1bGUoZXhwb3J0cyk7XHJcbl9fZXhwb3J0KGV4cG9ydHMsIHtcclxuICAgIFF1ZXJ5U3RhdHVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBRdWVyeVN0YXR1czsgfSxcclxuICAgIGJ1aWxkQ3JlYXRlQXBpOiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZENyZWF0ZUFwaTsgfSxcclxuICAgIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmc7IH0sXHJcbiAgICBjb3JlTW9kdWxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlTW9kdWxlOyB9LFxyXG4gICAgY29yZU1vZHVsZU5hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVNb2R1bGVOYW1lOyB9LFxyXG4gICAgY3JlYXRlQXBpOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVBcGk7IH0sXHJcbiAgICBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzOyB9LFxyXG4gICAgZmFrZUJhc2VRdWVyeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFrZUJhc2VRdWVyeTsgfSxcclxuICAgIGZldGNoQmFzZVF1ZXJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmZXRjaEJhc2VRdWVyeTsgfSxcclxuICAgIHJldHJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXRyeTsgfSxcclxuICAgIHNldHVwTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXR1cExpc3RlbmVyczsgfSxcclxuICAgIHNraXBTZWxlY3RvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2tpcFNlbGVjdG9yOyB9LFxyXG4gICAgc2tpcFRva2VuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwVG9rZW47IH1cclxufSk7XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2FwaVN0YXRlLnRzXHJcbnZhciBRdWVyeVN0YXR1cztcclxuKGZ1bmN0aW9uIChRdWVyeVN0YXR1czIpIHtcclxuICAgIFF1ZXJ5U3RhdHVzMltcInVuaW5pdGlhbGl6ZWRcIl0gPSBcInVuaW5pdGlhbGl6ZWRcIjtcclxuICAgIFF1ZXJ5U3RhdHVzMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcclxuICAgIFF1ZXJ5U3RhdHVzMltcImZ1bGZpbGxlZFwiXSA9IFwiZnVsZmlsbGVkXCI7XHJcbiAgICBRdWVyeVN0YXR1czJbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcclxufSkoUXVlcnlTdGF0dXMgfHwgKFF1ZXJ5U3RhdHVzID0ge30pKTtcclxuZnVuY3Rpb24gZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN0YXR1cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICBpc1VuaW5pdGlhbGl6ZWQ6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCxcclxuICAgICAgICBpc0xvYWRpbmc6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMucGVuZGluZyxcclxuICAgICAgICBpc1N1Y2Nlc3M6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkLFxyXG4gICAgICAgIGlzRXJyb3I6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMucmVqZWN0ZWRcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2lzQWJzb2x1dGVVcmwudHNcclxuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKF58OikvL1wiKS50ZXN0KHVybCk7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2pvaW5VcmxzLnRzXHJcbnZhciB3aXRob3V0VHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7IH07XHJcbnZhciB3aXRob3V0TGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdXJsLnJlcGxhY2UoL15cXC8vLCBcIlwiKTsgfTtcclxuZnVuY3Rpb24gam9pblVybHMoYmFzZSwgdXJsKSB7XHJcbiAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgICByZXR1cm4gYmFzZTtcclxuICAgIH1cclxuICAgIGlmIChpc0Fic29sdXRlVXJsKHVybCkpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlbGltaXRlciA9IGJhc2UuZW5kc1dpdGgoXCIvXCIpIHx8ICF1cmwuc3RhcnRzV2l0aChcIj9cIikgPyBcIi9cIiA6IFwiXCI7XHJcbiAgICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XHJcbiAgICB1cmwgPSB3aXRob3V0TGVhZGluZ1NsYXNoKHVybCk7XHJcbiAgICByZXR1cm4gXCJcIiArIGJhc2UgKyBkZWxpbWl0ZXIgKyB1cmw7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2ZsYXR0ZW4udHNcclxudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGFycik7IH07XHJcbi8vIHNyYy9xdWVyeS91dGlscy9pc09ubGluZS50c1xyXG5mdW5jdGlvbiBpc09ubGluZSgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG5hdmlnYXRvci5vbkxpbmUgPT09IHZvaWQgMCA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lO1xyXG59XHJcbi8vIHNyYy9xdWVyeS91dGlscy9pc0RvY3VtZW50VmlzaWJsZS50c1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcudHNcclxudmFyIGltcG9ydF90b29sa2l0ID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBpc1BsYWluT2JqZWN0ID0gaW1wb3J0X3Rvb2xraXQuaXNQbGFpbk9iamVjdDtcclxuZnVuY3Rpb24gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmosIG5ld09iaikge1xyXG4gICAgaWYgKG9sZE9iaiA9PT0gbmV3T2JqIHx8ICEoaXNQbGFpbk9iamVjdChvbGRPYmopICYmIGlzUGxhaW5PYmplY3QobmV3T2JqKSB8fCBBcnJheS5pc0FycmF5KG9sZE9iaikgJiYgQXJyYXkuaXNBcnJheShuZXdPYmopKSkge1xyXG4gICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld09iaik7XHJcbiAgICB2YXIgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XHJcbiAgICB2YXIgaXNTYW1lT2JqZWN0ID0gbmV3S2V5cy5sZW5ndGggPT09IG9sZEtleXMubGVuZ3RoO1xyXG4gICAgdmFyIG1lcmdlT2JqID0gQXJyYXkuaXNBcnJheShuZXdPYmopID8gW10gOiB7fTtcclxuICAgIGZvciAodmFyIF9qID0gMCwgbmV3S2V5c18xID0gbmV3S2V5czsgX2ogPCBuZXdLZXlzXzEubGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNfMVtfal07XHJcbiAgICAgICAgbWVyZ2VPYmpba2V5XSA9IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqW2tleV0sIG5ld09ialtrZXldKTtcclxuICAgICAgICBpZiAoaXNTYW1lT2JqZWN0KVxyXG4gICAgICAgICAgICBpc1NhbWVPYmplY3QgPSBvbGRPYmpba2V5XSA9PT0gbWVyZ2VPYmpba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1NhbWVPYmplY3QgPyBvbGRPYmogOiBtZXJnZU9iajtcclxufVxyXG4vLyBzcmMvcXVlcnkvZmV0Y2hCYXNlUXVlcnkudHNcclxudmFyIGltcG9ydF90b29sa2l0MiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG52YXIgZGVmYXVsdEZldGNoRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGFyZ3VtZW50cy5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICBhcmdzW19qXSA9IGFyZ3VtZW50c1tfal07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmV0Y2guYXBwbHkodm9pZCAwLCBhcmdzKTtcclxufTtcclxudmFyIGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPD0gMjk5OyB9O1xyXG52YXIgZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlID0gZnVuY3Rpb24gKGhlYWRlcnMpIHsgcmV0dXJuIC9pb25cXC8odm5kXFwuYXBpXFwrKT9qc29uLy50ZXN0KGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpOyB9O1xyXG5mdW5jdGlvbiBzdHJpcFVuZGVmaW5lZChvYmopIHtcclxuICAgIGlmICghKDAsIGltcG9ydF90b29sa2l0Mi5pc1BsYWluT2JqZWN0KShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHZhciBjb3B5ID0gX19zcHJlYWRWYWx1ZXMoe30sIG9iaik7XHJcbiAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMoY29weSk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrID0gX2xbMF0sIHYgPSBfbFsxXTtcclxuICAgICAgICBpZiAodiA9PT0gdm9pZCAwKVxyXG4gICAgICAgICAgICBkZWxldGUgY29weVtrXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3B5O1xyXG59XHJcbmZ1bmN0aW9uIGZldGNoQmFzZVF1ZXJ5KF9hKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgaWYgKF9hID09PSB2b2lkIDApIHsgX2EgPSB7fTsgfVxyXG4gICAgdmFyIF9iID0gX2EsIGJhc2VVcmwgPSBfYi5iYXNlVXJsLCBfaiA9IF9iLnByZXBhcmVIZWFkZXJzLCBwcmVwYXJlSGVhZGVycyA9IF9qID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9qLCBfayA9IF9iLmZldGNoRm4sIGZldGNoRm4gPSBfayA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoRm4gOiBfaywgcGFyYW1zU2VyaWFsaXplciA9IF9iLnBhcmFtc1NlcmlhbGl6ZXIsIF9sID0gX2IuaXNKc29uQ29udGVudFR5cGUsIGlzSnNvbkNvbnRlbnRUeXBlID0gX2wgPT09IHZvaWQgMCA/IGRlZmF1bHRJc0pzb25Db250ZW50VHlwZSA6IF9sLCBfbSA9IF9iLmpzb25Db250ZW50VHlwZSwganNvbkNvbnRlbnRUeXBlID0gX20gPT09IHZvaWQgMCA/IFwiYXBwbGljYXRpb24vanNvblwiIDogX20sIGpzb25SZXBsYWNlciA9IF9iLmpzb25SZXBsYWNlciwgZGVmYXVsdFRpbWVvdXQgPSBfYi50aW1lb3V0LCBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPSBfYi5yZXNwb25zZUhhbmRsZXIsIGdsb2JhbFZhbGlkYXRlU3RhdHVzID0gX2IudmFsaWRhdGVTdGF0dXMsIGJhc2VGZXRjaE9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcclxuICAgICAgICBcImJhc2VVcmxcIixcclxuICAgICAgICBcInByZXBhcmVIZWFkZXJzXCIsXHJcbiAgICAgICAgXCJmZXRjaEZuXCIsXHJcbiAgICAgICAgXCJwYXJhbXNTZXJpYWxpemVyXCIsXHJcbiAgICAgICAgXCJpc0pzb25Db250ZW50VHlwZVwiLFxyXG4gICAgICAgIFwianNvbkNvbnRlbnRUeXBlXCIsXHJcbiAgICAgICAgXCJqc29uUmVwbGFjZXJcIixcclxuICAgICAgICBcInRpbWVvdXRcIixcclxuICAgICAgICBcInJlc3BvbnNlSGFuZGxlclwiLFxyXG4gICAgICAgIFwidmFsaWRhdGVTdGF0dXNcIlxyXG4gICAgXSk7XHJcbiAgICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiICYmIGZldGNoRm4gPT09IGRlZmF1bHRGZXRjaEZuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogYGZldGNoYCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2Ugc3VwcGx5IGEgY3VzdG9tIGBmZXRjaEZuYCBwcm9wZXJ0eSB0byB1c2UgYGZldGNoQmFzZVF1ZXJ5YCBvbiBTU1IgZW52aXJvbm1lbnRzLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnLCBhcGkpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2lnbmFsLCBnZXRTdGF0ZSwgZXh0cmEsIGVuZHBvaW50LCBmb3JjZWQsIHR5cGUsIG1ldGEsIF9hMiwgdXJsLCBfaiwgaGVhZGVycywgX2ssIHBhcmFtcywgX2wsIHJlc3BvbnNlSGFuZGxlciwgX20sIHZhbGlkYXRlU3RhdHVzLCBfbywgdGltZW91dCwgcmVzdCwgY29uZmlnLCBfcCwgaXNKc29uaWZpYWJsZSwgZGl2aWRlciwgcXVlcnksIHJlcXVlc3QsIHJlcXVlc3RDbG9uZSwgcmVzcG9uc2UsIHRpbWVkT3V0LCB0aW1lb3V0SWQsIGVfMSwgcmVzcG9uc2VDbG9uZSwgcmVzdWx0RGF0YSwgcmVzcG9uc2VUZXh0LCBoYW5kbGVSZXNwb25zZUVycm9yXzEsIGVfMjtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9xKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX3EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBhcGkuc2lnbmFsLCBnZXRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSwgZXh0cmEgPSBhcGkuZXh0cmEsIGVuZHBvaW50ID0gYXBpLmVuZHBvaW50LCBmb3JjZWQgPSBhcGkuZm9yY2VkLCB0eXBlID0gYXBpLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EyID0gdHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiID8geyB1cmw6IGFyZyB9IDogYXJnLCB1cmwgPSBfYTIudXJsLCBfaiA9IF9hMi5oZWFkZXJzLCBoZWFkZXJzID0gX2ogPT09IHZvaWQgMCA/IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycykgOiBfaiwgX2sgPSBfYTIucGFyYW1zLCBwYXJhbXMgPSBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ssIF9sID0gX2EyLnJlc3BvbnNlSGFuZGxlciwgcmVzcG9uc2VIYW5kbGVyID0gX2wgPT09IHZvaWQgMCA/IGdsb2JhbFJlc3BvbnNlSGFuZGxlciAhPSBudWxsID8gZ2xvYmFsUmVzcG9uc2VIYW5kbGVyIDogXCJqc29uXCIgOiBfbCwgX20gPSBfYTIudmFsaWRhdGVTdGF0dXMsIHZhbGlkYXRlU3RhdHVzID0gX20gPT09IHZvaWQgMCA/IGdsb2JhbFZhbGlkYXRlU3RhdHVzICE9IG51bGwgPyBnbG9iYWxWYWxpZGF0ZVN0YXR1cyA6IGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyA6IF9tLCBfbyA9IF9hMi50aW1lb3V0LCB0aW1lb3V0ID0gX28gPT09IHZvaWQgMCA/IGRlZmF1bHRUaW1lb3V0IDogX28sIHJlc3QgPSBfX29ialJlc3QoX2EyLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidXJsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVhZGVyc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhcmFtc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlSGFuZGxlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbGlkYXRlU3RhdHVzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGltZW91dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUZldGNoT3B0aW9ucyksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWxcclxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmlwVW5kZWZpbmVkKGhlYWRlcnMpKTtcclxuICAgICAgICAgICAgICAgICAgICBfcCA9IGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWQ6IGZvcmNlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9wLmhlYWRlcnMgPSAoX3Euc2VudCgpKSB8fCBoZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzSnNvbmlmaWFibGUgPSBmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgKCgwLCBpbXBvcnRfdG9vbGtpdDIuaXNQbGFpbk9iamVjdCkoYm9keSkgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCB0eXBlb2YgYm9keS50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIGpzb25Db250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0pzb25pZmlhYmxlKGNvbmZpZy5ib2R5KSAmJiBpc0pzb25Db250ZW50VHlwZShjb25maWcuaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJvZHkgPSBKU09OLnN0cmluZ2lmeShjb25maWcuYm9keSwganNvblJlcGxhY2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gfnVybC5pbmRleE9mKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyYW1zU2VyaWFsaXplciA/IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKSA6IG5ldyBVUkxTZWFyY2hQYXJhbXMoc3RyaXBVbmRlZmluZWQocGFyYW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBkaXZpZGVyICsgcXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGpvaW5VcmxzKGJhc2VVcmwsIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q2xvbmUgPSBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YSA9IHsgcmVxdWVzdDogcmVxdWVzdENsb25lIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQgPSBmYWxzZSwgdGltZW91dElkID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBfcS5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX3EudHJ5cy5wdXNoKFsyLCA0LCA1LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hGbihyZXF1ZXN0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZV8xID0gX3Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogdGltZWRPdXQgPyBcIlRJTUVPVVRfRVJST1JcIiA6IFwiRkVUQ0hfRVJST1JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogU3RyaW5nKGVfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YS5yZXNwb25zZSA9IHJlc3BvbnNlQ2xvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBfcS5sYWJlbCA9IDc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgX3EudHJ5cy5wdXNoKFs3LCA5LCAsIDEwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIHJlc3BvbnNlSGFuZGxlcikudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0RGF0YSA9IHI7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVSZXNwb25zZUVycm9yXzEgPSBlOyB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2xvbmUudGV4dCgpLnRoZW4oZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc3BvbnNlVGV4dCA9IHI7IH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZVJlc3BvbnNlRXJyb3JfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlUmVzcG9uc2VFcnJvcl8xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICBlXzIgPSBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIlBBUlNJTkdfRVJST1JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogU3RyaW5nKGVfMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLCByZXN1bHREYXRhKSA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0RGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdERhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9qKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJjb250ZW50LXR5cGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyID0gaXNKc29uQ29udGVudFR5cGUocmVzcG9uc2UuaGVhZGVycykgPyBcImpzb25cIiA6IFwidGV4dFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJqc29uXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfai5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZXh0Lmxlbmd0aCA/IEpTT04ucGFyc2UodGV4dCkgOiBudWxsXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZS50ZXh0KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vLyBzcmMvcXVlcnkvSGFuZGxlZEVycm9yLnRzXHJcbnZhciBIYW5kbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGVkRXJyb3IodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7IG1ldGEgPSB2b2lkIDA7IH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBIYW5kbGVkRXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9xdWVyeS9yZXRyeS50c1xyXG5mdW5jdGlvbiBkZWZhdWx0QmFja29mZihhdHRlbXB0LCBtYXhSZXRyaWVzKSB7XHJcbiAgICBpZiAoYXR0ZW1wdCA9PT0gdm9pZCAwKSB7IGF0dGVtcHQgPSAwOyB9XHJcbiAgICBpZiAobWF4UmV0cmllcyA9PT0gdm9pZCAwKSB7IG1heFJldHJpZXMgPSA1OyB9XHJcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGF0dGVtcHRzLCB0aW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfai5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzID0gTWF0aC5taW4oYXR0ZW1wdCwgbWF4UmV0cmllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC40KSAqICgzMDAgPDwgYXR0ZW1wdHMpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXNvbHZlKHJlcyk7IH0sIHRpbWVvdXQpOyB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmFpbChlKSB7XHJcbiAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBIYW5kbGVkRXJyb3IoeyBlcnJvcjogZSB9KSwge1xyXG4gICAgICAgIHRocm93SW1tZWRpYXRlbHk6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbnZhciBFTVBUWV9PUFRJT05TID0ge307XHJcbnZhciByZXRyeVdpdGhCYWNrb2ZmID0gZnVuY3Rpb24gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3NzaWJsZU1heFJldHJpZXMsIG1heFJldHJpZXMsIGRlZmF1bHRSZXRyeUNvbmRpdGlvbiwgb3B0aW9ucywgcmV0cnkyLCByZXN1bHQsIGVfMztcclxuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHBvc3NpYmxlTWF4UmV0cmllcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICA1LFxyXG4gICAgICAgICAgICAgICAgICAgIChkZWZhdWx0T3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzLFxyXG4gICAgICAgICAgICAgICAgICAgIChleHRyYU9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUykubWF4UmV0cmllc1xyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHZvaWQgMDsgfSk7XHJcbiAgICAgICAgICAgICAgICBtYXhSZXRyaWVzID0gcG9zc2libGVNYXhSZXRyaWVzLnNsaWNlKC0xKVswXTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXRyeUNvbmRpdGlvbiA9IGZ1bmN0aW9uIChfLCBfXywgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ZW1wdCA9IF9qLmF0dGVtcHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQgPD0gbWF4UmV0cmllcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja29mZjogZGVmYXVsdEJhY2tvZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb25kaXRpb246IGRlZmF1bHRSZXRyeUNvbmRpdGlvblxyXG4gICAgICAgICAgICAgICAgfSwgZGVmYXVsdE9wdGlvbnMpLCBleHRyYU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0cnkyID0gMDtcclxuICAgICAgICAgICAgICAgIF9qLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcclxuICAgICAgICAgICAgICAgIF9qLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgX2oudHJ5cy5wdXNoKFsyLCA0LCAsIDZdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VRdWVyeShhcmdzLCBhcGksIGV4dHJhT3B0aW9ucyldO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfai5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhhbmRsZWRFcnJvcihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGVfMyA9IF9qLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHJ5MisrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVfMy50aHJvd0ltbWVkaWF0ZWx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMyBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZV8zLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVfMyBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvciAmJiAhb3B0aW9ucy5yZXRyeUNvbmRpdGlvbihlXzMudmFsdWUuZXJyb3IsIGFyZ3MsIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiByZXRyeTIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVF1ZXJ5QXBpOiBhcGksXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRpb25zOiBleHRyYU9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGVfMy52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvcHRpb25zLmJhY2tvZmYocmV0cnkyLCBvcHRpb25zLm1heFJldHJpZXMpXTtcclxuICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTsgfTsgfTtcclxudmFyIHJldHJ5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24ocmV0cnlXaXRoQmFja29mZiwgeyBmYWlsOiBmYWlsIH0pO1xyXG4vLyBzcmMvcXVlcnkvY29yZS9zZXR1cExpc3RlbmVycy50c1xyXG52YXIgaW1wb3J0X3Rvb2xraXQzID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBvbkZvY3VzID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDMuY3JlYXRlQWN0aW9uKShcIl9fcnRrcS9mb2N1c2VkXCIpO1xyXG52YXIgb25Gb2N1c0xvc3QgPSAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF90b29sa2l0My5jcmVhdGVBY3Rpb24pKFwiX19ydGtxL3VuZm9jdXNlZFwiKTtcclxudmFyIG9uT25saW5lID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDMuY3JlYXRlQWN0aW9uKShcIl9fcnRrcS9vbmxpbmVcIik7XHJcbnZhciBvbk9mZmxpbmUgPSAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF90b29sa2l0My5jcmVhdGVBY3Rpb24pKFwiX19ydGtxL29mZmxpbmVcIik7XHJcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyhkaXNwYXRjaCwgY3VzdG9tSGFuZGxlcikge1xyXG4gICAgZnVuY3Rpb24gZGVmYXVsdEhhbmRsZXIoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25Gb2N1cygpKTsgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRm9jdXNMb3N0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25Gb2N1c0xvc3QoKSk7IH07XHJcbiAgICAgICAgdmFyIGhhbmRsZU9ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoKG9uT25saW5lKCkpOyB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVPZmZsaW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25PZmZsaW5lKCkpOyB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVPZmZsaW5lKTtcclxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXN0b21IYW5kbGVyID8gY3VzdG9tSGFuZGxlcihkaXNwYXRjaCwgeyBvbkZvY3VzOiBvbkZvY3VzLCBvbkZvY3VzTG9zdDogb25Gb2N1c0xvc3QsIG9uT2ZmbGluZTogb25PZmZsaW5lLCBvbk9ubGluZTogb25PbmxpbmUgfSkgOiBkZWZhdWx0SGFuZGxlcigpO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2VsZWN0b3JzLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDcgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcclxudmFyIERlZmluaXRpb25UeXBlO1xyXG4oZnVuY3Rpb24gKERlZmluaXRpb25UeXBlMikge1xyXG4gICAgRGVmaW5pdGlvblR5cGUyW1wicXVlcnlcIl0gPSBcInF1ZXJ5XCI7XHJcbiAgICBEZWZpbml0aW9uVHlwZTJbXCJtdXRhdGlvblwiXSA9IFwibXV0YXRpb25cIjtcclxufSkoRGVmaW5pdGlvblR5cGUgfHwgKERlZmluaXRpb25UeXBlID0ge30pKTtcclxuZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZSkge1xyXG4gICAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUucXVlcnk7XHJcbn1cclxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xyXG4gICAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUubXV0YXRpb247XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeShkZXNjcmlwdGlvbiwgcmVzdWx0LCBlcnJvciwgcXVlcnlBcmcsIG1ldGEsIGFzc2VydFRhZ1R5cGVzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihkZXNjcmlwdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24ocmVzdWx0LCBlcnJvciwgcXVlcnlBcmcsIG1ldGEpLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHQgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogZGVzY3JpcHRpb24gfSA6IGRlc2NyaXB0aW9uO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2xpY2UudHNcclxudmFyIGltcG9ydF90b29sa2l0NiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNOb3ROdWxsaXNoLnRzXHJcbmZ1bmN0aW9uIGlzTm90TnVsbGlzaCh2KSB7XHJcbiAgICByZXR1cm4gdiAhPSBudWxsO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkSW5pdGlhdGUudHNcclxudmFyIGZvcmNlUXVlcnlGblN5bWJvbCA9IFN5bWJvbChcImZvcmNlUXVlcnlGblwiKTtcclxudmFyIGlzVXBzZXJ0UXVlcnkgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjsgfTtcclxuZnVuY3Rpb24gYnVpbGRJbml0aWF0ZShfaikge1xyXG4gICAgdmFyIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfai5tdXRhdGlvblRodW5rLCBhcGkgPSBfai5hcGksIGNvbnRleHQgPSBfai5jb250ZXh0O1xyXG4gICAgdmFyIHJ1bm5pbmdRdWVyaWVzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHJ1bm5pbmdNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgX2sgPSBhcGkuaW50ZXJuYWxBY3Rpb25zLCB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0ID0gX2sudW5zdWJzY3JpYmVRdWVyeVJlc3VsdCwgcmVtb3ZlTXV0YXRpb25SZXN1bHQgPSBfay5yZW1vdmVNdXRhdGlvblJlc3VsdCwgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IF9rLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnM7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJ1aWxkSW5pdGlhdGVRdWVyeTogYnVpbGRJbml0aWF0ZVF1ZXJ5LFxyXG4gICAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbjogYnVpbGRJbml0aWF0ZU11dGF0aW9uLFxyXG4gICAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rOiBnZXRSdW5uaW5nUXVlcnlUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuazogZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXHJcbiAgICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuazogZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bms6IGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXM6IGdldFJ1bm5pbmdPcGVyYXRpb25Qcm9taXNlcyxcclxuICAgICAgICByZW1vdmFsV2FybmluZzogcmVtb3ZhbFdhcm5pbmdcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiByZW1vdmFsV2FybmluZygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYWQgdG8gYmUgcmVtb3ZlZCBkdWUgdG8gYSBjb25jZXB0dWFsIGJ1ZyBpbiBSVEsuXFxuICAgICAgIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgtdG9vbGtpdC9wdWxsLzI0ODEgZm9yIGRldGFpbHMuXFxuICAgICAgIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3J0ay1xdWVyeS91c2FnZS9zZXJ2ZXItc2lkZS1yZW5kZXJpbmcgZm9yIG5ldyBndWlkYW5jZSBvbiBTU1IuXCIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0UnVubmluZ09wZXJhdGlvblByb21pc2VzKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJlbW92YWxXYXJuaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmFjdCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBBcnJheS5mcm9tKHYudmFsdWVzKCkpLmZsYXRNYXAoZnVuY3Rpb24gKHF1ZXJpZXNGb3JTdG9yZSkgeyByZXR1cm4gcXVlcmllc0ZvclN0b3JlID8gT2JqZWN0LnZhbHVlcyhxdWVyaWVzRm9yU3RvcmUpIDogW107IH0pOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBleHRyYWN0KHJ1bm5pbmdRdWVyaWVzKSksIGV4dHJhY3QocnVubmluZ011dGF0aW9ucykpLmZpbHRlcihpc05vdE51bGxpc2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyeVRodW5rKGVuZHBvaW50TmFtZSwgcXVlcnlBcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHZhciBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xyXG4gICAgICAgICAgICAgICAgcXVlcnlBcmdzOiBxdWVyeUFyZ3MsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludERlZmluaXRpb246IGVuZHBvaW50RGVmaW5pdGlvbixcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayhfZW5kcG9pbnROYW1lLCBmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2ZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZF07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkgeyByZXR1cm4gT2JqZWN0LnZhbHVlcyhydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9KS5maWx0ZXIoaXNOb3ROdWxsaXNoKTsgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuaygpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7IHJldHVybiBPYmplY3QudmFsdWVzKHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7IH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCkge1xyXG4gICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlV2FybmluZy50cmlnZ2VyZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9wcm9iZVN1YnNjcmlwdGlvbih7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBcIkRPRVNfTk9UX0VYSVNUXCIsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IFwiRFVNTVlfUkVRVUVTVF9JRFwiXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbWlkZGxld2FyZVdhcm5pbmcudHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWdpc3RlcmVkICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcXFwiXCIgKyBhcGkucmVkdWNlclBhdGggKyBcIlxcXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cXG5Zb3UgbXVzdCBhZGQgdGhlIG1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSB0byBmdW5jdGlvbiBjb3JyZWN0bHkhXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5QWN0aW9uID0gZnVuY3Rpb24gKGFyZywgX2opIHtcclxuICAgICAgICAgICAgdmFyIF9rID0gX2ogPT09IHZvaWQgMCA/IHt9IDogX2osIF9sID0gX2suc3Vic2NyaWJlLCBzdWJzY3JpYmUgPSBfbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9sLCBmb3JjZVJlZmV0Y2ggPSBfay5mb3JjZVJlZmV0Y2gsIHN1YnNjcmlwdGlvbk9wdGlvbnMgPSBfay5zdWJzY3JpcHRpb25PcHRpb25zLCBfbSA9IGZvcmNlUXVlcnlGblN5bWJvbCwgZm9yY2VRdWVyeUZuID0gX2tbX21dO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9qO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbjogZW5kcG9pbnREZWZpbml0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciB0aHVuayA9IHF1ZXJ5VGh1bmsoKF9qID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInF1ZXJ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IGZvcmNlUmVmZXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnROYW1lOiBlbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBfaltmb3JjZVF1ZXJ5Rm5TeW1ib2xdID0gZm9yY2VRdWVyeUZuLFxyXG4gICAgICAgICAgICAgICAgICAgIF9qKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVBZnRlciA9IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IHRodW5rUmVzdWx0LnJlcXVlc3RJZCwgYWJvcnQgPSB0aHVua1Jlc3VsdC5hYm9ydDtcclxuICAgICAgICAgICAgICAgIHZhciBza2lwcGVkU3luY2hyb25vdXNseSA9IHN0YXRlQWZ0ZXIucmVxdWVzdElkICE9PSByZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVubmluZ1F1ZXJ5ID0gKF9hID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEZyb21TdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yKGdldFN0YXRlKCkpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlUHJvbWlzZSA9IE9iamVjdC5hc3NpZ24oZm9yY2VRdWVyeUZuID8gdGh1bmtSZXN1bHQudGhlbihzZWxlY3RGcm9tU3RhdGUpIDogc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIXJ1bm5pbmdRdWVyeSA/IFByb21pc2UucmVzb2x2ZShzdGF0ZUFmdGVyKSA6IFByb21pc2UuYWxsKFtydW5uaW5nUXVlcnksIHRodW5rUmVzdWx0XSkudGhlbihzZWxlY3RGcm9tU3RhdGUpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhdGVQcm9taXNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWZldGNoOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwYXRjaChxdWVyeUFjdGlvbihhcmcsIHsgc3Vic2NyaWJlOiBmYWxzZSwgZm9yY2VSZWZldGNoOiB0cnVlIH0pKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godW5zdWJzY3JpYmVRdWVyeVJlc3VsdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQcm9taXNlLnN1YnNjcmlwdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmdRdWVyeSAmJiAhc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIWZvcmNlUXVlcnlGbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5uaW5nXzEgPSBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfMVtxdWVyeUNhY2hlS2V5XSA9IHN0YXRlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nUXVlcmllcy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmdfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVubmluZ18xW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJ1bm5pbmdfMSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nUXVlcmllcy5kZWxldGUoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVQcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnLCBfaikge1xyXG4gICAgICAgICAgICB2YXIgX2sgPSBfaiA9PT0gdm9pZCAwID8ge30gOiBfaiwgX2wgPSBfay50cmFjaywgdHJhY2sgPSBfbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9sLCBmaXhlZENhY2hlS2V5ID0gX2suZml4ZWRDYWNoZUtleTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aHVuayA9IG11dGF0aW9uVGh1bmsoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibXV0YXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGVuZHBvaW50TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRDYWNoZUtleTogZml4ZWRDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XHJcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gdGh1bmtSZXN1bHQucmVxdWVzdElkLCBhYm9ydCA9IHRodW5rUmVzdWx0LmFib3J0LCB1bndyYXAgPSB0aHVua1Jlc3VsdC51bndyYXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWVQcm9taXNlID0gdGh1bmtSZXN1bHQudW53cmFwKCkudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHsgZGF0YTogZGF0YSB9KTsgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoeyBlcnJvcjogZXJyb3IgfSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHJlbW92ZU11dGF0aW9uUmVzdWx0KHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGZpeGVkQ2FjaGVLZXk6IGZpeGVkQ2FjaGVLZXkgfSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBPYmplY3QuYXNzaWduKHJldHVyblZhbHVlUHJvbWlzZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogdGh1bmtSZXN1bHQuYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICB1bndyYXA6IHVud3JhcCxcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogcmVzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IHJlc2V0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBydW5uaW5nID0gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xyXG4gICAgICAgICAgICAgICAgcnVubmluZ1tyZXF1ZXN0SWRdID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW3JlcXVlc3RJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhydW5uaW5nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5kZWxldGUoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdbZml4ZWRDYWNoZUtleV0gPT09IHJldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbZml4ZWRDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJ1bm5pbmcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuZGVsZXRlKGRpc3BhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkVGh1bmtzLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDQgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIGltcG9ydF9pbW1lciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIGltcG9ydF90b29sa2l0NSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2UoYmFzZVF1ZXJ5UmV0dXJuVmFsdWUpIHtcclxuICAgIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFRodW5rcyhfaikge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBiYXNlUXVlcnkgPSBfai5iYXNlUXVlcnksIGVuZHBvaW50RGVmaW5pdGlvbnMgPSBfai5jb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMsIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgYXBpID0gX2ouYXBpLCBhc3NlcnRUYWdUeXBlID0gX2ouYXNzZXJ0VGFnVHlwZTtcclxuICAgIHZhciBwYXRjaFF1ZXJ5RGF0YSA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZ3MsIHBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSB7IHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcclxuICAgICAgICB2YXIgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XHJcbiAgICAgICAgICAgIHF1ZXJ5QXJnczogYXJncyxcclxuICAgICAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uOiBlbmRwb2ludERlZmluaXRpb24sXHJcbiAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5xdWVyeVJlc3VsdFBhdGNoZWQoeyBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LCBwYXRjaGVzOiBwYXRjaGVzIH0pKTtcclxuICAgICAgICBpZiAoIXVwZGF0ZVByb3ZpZGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmdzKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICB2YXIgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB2b2lkIDAsIGFyZ3MsIHt9LCBhc3NlcnRUYWdUeXBlKTtcclxuICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoeyBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LCBwcm92aWRlZFRhZ3M6IHByb3ZpZGVkVGFncyB9KSk7XHJcbiAgICB9OyB9O1xyXG4gICAgdmFyIHVwZGF0ZVF1ZXJ5RGF0YSA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZ3MsIHVwZGF0ZVJlY2lwZSwgdXBkYXRlUHJvdmlkZWQpIHtcclxuICAgICAgICBpZiAodXBkYXRlUHJvdmlkZWQgPT09IHZvaWQgMCkgeyB1cGRhdGVQcm92aWRlZCA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2osIF9rO1xyXG4gICAgICAgICAgICB2YXIgZW5kcG9pbnREZWZpbml0aW9uID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gZW5kcG9pbnREZWZpbml0aW9uLnNlbGVjdChhcmdzKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICAgICAgdmFyIHJldCA9IHtcclxuICAgICAgICAgICAgICAgIHBhdGNoZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdW5kbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2goYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBhcmdzLCByZXQuaW52ZXJzZVBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSk7IH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGltcG9ydF9pbW1lci5pc0RyYWZ0YWJsZSkoY3VycmVudFN0YXRlLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gKDAsIGltcG9ydF9pbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMpKGN1cnJlbnRTdGF0ZS5kYXRhLCB1cGRhdGVSZWNpcGUpLCB2YWx1ZSA9IF9sWzBdLCBwYXRjaGVzID0gX2xbMV0sIGludmVyc2VQYXRjaGVzID0gX2xbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgKF9qID0gcmV0LnBhdGNoZXMpLnB1c2guYXBwbHkoX2osIHBhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIChfayA9IHJldC5pbnZlcnNlUGF0Y2hlcykucHVzaC5hcHBseShfaywgaW52ZXJzZVBhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHVwZGF0ZVJlY2lwZShjdXJyZW50U3RhdGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LnBhdGNoZXMucHVzaCh7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogW10sIHZhbHVlOiBuZXdWYWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50U3RhdGUuZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BhdGNoKGFwaS51dGlsLnBhdGNoUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgYXJncywgcmV0LnBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgdXBzZXJ0UXVlcnlEYXRhID0gZnVuY3Rpb24gKGVuZHBvaW50TmFtZSwgYXJncywgdmFsdWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHZhciBfajtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2goYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZ3MsIChfaiA9IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2pbZm9yY2VRdWVyeUZuU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTsgfSxcclxuICAgICAgICAgICAgX2opKSk7XHJcbiAgICB9OyB9O1xyXG4gICAgdmFyIGV4ZWN1dGVFbmRwb2ludCA9IGZ1bmN0aW9uIChfMCwgXzEpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIFtfMCwgXzFdLCBmdW5jdGlvbiAoYXJnLCBfaikge1xyXG4gICAgICAgIHZhciBlbmRwb2ludERlZmluaXRpb24sIHRyYW5zZm9ybVJlc3BvbnNlLCByZXN1bHQsIGJhc2VRdWVyeUFwaV8xLCBmb3JjZVF1ZXJ5Rm4sIHdoYXQsIGVyciwgX2ssIF9sLCBrZXksIF9tLCBlcnJvcl8xLCBjYXRjaGVkRXJyb3IsIHRyYW5zZm9ybUVycm9yUmVzcG9uc2UsIF9vLCBlXzQ7XHJcbiAgICAgICAgdmFyIF9wLCBfcTtcclxuICAgICAgICB2YXIgc2lnbmFsID0gX2ouc2lnbmFsLCBhYm9ydCA9IF9qLmFib3J0LCByZWplY3RXaXRoVmFsdWUgPSBfai5yZWplY3RXaXRoVmFsdWUsIGZ1bGZpbGxXaXRoVmFsdWUgPSBfai5mdWxmaWxsV2l0aFZhbHVlLCBkaXNwYXRjaCA9IF9qLmRpc3BhdGNoLCBnZXRTdGF0ZSA9IF9qLmdldFN0YXRlLCBleHRyYSA9IF9qLmV4dHJhO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfci5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbYXJnLmVuZHBvaW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgX3IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9yLnRyeXMucHVzaChbMSwgOCwgLCAxM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlID0gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlUXVlcnlBcGlfMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGFyZy5lbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFyZy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWQ6IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgOiB2b2lkIDBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUXVlcnlGbiA9IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBhcmdbZm9yY2VRdWVyeUZuU3ltYm9sXSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUXVlcnlGbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRwb2ludERlZmluaXRpb24ucXVlcnkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VRdWVyeShlbmRwb2ludERlZmluaXRpb24ucXVlcnkoYXJnLm9yaWdpbmFsQXJncyksIGJhc2VRdWVyeUFwaV8xLCBlbmRwb2ludERlZmluaXRpb24uZXh0cmFPcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UgPSBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBlbmRwb2ludERlZmluaXRpb24ucXVlcnlGbihhcmcub3JpZ2luYWxBcmdzLCBiYXNlUXVlcnlBcGlfMSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucywgZnVuY3Rpb24gKGFyZzIpIHsgcmV0dXJuIGJhc2VRdWVyeShhcmcyLCBiYXNlUXVlcnlBcGlfMSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucyk7IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfci5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3IubGFiZWwgPSA2O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoYXQgPSBlbmRwb2ludERlZmluaXRpb24ucXVlcnkgPyBcImBiYXNlUXVlcnlgXCIgOiBcImBxdWVyeUZuYFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSB3aGF0ICsgXCIgZGlkIG5vdCByZXR1cm4gYW55dGhpbmcuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gd2hhdCArIFwiIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IHdoYXQgKyBcIiByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBib3RoIGBlcnJvcmAgYW5kIGByZXN1bHRgLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5lcnJvciA9PT0gdm9pZCAwICYmIHJlc3VsdC5kYXRhID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IHdoYXQgKyBcIiByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBuZWl0aGVyIGEgdmFsaWQgYGVycm9yYCBhbmQgYHJlc3VsdGAuIEF0IGxlYXN0IG9uZSBvZiB0aGVtIHNob3VsZCBub3QgYmUgYHVuZGVmaW5lZGBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbCA9IE9iamVjdC5rZXlzKHJlc3VsdCk7IF9rIDwgX2wubGVuZ3RoOyBfaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gX2xbX2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZXJyb3JcIiAmJiBrZXkgIT09IFwiZGF0YVwiICYmIGtleSAhPT0gXCJtZXRhXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJUaGUgb2JqZWN0IHJldHVybmVkIGJ5IFwiICsgd2hhdCArIFwiIGhhcyB0aGUgdW5rbm93biBwcm9wZXJ0eSBcIiArIGtleSArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGVuY291bnRlcmVkIGhhbmRsaW5nIHRoZSBlbmRwb2ludCBcIiArIGFyZy5lbmRwb2ludE5hbWUgKyBcIi5cXG4gICAgICAgICAgICAgIFwiICsgZXJyICsgXCJcXG4gICAgICAgICAgICAgIEl0IG5lZWRzIHRvIHJldHVybiBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHNoYXBlIGB7IGRhdGE6IDx2YWx1ZT4gfWAgb3IgYHsgZXJyb3I6IDx2YWx1ZT4gfWAgdGhhdCBtYXkgY29udGFpbiBhbiBvcHRpb25hbCBgbWV0YWAgcHJvcGVydHkuXFxuICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOlwiLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX20gPSBmdWxmaWxsV2l0aFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3VsdC5kYXRhLCByZXN1bHQubWV0YSwgYXJnLm9yaWdpbmFsQXJncyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX20uYXBwbHkodm9pZCAwLCBbX3Iuc2VudCgpLCAoX3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VRdWVyeU1ldGE6IHJlc3VsdC5tZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BbaW1wb3J0X3Rvb2xraXQ1LlNIT1VMRF9BVVRPQkFUQ0hdID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wKV0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZWRFcnJvciA9IGVycm9yXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2F0Y2hlZEVycm9yIGluc3RhbmNlb2YgSGFuZGxlZEVycm9yKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSAmJiBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtRXJyb3JSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlID0gZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9yLmxhYmVsID0gOTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICBfci50cnlzLnB1c2goWzksIDExLCAsIDEyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX28gPSByZWplY3RXaXRoVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNmb3JtRXJyb3JSZXNwb25zZShjYXRjaGVkRXJyb3IudmFsdWUsIGNhdGNoZWRFcnJvci5tZXRhLCBhcmcub3JpZ2luYWxBcmdzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX28uYXBwbHkodm9pZCAwLCBbX3Iuc2VudCgpLCAoX3EgPSB7IGJhc2VRdWVyeU1ldGE6IGNhdGNoZWRFcnJvci5tZXRhIH0sIF9xW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9xKV0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICAgICAgZV80ID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZWRFcnJvciA9IGVfNDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbiB1bmhhbmRsZWQgZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBhIHJlcXVlc3QgZm9yIHRoZSBlbmRwb2ludCBcXFwiXCIgKyBhcmcuZW5kcG9pbnROYW1lICsgXCJcXFwiLlxcbkluIHRoZSBjYXNlIG9mIGFuIHVuaGFuZGxlZCBlcnJvciwgbm8gdGFncyB3aWxsIGJlIFxcXCJwcm92aWRlZFxcXCIgb3IgXFxcImludmFsaWRhdGVkXFxcIi5cIiwgY2F0Y2hlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY2F0Y2hlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY2F0Y2hlZEVycm9yO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfTtcclxuICAgIGZ1bmN0aW9uIGlzRm9yY2VkUXVlcnkoYXJnLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB2YXIgcmVxdWVzdFN0YXRlID0gKF9iID0gKF9hID0gc3RhdGVbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcmllcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2FyZy5xdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlID0gKF9jID0gc3RhdGVbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY29uZmlnLnJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICB2YXIgcmVmZXRjaFZhbCA9IChfZCA9IGFyZy5mb3JjZVJlZmV0Y2gpICE9IG51bGwgPyBfZCA6IGFyZy5zdWJzY3JpYmUgJiYgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlO1xyXG4gICAgICAgIGlmIChyZWZldGNoVmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWZldGNoVmFsID09PSB0cnVlIHx8IChOdW1iZXIobmV3IERhdGUoKSkgLSBOdW1iZXIoZnVsZmlsbGVkVmFsKSkgLyAxZTMgPj0gcmVmZXRjaFZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIHF1ZXJ5VGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQ1LmNyZWF0ZUFzeW5jVGh1bmspKHJlZHVjZXJQYXRoICsgXCIvZXhlY3V0ZVF1ZXJ5XCIsIGV4ZWN1dGVFbmRwb2ludCwge1xyXG4gICAgICAgIGdldFBlbmRpbmdNZXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfajtcclxuICAgICAgICAgICAgcmV0dXJuIF9qID0geyBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpIH0sIF9qW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9qO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocXVlcnlUaHVua0FyZ3MsIF9qKSB7XHJcbiAgICAgICAgICAgIHZhciBnZXRTdGF0ZSA9IF9qLmdldFN0YXRlO1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RTdGF0ZSA9IChfYiA9IChfYSA9IHN0YXRlW3JlZHVjZXJQYXRoXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYltxdWVyeVRodW5rQXJncy5xdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBxdWVyeVRodW5rQXJncy5vcmlnaW5hbEFyZ3M7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0FyZyA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLm9yaWdpbmFsQXJncztcclxuICAgICAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbcXVlcnlUaHVua0FyZ3MuZW5kcG9pbnROYW1lXTtcclxuICAgICAgICAgICAgaWYgKGlzVXBzZXJ0UXVlcnkocXVlcnlUaHVua0FyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLnN0YXR1cykgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRm9yY2VkUXVlcnkocXVlcnlUaHVua0FyZ3MsIHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgJiYgKChfYyA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLmZvcmNlUmVmZXRjaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoZW5kcG9pbnREZWZpbml0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXJnOiBjdXJyZW50QXJnLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNBcmc6IHByZXZpb3VzQXJnLFxyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRTdGF0ZTogcmVxdWVzdFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlXHJcbiAgICAgICAgICAgIH0pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZ1bGZpbGxlZFZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb246IHRydWVcclxuICAgIH0pO1xyXG4gICAgdmFyIG11dGF0aW9uVGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQ1LmNyZWF0ZUFzeW5jVGh1bmspKHJlZHVjZXJQYXRoICsgXCIvZXhlY3V0ZU11dGF0aW9uXCIsIGV4ZWN1dGVFbmRwb2ludCwge1xyXG4gICAgICAgIGdldFBlbmRpbmdNZXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfajtcclxuICAgICAgICAgICAgcmV0dXJuIF9qID0geyBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpIH0sIF9qW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9qO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGhhc1RoZUZvcmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIFwiZm9yY2VcIiBpbiBvcHRpb25zOyB9O1xyXG4gICAgdmFyIGhhc01heEFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBcImlmT2xkZXJUaGFuXCIgaW4gb3B0aW9uczsgfTtcclxuICAgIHZhciBwcmVmZXRjaCA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucykgeyByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBmb3JjZSA9IGhhc1RoZUZvcmNlKG9wdGlvbnMpICYmIG9wdGlvbnMuZm9yY2U7XHJcbiAgICAgICAgdmFyIG1heEFnZSA9IGhhc01heEFnZShvcHRpb25zKSAmJiBvcHRpb25zLmlmT2xkZXJUaGFuO1xyXG4gICAgICAgIHZhciBxdWVyeUFjdGlvbiA9IGZ1bmN0aW9uIChmb3JjZTIpIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlMiA9PT0gdm9pZCAwKSB7IGZvcmNlMiA9IHRydWU7IH1cclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIHsgZm9yY2VSZWZldGNoOiBmb3JjZTIgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbGF0ZXN0U3RhdGVWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1heEFnZSkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEZ1bGZpbGxlZFRzID0gbGF0ZXN0U3RhdGVWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0U3RhdGVWYWx1ZS5mdWxmaWxsZWRUaW1lU3RhbXA7XHJcbiAgICAgICAgICAgIGlmICghbGFzdEZ1bGZpbGxlZFRzKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2hvdWxkUmV0cmlnZ2VyID0gKE51bWJlcihuZXcgRGF0ZSgpKSAtIE51bWJlcihuZXcgRGF0ZShsYXN0RnVsZmlsbGVkVHMpKSkgLyAxZTMgPj0gbWF4QWdlO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICB9OyB9O1xyXG4gICAgZnVuY3Rpb24gbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gYWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBhY3Rpb24ubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFyZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmVuZHBvaW50TmFtZSkgPT09IGVuZHBvaW50TmFtZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRNYXRjaFRodW5rQWN0aW9ucyh0aHVuaywgZW5kcG9pbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWF0Y2hQZW5kaW5nOiAoMCwgaW1wb3J0X3Rvb2xraXQ0LmlzQWxsT2YpKCgwLCBpbXBvcnRfdG9vbGtpdDQuaXNQZW5kaW5nKSh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcclxuICAgICAgICAgICAgbWF0Y2hGdWxmaWxsZWQ6ICgwLCBpbXBvcnRfdG9vbGtpdDQuaXNBbGxPZikoKDAsIGltcG9ydF90b29sa2l0NC5pc0Z1bGZpbGxlZCkodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXHJcbiAgICAgICAgICAgIG1hdGNoUmVqZWN0ZWQ6ICgwLCBpbXBvcnRfdG9vbGtpdDQuaXNBbGxPZikoKDAsIGltcG9ydF90b29sa2l0NC5pc1JlamVjdGVkKSh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5VGh1bms6IHF1ZXJ5VGh1bmssXHJcbiAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICBwcmVmZXRjaDogcHJlZmV0Y2gsXHJcbiAgICAgICAgdXBkYXRlUXVlcnlEYXRhOiB1cGRhdGVRdWVyeURhdGEsXHJcbiAgICAgICAgdXBzZXJ0UXVlcnlEYXRhOiB1cHNlcnRRdWVyeURhdGEsXHJcbiAgICAgICAgcGF0Y2hRdWVyeURhdGE6IHBhdGNoUXVlcnlEYXRhLFxyXG4gICAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnM6IGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgdHlwZSwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSkge1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZVByb3ZpZGVkQnkoZW5kcG9pbnREZWZpbml0aW9uc1thY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lXVt0eXBlXSwgKDAsIGltcG9ydF90b29sa2l0NC5pc0Z1bGZpbGxlZCkoYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogdm9pZCAwLCAoMCwgaW1wb3J0X3Rvb2xraXQ0LmlzUmVqZWN0ZWRXaXRoVmFsdWUpKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHZvaWQgMCwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgXCJiYXNlUXVlcnlNZXRhXCIgaW4gYWN0aW9uLm1ldGEgPyBhY3Rpb24ubWV0YS5iYXNlUXVlcnlNZXRhIDogdm9pZCAwLCBhc3NlcnRUYWdUeXBlKTtcclxufVxyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFNsaWNlLnRzXHJcbnZhciBpbXBvcnRfaW1tZXIyID0gX190b01vZHVsZShyZXF1aXJlKFwiaW1tZXJcIikpO1xyXG52YXIgaW1wb3J0X2ltbWVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxuZnVuY3Rpb24gdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKHN0YXRlLCBxdWVyeUNhY2hlS2V5LCB1cGRhdGUpIHtcclxuICAgIHZhciBzdWJzdGF0ZSA9IHN0YXRlW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgaWYgKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgdXBkYXRlKHN1YnN0YXRlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gXCJhcmdcIiBpbiBpZCA/IGlkLmFyZy5maXhlZENhY2hlS2V5IDogaWQuZml4ZWRDYWNoZUtleSkgIT0gbnVsbCA/IF9hIDogaWQucmVxdWVzdElkO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhzdGF0ZSwgaWQsIHVwZGF0ZSkge1xyXG4gICAgdmFyIHN1YnN0YXRlID0gc3RhdGVbZ2V0TXV0YXRpb25DYWNoZUtleShpZCldO1xyXG4gICAgaWYgKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgdXBkYXRlKHN1YnN0YXRlKTtcclxuICAgIH1cclxufVxyXG52YXIgaW5pdGlhbFN0YXRlID0ge307XHJcbmZ1bmN0aW9uIGJ1aWxkU2xpY2UoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBxdWVyeVRodW5rID0gX2oucXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayA9IF9qLm11dGF0aW9uVGh1bmssIF9rID0gX2ouY29udGV4dCwgZGVmaW5pdGlvbnMgPSBfay5lbmRwb2ludERlZmluaXRpb25zLCBhcGlVaWQgPSBfay5hcGlVaWQsIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSBfay5leHRyYWN0UmVoeWRyYXRpb25JbmZvLCBoYXNSZWh5ZHJhdGlvbkluZm8gPSBfay5oYXNSZWh5ZHJhdGlvbkluZm8sIGFzc2VydFRhZ1R5cGUgPSBfai5hc3NlcnRUYWdUeXBlLCBjb25maWcgPSBfai5jb25maWc7XHJcbiAgICB2YXIgcmVzZXRBcGlTdGF0ZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlQWN0aW9uKShyZWR1Y2VyUGF0aCArIFwiL3Jlc2V0QXBpU3RhdGVcIik7XHJcbiAgICB2YXIgcXVlcnlTbGljZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlU2xpY2UpKHtcclxuICAgICAgICBuYW1lOiByZWR1Y2VyUGF0aCArIFwiL3F1ZXJpZXNcIixcclxuICAgICAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSxcclxuICAgICAgICByZWR1Y2Vyczoge1xyXG4gICAgICAgICAgICByZW1vdmVRdWVyeVJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFtxdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmVwYXJlOiAoMCwgaW1wb3J0X3Rvb2xraXQ2LnByZXBhcmVBdXRvQmF0Y2hlZCkoKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBxdWVyeVJlc3VsdFBhdGNoZWQ6IHtcclxuICAgICAgICAgICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2sgPSBfai5wYXlsb2FkLCBxdWVyeUNhY2hlS2V5ID0gX2sucXVlcnlDYWNoZUtleSwgcGF0Y2hlcyA9IF9rLnBhdGNoZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5LCBmdW5jdGlvbiAoc3Vic3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9ICgwLCBpbXBvcnRfaW1tZXIzLmFwcGx5UGF0Y2hlcykoc3Vic3RhdGUuZGF0YSwgcGF0Y2hlcy5jb25jYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJlcGFyZTogKDAsIGltcG9ydF90b29sa2l0Ni5wcmVwYXJlQXV0b0JhdGNoZWQpKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFSZWR1Y2VyczogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5VGh1bmsucGVuZGluZywgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfai5tZXRhLCBhcmcgPSBfai5tZXRhLmFyZztcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBzZXJ0aW5nID0gaXNVcHNlcnRRdWVyeShhcmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5zdWJzY3JpYmUgfHwgdXBzZXJ0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gZHJhZnRbX2EgPSBhcmcucXVlcnlDYWNoZUtleV0pICE9IG51bGwgPyBfYiA6IGRyYWZ0W19hXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgZnVuY3Rpb24gKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gUXVlcnlTdGF0dXMucGVuZGluZztcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgPSB1cHNlcnRpbmcgJiYgc3Vic3RhdGUucmVxdWVzdElkID8gc3Vic3RhdGUucmVxdWVzdElkIDogbWV0YS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5vcmlnaW5hbEFyZ3MgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5vcmlnaW5hbEFyZ3MgPSBhcmcub3JpZ2luYWxBcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5zdGFydGVkVGltZVN0YW1wID0gbWV0YS5zdGFydGVkVGltZVN0YW1wO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLmFkZENhc2UocXVlcnlUaHVuay5mdWxmaWxsZWQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gX2oubWV0YSwgcGF5bG9hZCA9IF9qLnBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIG1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXksIGZ1bmN0aW9uIChzdWJzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCAmJiAhaXNVcHNlcnRRdWVyeShtZXRhLmFyZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2UgPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdLm1lcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRpbWVTdGFtcF8xID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXAsIGFyZ18xID0gbWV0YS5hcmcsIGJhc2VRdWVyeU1ldGFfMSA9IG1ldGEuYmFzZVF1ZXJ5TWV0YSwgcmVxdWVzdElkXzEgPSBtZXRhLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVOZXh0U3RhdGUpKHN1YnN0YXRlLmRhdGEsIGZ1bmN0aW9uIChkcmFmdFN1YnN0YXRlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZShkcmFmdFN1YnN0YXRlRGF0YSwgcGF5bG9hZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmc6IGFyZ18xLm9yaWdpbmFsQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YTogYmFzZVF1ZXJ5TWV0YV8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IGZ1bGZpbGxlZFRpbWVTdGFtcF8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZF8xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBuZXdEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSAoKF9hID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXS5zdHJ1Y3R1cmFsU2hhcmluZykgIT0gbnVsbCA/IF9hIDogdHJ1ZSkgPyBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKCgwLCBpbXBvcnRfaW1tZXIyLmlzRHJhZnQpKHN1YnN0YXRlLmRhdGEpID8gKDAsIGltcG9ydF9pbW1lcjMub3JpZ2luYWwpKHN1YnN0YXRlLmRhdGEpIDogc3Vic3RhdGUuZGF0YSwgcGF5bG9hZCkgOiBwYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3Vic3RhdGUuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZnVsZmlsbGVkVGltZVN0YW1wID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShxdWVyeVRodW5rLnJlamVjdGVkLCBmdW5jdGlvbiAoZHJhZnQsIF9qKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2sgPSBfai5tZXRhLCBjb25kaXRpb24gPSBfay5jb25kaXRpb24sIGFyZyA9IF9rLmFyZywgcmVxdWVzdElkID0gX2sucmVxdWVzdElkLCBlcnJvciA9IF9qLmVycm9yLCBwYXlsb2FkID0gX2oucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIGZ1bmN0aW9uIChzdWJzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCAhPSBudWxsID8gcGF5bG9hZCA6IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyaWVzID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pLnF1ZXJpZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMocXVlcmllcyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrZXkgPSBfbFswXSwgZW50cnkgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5zdGF0dXMpID09PSBRdWVyeVN0YXR1cy5mdWxmaWxsZWQgfHwgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5zdGF0dXMpID09PSBRdWVyeVN0YXR1cy5yZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBtdXRhdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvbXV0YXRpb25zXCIsXHJcbiAgICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IF9qLnBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gZ2V0TXV0YXRpb25DYWNoZUtleShwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkgaW4gZHJhZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRyYWZ0W2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJlcGFyZTogKDAsIGltcG9ydF90b29sa2l0Ni5wcmVwYXJlQXV0b0JhdGNoZWQpKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFSZWR1Y2VyczogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKG11dGF0aW9uVGh1bmsucGVuZGluZywgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfai5tZXRhLCBfayA9IF9qLm1ldGEsIHJlcXVlc3RJZCA9IF9rLnJlcXVlc3RJZCwgYXJnID0gX2suYXJnLCBzdGFydGVkVGltZVN0YW1wID0gX2suc3RhcnRlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIGlmICghYXJnLnRyYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGRyYWZ0W2dldE11dGF0aW9uQ2FjaGVLZXkobWV0YSldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcDogc3RhcnRlZFRpbWVTdGFtcFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShtdXRhdGlvblRodW5rLmZ1bGZpbGxlZCwgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBfai5wYXlsb2FkLCBtZXRhID0gX2oubWV0YTtcclxuICAgICAgICAgICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCBmdW5jdGlvbiAoc3Vic3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsucmVqZWN0ZWQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gX2oucGF5bG9hZCwgZXJyb3IgPSBfai5lcnJvciwgbWV0YSA9IF9qLm1ldGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgZnVuY3Rpb24gKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBRdWVyeVN0YXR1cy5yZWplY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5lcnJvciA9IHBheWxvYWQgIT0gbnVsbCA/IHBheWxvYWQgOiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbnMgPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikubXV0YXRpb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5lbnRyaWVzKG11dGF0aW9ucyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrZXkgPSBfbFswXSwgZW50cnkgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuc3RhdHVzKSA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkIHx8IChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuc3RhdHVzKSA9PT0gUXVlcnlTdGF0dXMucmVqZWN0ZWQpICYmIGtleSAhPT0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWZ0W2tleV0gPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGludmFsaWRhdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvaW52YWxpZGF0aW9uXCIsXHJcbiAgICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgdXBkYXRlUHJvdmlkZWRCeToge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5LCBwcm92aWRlZFRhZ3MgPSBfai5wcm92aWRlZFRhZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBfbCA9IE9iamVjdC52YWx1ZXMoZHJhZnQpOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnVHlwZVN1YnNjcmlwdGlvbnMgPSBfbFtfa107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9tID0gMCwgX28gPSBPYmplY3QudmFsdWVzKHRhZ1R5cGVTdWJzY3JpcHRpb25zKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZFN1YnNjcmlwdGlvbnMgPSBfb1tfbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRBdCA9IGlkU3Vic2NyaXB0aW9ucy5pbmRleE9mKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQXQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcCA9IDAsIHByb3ZpZGVkVGFnc18xID0gcHJvdmlkZWRUYWdzOyBfcCA8IHByb3ZpZGVkVGFnc18xLmxlbmd0aDsgX3ArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3EgPSBwcm92aWRlZFRhZ3NfMVtfcF0sIHR5cGUgPSBfcS50eXBlLCBpZCA9IF9xLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoX2QgPSAoX2IgPSAoX2EgPSBkcmFmdFt0eXBlXSkgIT0gbnVsbCA/IF9hIDogZHJhZnRbdHlwZV0gPSB7fSlbX2MgPSBpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSkgIT0gbnVsbCA/IF9kIDogX2JbX2NdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5U3Vic2NyaWJlZCA9IHN1YnNjcmliZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlTdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByZXBhcmU6ICgwLCBpbXBvcnRfdG9vbGtpdDYucHJlcGFyZUF1dG9CYXRjaGVkKSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4dHJhUmVkdWNlcnM6IGZ1bmN0aW9uIChidWlsZGVyKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVNsaWNlLmFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBfbCA9IE9iamVjdC52YWx1ZXMoZHJhZnQpOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdUeXBlU3Vic2NyaXB0aW9ucyA9IF9sW19rXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gT2JqZWN0LnZhbHVlcyh0YWdUeXBlU3Vic2NyaXB0aW9ucyk7IF9tIDwgX28ubGVuZ3RoOyBfbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZFN1YnNjcmlwdGlvbnMgPSBfb1tfbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEF0ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIGZ1bmN0aW9uIChkcmFmdCwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZWQgPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikucHJvdmlkZWQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMocHJvdmlkZWQpOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbCA9IF9rW19qXSwgdHlwZSA9IF9sWzBdLCBpbmNvbWluZ1RhZ3MgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdUYWdzKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wID0gX29bX21dLCBpZCA9IF9wWzBdLCBjYWNoZUtleXMgPSBfcFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZWRRdWVyaWVzID0gKF9kID0gKF9iID0gKF9hID0gZHJhZnRbdHlwZV0pICE9IG51bGwgPyBfYSA6IGRyYWZ0W3R5cGVdID0ge30pW19jID0gaWQgfHwgXCJfX2ludGVybmFsX3dpdGhvdXRfaWRcIl0pICE9IG51bGwgPyBfZCA6IF9iW19jXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcSA9IDAsIGNhY2hlS2V5c18xID0gY2FjaGVLZXlzOyBfcSA8IGNhY2hlS2V5c18xLmxlbmd0aDsgX3ErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBjYWNoZUtleXNfMVtfcV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKCgwLCBpbXBvcnRfdG9vbGtpdDYuaXNBbnlPZikoKDAsIGltcG9ydF90b29sa2l0Ni5pc0Z1bGZpbGxlZCkocXVlcnlUaHVuayksICgwLCBpbXBvcnRfdG9vbGtpdDYuaXNSZWplY3RlZFdpdGhWYWx1ZSkocXVlcnlUaHVuaykpLCBmdW5jdGlvbiAoZHJhZnQsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVkVGFncyA9IGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIFwicHJvdmlkZXNUYWdzXCIsIGRlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKTtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gYWN0aW9uLm1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRpb25TbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUHJvdmlkZWRCeShkcmFmdCwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucy51cGRhdGVQcm92aWRlZEJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkVGFnczogcHJvdmlkZWRUYWdzXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvc3Vic2NyaXB0aW9uc1wiLFxyXG4gICAgICAgIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlLFxyXG4gICAgICAgIHJlZHVjZXJzOiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnM6IGZ1bmN0aW9uIChkLCBhKSB7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQ6IGZ1bmN0aW9uIChkLCBhKSB7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVybmFsX3Byb2JlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbiAoZCwgYSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UgPSAoMCwgaW1wb3J0X3Rvb2xraXQ2LmNyZWF0ZVNsaWNlKSh7XHJcbiAgICAgICAgbmFtZTogcmVkdWNlclBhdGggKyBcIi9pbnRlcm5hbFN1YnNjcmlwdGlvbnNcIixcclxuICAgICAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSxcclxuICAgICAgICByZWR1Y2Vyczoge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zVXBkYXRlZDoge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9pbW1lcjMuYXBwbHlQYXRjaGVzKShzdGF0ZSwgYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByZXBhcmU6ICgwLCBpbXBvcnRfdG9vbGtpdDYucHJlcGFyZUF1dG9CYXRjaGVkKSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBjb25maWdTbGljZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlU2xpY2UpKHtcclxuICAgICAgICBuYW1lOiByZWR1Y2VyUGF0aCArIFwiL2NvbmZpZ1wiLFxyXG4gICAgICAgIGluaXRpYWxTdGF0ZTogX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICBvbmxpbmU6IGlzT25saW5lKCksXHJcbiAgICAgICAgICAgIGZvY3VzZWQ6IGlzRG9jdW1lbnRWaXNpYmxlKCksXHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVSZWdpc3RlcmVkOiBmYWxzZVxyXG4gICAgICAgIH0sIGNvbmZpZyksXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZVJlZ2lzdGVyZWQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gX2oucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIiB8fCBhcGlVaWQgIT09IHBheWxvYWQgPyBcImNvbmZsaWN0XCIgOiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHRyYVJlZHVjZXJzOiBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBidWlsZGVyLmFkZENhc2Uob25PbmxpbmUsIGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUub25saW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShvbk9mZmxpbmUsIGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUub25saW5lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmFkZENhc2Uob25Gb2N1cywgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzTG9zdCwgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCBmdW5jdGlvbiAoZHJhZnQpIHsgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBkcmFmdCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGNvbWJpbmVkUmVkdWNlciA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY29tYmluZVJlZHVjZXJzKSh7XHJcbiAgICAgICAgcXVlcmllczogcXVlcnlTbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIG11dGF0aW9uczogbXV0YXRpb25TbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIHByb3ZpZGVkOiBpbnZhbGlkYXRpb25TbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IGludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlLnJlZHVjZXIsXHJcbiAgICAgICAgY29uZmlnOiBjb25maWdTbGljZS5yZWR1Y2VyXHJcbiAgICB9KTtcclxuICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHsgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcihyZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikgPyB2b2lkIDAgOiBzdGF0ZSwgYWN0aW9uKTsgfTtcclxuICAgIHZhciBhY3Rpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29uZmlnU2xpY2UuYWN0aW9ucyksIHF1ZXJ5U2xpY2UuYWN0aW9ucyksIHN1YnNjcmlwdGlvblNsaWNlLmFjdGlvbnMpLCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zKSwgbXV0YXRpb25TbGljZS5hY3Rpb25zKSwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucyksIHtcclxuICAgICAgICB1bnN1YnNjcmliZU11dGF0aW9uUmVzdWx0OiBtdXRhdGlvblNsaWNlLmFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQsXHJcbiAgICAgICAgcmVzZXRBcGlTdGF0ZTogcmVzZXRBcGlTdGF0ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4geyByZWR1Y2VyOiByZWR1Y2VyLCBhY3Rpb25zOiBhY3Rpb25zIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTZWxlY3RvcnMudHNcclxudmFyIHNraXBUb2tlbiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiUlRLUS9za2lwVG9rZW5cIik7XHJcbnZhciBza2lwU2VsZWN0b3IgPSBza2lwVG9rZW47XHJcbnZhciBpbml0aWFsU3ViU3RhdGUgPSB7XHJcbiAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWRcclxufTtcclxudmFyIGRlZmF1bHRRdWVyeVN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDcuY3JlYXRlTmV4dFN0YXRlKShpbml0aWFsU3ViU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxufSk7XHJcbnZhciBkZWZhdWx0TXV0YXRpb25TdWJTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X3Rvb2xraXQ3LmNyZWF0ZU5leHRTdGF0ZSkoaW5pdGlhbFN1YlN0YXRlLCBmdW5jdGlvbiAoKSB7XHJcbn0pO1xyXG5mdW5jdGlvbiBidWlsZFNlbGVjdG9ycyhfaikge1xyXG4gICAgdmFyIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aDtcclxuICAgIHZhciBzZWxlY3RTa2lwcGVkUXVlcnkgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGRlZmF1bHRRdWVyeVN1YlN0YXRlOyB9O1xyXG4gICAgdmFyIHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gZGVmYXVsdE11dGF0aW9uU3ViU3RhdGU7IH07XHJcbiAgICByZXR1cm4geyBidWlsZFF1ZXJ5U2VsZWN0b3I6IGJ1aWxkUXVlcnlTZWxlY3RvciwgYnVpbGRNdXRhdGlvblNlbGVjdG9yOiBidWlsZE11dGF0aW9uU2VsZWN0b3IsIHNlbGVjdEludmFsaWRhdGVkQnk6IHNlbGVjdEludmFsaWRhdGVkQnkgfTtcclxuICAgIGZ1bmN0aW9uIHdpdGhSZXF1ZXN0RmxhZ3Moc3Vic3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHN1YnN0YXRlKSwgZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2VsZWN0SW50ZXJuYWxTdGF0ZShyb290U3RhdGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSByb290U3RhdGVbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgYHN0YXRlLlwiICsgcmVkdWNlclBhdGggKyBcImAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocXVlcnlBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQXJncyA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUFyZ3M6IHF1ZXJ5QXJncyxcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbjogZW5kcG9pbnREZWZpbml0aW9uLFxyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnROYW1lOiBlbmRwb2ludE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RRdWVyeVN1YnN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBzZWxlY3RJbnRlcm5hbFN0YXRlKHN0YXRlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYltzZXJpYWxpemVkQXJnc10pICE9IG51bGwgPyBfYyA6IGRlZmF1bHRRdWVyeVN1YlN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlID0gcXVlcnlBcmdzID09PSBza2lwVG9rZW4gPyBzZWxlY3RTa2lwcGVkUXVlcnkgOiBzZWxlY3RRdWVyeVN1YnN0YXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF90b29sa2l0Ny5jcmVhdGVTZWxlY3RvcikoZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRNdXRhdGlvblNlbGVjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgbXV0YXRpb25JZDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25JZCA9IChfYSA9IGdldE11dGF0aW9uQ2FjaGVLZXkoaWQpKSAhPSBudWxsID8gX2EgOiBza2lwVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbklkID0gaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlbGVjdE11dGF0aW9uU3Vic3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTIsIF9iLCBfYztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EyID0gc2VsZWN0SW50ZXJuYWxTdGF0ZShzdGF0ZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubXV0YXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2JbbXV0YXRpb25JZF0pICE9IG51bGwgPyBfYyA6IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfdG9vbGtpdDcuY3JlYXRlU2VsZWN0b3IpKGZpbmFsU2VsZWN0TXV0YXRpb25TdWJzdGF0ZSwgd2l0aFJlcXVlc3RGbGFncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGFwaVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIHZhciB0b0ludmFsaWRhdGUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IHRhZ3MubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHRhZyA9IF9rW19qXTtcclxuICAgICAgICAgICAgdmFyIHByb3ZpZGVkID0gYXBpU3RhdGUucHJvdmlkZWRbdGFnLnR5cGVdO1xyXG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMgPSAoX2EgPSB0YWcuaWQgIT09IHZvaWQgMCA/IHByb3ZpZGVkW3RhZy5pZF0gOiBmbGF0dGVuKE9iamVjdC52YWx1ZXMocHJvdmlkZWQpKSkgIT0gbnVsbCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9sID0gMCwgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnNfMSA9IGludmFsaWRhdGVTdWJzY3JpcHRpb25zOyBfbCA8IGludmFsaWRhdGVTdWJzY3JpcHRpb25zXzEubGVuZ3RoOyBfbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52YWxpZGF0ZSA9IGludmFsaWRhdGVTdWJzY3JpcHRpb25zXzFbX2xdO1xyXG4gICAgICAgICAgICAgICAgdG9JbnZhbGlkYXRlLmFkZChpbnZhbGlkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxhdHRlbihBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSkubWFwKGZ1bmN0aW9uIChxdWVyeUNhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeVN1YlN0YXRlID0gYXBpU3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5U3ViU3RhdGUgPyBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSxcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IHF1ZXJ5U3ViU3RhdGUuZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSA6IFtdO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG4vLyBzcmMvcXVlcnkvZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncy50c1xyXG52YXIgaW1wb3J0X3Rvb2xraXQ4ID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBjYWNoZSA9IFdlYWtNYXAgPyBuZXcgV2Vha01hcCgpIDogdm9pZCAwO1xyXG52YXIgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGVuZHBvaW50TmFtZSA9IF9qLmVuZHBvaW50TmFtZSwgcXVlcnlBcmdzID0gX2oucXVlcnlBcmdzO1xyXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBcIlwiO1xyXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlID09IG51bGwgPyB2b2lkIDAgOiBjYWNoZS5nZXQocXVlcnlBcmdzKTtcclxuICAgIGlmICh0eXBlb2YgY2FjaGVkID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZCA9IGNhY2hlZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5QXJncywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgcmV0dXJuICgwLCBpbXBvcnRfdG9vbGtpdDguaXNQbGFpbk9iamVjdCkodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5Mikge1xyXG4gICAgICAgICAgICBhY2Nba2V5Ml0gPSB2YWx1ZVtrZXkyXTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LCB7fSkgOiB2YWx1ZTsgfSk7XHJcbiAgICAgICAgaWYgKCgwLCBpbXBvcnRfdG9vbGtpdDguaXNQbGFpbk9iamVjdCkocXVlcnlBcmdzKSkge1xyXG4gICAgICAgICAgICBjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5kcG9pbnROYW1lICsgXCIoXCIgKyBzZXJpYWxpemVkICsgXCIpXCI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jcmVhdGVBcGkudHNcclxudmFyIGltcG9ydF90b29sa2l0OSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG52YXIgaW1wb3J0X3Jlc2VsZWN0ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVzZWxlY3RcIikpO1xyXG5mdW5jdGlvbiBidWlsZENyZWF0ZUFwaSgpIHtcclxuICAgIHZhciBtb2R1bGVzID0gW107XHJcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgYXJndW1lbnRzLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgIG1vZHVsZXNbX2pdID0gYXJndW1lbnRzW19qXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBiYXNlQ3JlYXRlQXBpKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyA9ICgwLCBpbXBvcnRfcmVzZWxlY3QuZGVmYXVsdE1lbW9pemUpKGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIChfYiA9IG9wdGlvbnMuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgYWN0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICByZWR1Y2VyUGF0aDogKF9hID0gb3B0aW9ucy5yZWR1Y2VyUGF0aCkgIT0gbnVsbCA/IF9hIDogXCJhcGlcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogXCJhcGlcIixcclxuICAgICAgICAgICAga2VlcFVudXNlZERhdGFGb3I6IDYwLFxyXG4gICAgICAgICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVmZXRjaE9uRm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IGZhbHNlXHJcbiAgICAgICAgfSwgb3B0aW9ucyksIHtcclxuICAgICAgICAgICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbzogZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcclxuICAgICAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiBmdW5jdGlvbiAocXVlcnlBcmdzQXBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic2VyaWFsaXplUXVlcnlBcmdzXCIgaW4gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludFNRQV8xID0gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbi5zZXJpYWxpemVRdWVyeUFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBmdW5jdGlvbiAocXVlcnlBcmdzQXBpMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFJlc3VsdCA9IGVuZHBvaW50U1FBXzEocXVlcnlBcmdzQXBpMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBxdWVyeUFyZ3NBcGkyKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogaW5pdGlhbFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YWdUeXBlczogX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy50YWdUeXBlcyB8fCBbXSlcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uczoge30sXHJcbiAgICAgICAgICAgIGJhdGNoOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFwaVVpZDogKDAsIGltcG9ydF90b29sa2l0OS5uYW5vaWQpKCksXHJcbiAgICAgICAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm86IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXHJcbiAgICAgICAgICAgIGhhc1JlaHlkcmF0aW9uSW5mbzogKDAsIGltcG9ydF9yZXNlbGVjdC5kZWZhdWx0TWVtb2l6ZSkoZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pICE9IG51bGw7IH0pXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYXBpID0ge1xyXG4gICAgICAgICAgICBpbmplY3RFbmRwb2ludHM6IGluamVjdEVuZHBvaW50cyxcclxuICAgICAgICAgICAgZW5oYW5jZUVuZHBvaW50czogZnVuY3Rpb24gKF9qKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkVGFnVHlwZXMgPSBfai5hZGRUYWdUeXBlcywgZW5kcG9pbnRzID0gX2ouZW5kcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFRhZ1R5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBhZGRUYWdUeXBlc18xID0gYWRkVGFnVHlwZXM7IF9rIDwgYWRkVGFnVHlwZXNfMS5sZW5ndGg7IF9rKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVUID0gYWRkVGFnVHlwZXNfMVtfa107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5pbmNsdWRlcyhlVCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNXaXRoRGVmYXVsdHMudGFnVHlwZXMucHVzaChlVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2wgPSAwLCBfbSA9IE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cyk7IF9sIDwgX20ubGVuZ3RoOyBfbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbyA9IF9tW19sXSwgZW5kcG9pbnROYW1lID0gX29bMF0sIHBhcnRpYWxEZWZpbml0aW9uID0gX29bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydGlhbERlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbERlZmluaXRpb24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSB8fCB7fSwgcGFydGlhbERlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGluaXRpYWxpemVkTW9kdWxlcyA9IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmluaXQoYXBpLCBvcHRpb25zV2l0aERlZmF1bHRzLCBjb250ZXh0KTsgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gaW5qZWN0RW5kcG9pbnRzKGluamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XHJcbiAgICAgICAgICAgICAgICBxdWVyeTogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHgpLCB7IHR5cGU6IERlZmluaXRpb25UeXBlLnF1ZXJ5IH0pOyB9LFxyXG4gICAgICAgICAgICAgICAgbXV0YXRpb246IGZ1bmN0aW9uICh4KSB7IHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB4KSwgeyB0eXBlOiBEZWZpbml0aW9uVHlwZS5tdXRhdGlvbiB9KTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5lbnRyaWVzKGV2YWx1YXRlZEVuZHBvaW50cyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2wgPSBfa1tfal0sIGVuZHBvaW50TmFtZSA9IF9sWzBdLCBkZWZpbml0aW9uID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluamVjdC5vdmVycmlkZUV4aXN0aW5nICYmIGVuZHBvaW50TmFtZSBpbiBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FsbGVkIGBpbmplY3RFbmRwb2ludHNgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lIFwiICsgZW5kcG9pbnROYW1lICsgXCIgd2l0aG91dCBzcGVjaWZ5aW5nIGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlYFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIGluaXRpYWxpemVkTW9kdWxlc18xID0gaW5pdGlhbGl6ZWRNb2R1bGVzOyBfbSA8IGluaXRpYWxpemVkTW9kdWxlc18xLmxlbmd0aDsgX20rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gaW5pdGlhbGl6ZWRNb2R1bGVzXzFbX21dO1xyXG4gICAgICAgICAgICAgICAgICAgIG0uaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBpLmluamVjdEVuZHBvaW50cyh7IGVuZHBvaW50czogb3B0aW9ucy5lbmRwb2ludHMgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9xdWVyeS9mYWtlQmFzZVF1ZXJ5LnRzXHJcbmZ1bmN0aW9uIGZha2VCYXNlUXVlcnkoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gdXNpbmcgYGZha2VCYXNlUXVlcnlgLCBhbGwgcXVlcmllcyAmIG11dGF0aW9ucyBtdXN0IHVzZSB0aGUgYHF1ZXJ5Rm5gIGRlZmluaXRpb24gc3ludGF4LlwiKTtcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2luZGV4LnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDEzID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUNvbGxlY3Rpb24udHNcclxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcclxuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxudmFyIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTID0gMjE0NzQ4MzY0NyAvIDFlMyAtIDE7XHJcbnZhciBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBhcGkgPSBfai5hcGksIGNvbnRleHQgPSBfai5jb250ZXh0LCBpbnRlcm5hbFN0YXRlID0gX2ouaW50ZXJuYWxTdGF0ZTtcclxuICAgIHZhciBfayA9IGFwaS5pbnRlcm5hbEFjdGlvbnMsIHJlbW92ZVF1ZXJ5UmVzdWx0ID0gX2sucmVtb3ZlUXVlcnlSZXN1bHQsIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQgPSBfay51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0O1xyXG4gICAgZnVuY3Rpb24gYW55U3Vic2NyaXB0aW9uc1JlbWFpbmluZ0ZvcktleShxdWVyeUNhY2hlS2V5KSB7XHJcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnMgJiYgIWlzT2JqZWN0RW1wdHkoc3Vic2NyaXB0aW9ucyk7XHJcbiAgICB9XHJcbiAgICB2YXIgY3VycmVudFJlbW92YWxUaW1lb3V0cyA9IHt9O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSwgaW50ZXJuYWxTdGF0ZTIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBhY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCAoX2EgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMoY3VycmVudFJlbW92YWxUaW1lb3V0cyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2wgPSBfa1tfal0sIGtleSA9IF9sWzBdLCB0aW1lb3V0ID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dClcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IGNvbnRleHQuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pLnF1ZXJpZXM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9tID0gMCwgX28gPSBPYmplY3QuZW50cmllcyhxdWVyaWVzKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcCA9IF9vW19tXSwgcXVlcnlDYWNoZUtleSA9IF9wWzBdLCBxdWVyeVN0YXRlID0gX3BbMV07XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCBxdWVyeVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeVN0YXRlLmVuZHBvaW50TmFtZSwgbXdBcGksIHN0YXRlLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgZW5kcG9pbnROYW1lLCBhcGkyLCBjb25maWcpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgIHZhciBrZWVwVW51c2VkRGF0YUZvciA9IChfYSA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLmtlZXBVbnVzZWREYXRhRm9yKSAhPSBudWxsID8gX2EgOiBjb25maWcua2VlcFVudXNlZERhdGFGb3I7XHJcbiAgICAgICAgaWYgKGtlZXBVbnVzZWREYXRhRm9yID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaW5hbEtlZXBVbnVzZWREYXRhRm9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oa2VlcFVudXNlZERhdGFGb3IsIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTKSk7XHJcbiAgICAgICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZW91dCA9IGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRUaW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW3F1ZXJ5Q2FjaGVLZXldID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHsgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgfSwgZmluYWxLZWVwVW51c2VkRGF0YUZvciAqIDFlMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbnZhbGlkYXRpb25CeVRhZ3MudHNcclxudmFyIGltcG9ydF90b29sa2l0MTAgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIHJlZHVjZXJQYXRoID0gX2oucmVkdWNlclBhdGgsIGNvbnRleHQgPSBfai5jb250ZXh0LCBlbmRwb2ludERlZmluaXRpb25zID0gX2ouY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zLCBtdXRhdGlvblRodW5rID0gX2oubXV0YXRpb25UaHVuaywgYXBpID0gX2ouYXBpLCBhc3NlcnRUYWdUeXBlID0gX2ouYXNzZXJ0VGFnVHlwZSwgcmVmZXRjaFF1ZXJ5ID0gX2oucmVmZXRjaFF1ZXJ5O1xyXG4gICAgdmFyIHJlbW92ZVF1ZXJ5UmVzdWx0ID0gYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdDtcclxuICAgIHZhciBpc1RodW5rQWN0aW9uV2l0aFRhZ3MgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMC5pc0FueU9mKSgoMCwgaW1wb3J0X3Rvb2xraXQxMC5pc0Z1bGZpbGxlZCkobXV0YXRpb25UaHVuayksICgwLCBpbXBvcnRfdG9vbGtpdDEwLmlzUmVqZWN0ZWRXaXRoVmFsdWUpKG11dGF0aW9uVGh1bmspKTtcclxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgbXdBcGkpIHtcclxuICAgICAgICBpZiAoaXNUaHVua0FjdGlvbldpdGhUYWdzKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJpbnZhbGlkYXRlc1RhZ3NcIiwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLmludmFsaWRhdGVUYWdzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeShhY3Rpb24ucGF5bG9hZCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlVGFncyh0YWdzLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciByb290U3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHJvb3RTdGF0ZVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcclxuICAgICAgICBjb250ZXh0LmJhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzQXJyYXkgPSBBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMCwgdmFsdWVzQXJyYXlfMSA9IHZhbHVlc0FycmF5OyBfaiA8IHZhbHVlc0FycmF5XzEubGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlDYWNoZUtleSA9IHZhbHVlc0FycmF5XzFbX2pdLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSAoX2EgPSBzdGF0ZS5zdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldKSAhPSBudWxsID8gX2EgOiB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeVN1YlN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG13QXBpLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3BvbGxpbmcudHNcclxudmFyIGJ1aWxkUG9sbGluZ0hhbmRsZXIgPSBmdW5jdGlvbiAoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBxdWVyeVRodW5rID0gX2oucXVlcnlUaHVuaywgYXBpID0gX2ouYXBpLCByZWZldGNoUXVlcnkgPSBfai5yZWZldGNoUXVlcnksIGludGVybmFsU3RhdGUgPSBfai5pbnRlcm5hbFN0YXRlO1xyXG4gICAgdmFyIGN1cnJlbnRQb2xscyA9IHt9O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB1cGRhdGVQb2xsaW5nSW50ZXJ2YWwoYWN0aW9uLnBheWxvYWQsIG13QXBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pIHx8IHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSAmJiBhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcclxuICAgICAgICAgICAgdXBkYXRlUG9sbGluZ0ludGVydmFsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgIWFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICBzdGFydE5leHRQb2xsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyUG9sbHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc3RhcnROZXh0UG9sbChfaiwgYXBpMikge1xyXG4gICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucXVlcnlDYWNoZUtleTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIHZhciBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaXB0aW9ucyk7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobG93ZXN0UG9sbGluZ0ludGVydmFsKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICBpZiAoY3VycmVudFBvbGwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRQb2xsLnRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRQb2xsLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9sbC50aW1lb3V0ID0gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgIHZhciBjdXJyZW50SW50ZXJ2YWwgPSBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV0gPSB7XHJcbiAgICAgICAgICAgIG5leHRQb2xsVGltZXN0YW1wOiBuZXh0UG9sbFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsOiBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsLnRpbWVvdXQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XHJcbiAgICAgICAgICAgIH0sIGxvd2VzdFBvbGxpbmdJbnRlcnZhbClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9sbGluZ0ludGVydmFsKF9qLCBhcGkyKSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpcHRpb25zKTtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXBQb2xsRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgIGlmICghY3VycmVudFBvbGwgfHwgbmV4dFBvbGxUaW1lc3RhbXAgPCBjdXJyZW50UG9sbC5uZXh0UG9sbFRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICBzdGFydE5leHRQb2xsKHsgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSB9LCBhcGkyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGVhbnVwUG9sbEZvcktleShrZXkpIHtcclxuICAgICAgICB2YXIgZXhpc3RpbmdQb2xsID0gY3VycmVudFBvbGxzW2tleV07XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUG9sbCA9PSBudWxsID8gdm9pZCAwIDogZXhpc3RpbmdQb2xsLnRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nUG9sbC50aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRQb2xsc1trZXldO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJQb2xscygpIHtcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmtleXMoY3VycmVudFBvbGxzKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IF9rW19qXTtcclxuICAgICAgICAgICAgY2xlYW51cFBvbGxGb3JLZXkoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzID09PSB2b2lkIDApIHsgc3Vic2NyaWJlcnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghIXN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBNYXRoLm1pbihzdWJzY3JpYmVyc1trZXldLnBvbGxpbmdJbnRlcnZhbCwgbG93ZXN0UG9sbGluZ0ludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS93aW5kb3dFdmVudEhhbmRsaW5nLnRzXHJcbnZhciBidWlsZFdpbmRvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIHJlZHVjZXJQYXRoID0gX2oucmVkdWNlclBhdGgsIGNvbnRleHQgPSBfai5jb250ZXh0LCBhcGkgPSBfai5hcGksIHJlZmV0Y2hRdWVyeSA9IF9qLnJlZmV0Y2hRdWVyeSwgaW50ZXJuYWxTdGF0ZSA9IF9qLmludGVybmFsU3RhdGU7XHJcbiAgICB2YXIgcmVtb3ZlUXVlcnlSZXN1bHQgPSBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25Gb2N1c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uT25saW5lLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25SZWNvbm5lY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHJlZmV0Y2hWYWxpZFF1ZXJpZXMoYXBpMiwgdHlwZSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBzdGF0ZS5xdWVyaWVzO1xyXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcclxuICAgICAgICBjb250ZXh0LmJhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnMpOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBfa1tfal07XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdWJTdGF0ZSA9IHF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBzdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25TdWJTdGF0ZSB8fCAhcXVlcnlTdWJTdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZWZldGNoID0gT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuc29tZShmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWJbdHlwZV0gPT09IHRydWU7IH0pIHx8IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpLmV2ZXJ5KGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Ylt0eXBlXSA9PT0gdm9pZCAwOyB9KSAmJiBzdGF0ZS5jb25maWdbdHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVmZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVyO1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUudHNcclxudmFyIGltcG9ydF90b29sa2l0MTEgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIG5ldmVyUmVzb2x2ZWRFcnJvciA9IG5ldyBFcnJvcihcIlByb21pc2UgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlIGNhY2hlRW50cnlSZW1vdmVkLlwiKTtcclxudmFyIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyID0gZnVuY3Rpb24gKF9qKSB7XHJcbiAgICB2YXIgYXBpID0gX2ouYXBpLCByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBjb250ZXh0ID0gX2ouY29udGV4dCwgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfai5tdXRhdGlvblRodW5rLCBpbnRlcm5hbFN0YXRlID0gX2ouaW50ZXJuYWxTdGF0ZTtcclxuICAgIHZhciBpc1F1ZXJ5VGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMS5pc0FzeW5jVGh1bmtBY3Rpb24pKHF1ZXJ5VGh1bmspO1xyXG4gICAgdmFyIGlzTXV0YXRpb25UaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDExLmlzQXN5bmNUaHVua0FjdGlvbikobXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNGdWxmaWxsZWRUaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDExLmlzRnVsZmlsbGVkKShxdWVyeVRodW5rLCBtdXRhdGlvblRodW5rKTtcclxuICAgIHZhciBsaWZlY3ljbGVNYXAgPSB7fTtcclxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgbXdBcGksIHN0YXRlQmVmb3JlKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoYWN0aW9uKTtcclxuICAgICAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gc3RhdGVCZWZvcmVbcmVkdWNlclBhdGhdLnF1ZXJpZXNbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5xdWVyaWVzW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgaWYgKCFvbGRTdGF0ZSAmJiBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlTmV3S2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgYWN0aW9uLm1ldGEucmVxdWVzdElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtdXRhdGlvblRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5tdXRhdGlvbnNbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU5ld0tleShhY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzLCBjYWNoZUtleSwgbXdBcGksIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGdWxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlID09IG51bGwgPyB2b2lkIDAgOiBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5wYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIGxpZmVjeWNsZSA9IGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XHJcbiAgICAgICAgICAgIGlmIChsaWZlY3ljbGUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMCwgX2sgPSBPYmplY3QuZW50cmllcyhsaWZlY3ljbGVNYXApOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBjYWNoZUtleTIgPSBfbFswXSwgbGlmZWN5Y2xlID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW2NhY2hlS2V5Ml07XHJcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBnZXRDYWNoZUtleShhY3Rpb24pIHtcclxuICAgICAgICBpZiAoaXNRdWVyeVRodW5rKGFjdGlvbikpXHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleTtcclxuICAgICAgICBpZiAoaXNNdXRhdGlvblRodW5rKGFjdGlvbikpXHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIGdldE11dGF0aW9uQ2FjaGVLZXkoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBxdWVyeUNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgIHZhciBvbkNhY2hlRW50cnlBZGRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLm9uQ2FjaGVFbnRyeUFkZGVkO1xyXG4gICAgICAgIGlmICghb25DYWNoZUVudHJ5QWRkZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgbGlmZWN5Y2xlID0ge307XHJcbiAgICAgICAgdmFyIGNhY2hlRW50cnlSZW1vdmVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY2FjaGVEYXRhTG9hZGVkID0gUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGNhY2hlRW50cnlSZW1vdmVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV2ZXJSZXNvbHZlZEVycm9yO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNhY2hlRGF0YUxvYWRlZC5jYXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3F1ZXJ5Q2FjaGVLZXldID0gbGlmZWN5Y2xlO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gb3JpZ2luYWxBcmdzIDogcXVlcnlDYWNoZUtleSk7XHJcbiAgICAgICAgdmFyIGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goZnVuY3Rpb24gKF8sIF9fLCBleHRyYTIpIHsgcmV0dXJuIGV4dHJhMjsgfSk7XHJcbiAgICAgICAgdmFyIGxpZmVjeWNsZUFwaSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG13QXBpKSwge1xyXG4gICAgICAgICAgICBnZXRDYWNoZUVudHJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKTsgfSxcclxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gZnVuY3Rpb24gKHVwZGF0ZVJlY2lwZSkgeyByZXR1cm4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKTsgfSA6IHZvaWQgMCxcclxuICAgICAgICAgICAgY2FjaGVEYXRhTG9hZGVkOiBjYWNoZURhdGFMb2FkZWQsXHJcbiAgICAgICAgICAgIGNhY2hlRW50cnlSZW1vdmVkOiBjYWNoZUVudHJ5UmVtb3ZlZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBydW5uaW5nSGFuZGxlciA9IG9uQ2FjaGVFbnRyeUFkZGVkKG9yaWdpbmFsQXJncywgbGlmZWN5Y2xlQXBpKTtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUocnVubmluZ0hhbmRsZXIpLmNhdGNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSBuZXZlclJlc29sdmVkRXJyb3IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDEyID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGFwaSA9IF9qLmFwaSwgY29udGV4dCA9IF9qLmNvbnRleHQsIHF1ZXJ5VGh1bmsgPSBfai5xdWVyeVRodW5rLCBtdXRhdGlvblRodW5rID0gX2oubXV0YXRpb25UaHVuaztcclxuICAgIHZhciBpc1BlbmRpbmdUaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDEyLmlzUGVuZGluZykocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNSZWplY3RlZFRodW5rID0gKDAsIGltcG9ydF90b29sa2l0MTIuaXNSZWplY3RlZCkocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNGdWxsZmlsbGVkVGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMi5pc0Z1bGZpbGxlZCkocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgbGlmZWN5Y2xlTWFwID0ge307XHJcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChhY3Rpb24sIG13QXBpKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgaWYgKGlzUGVuZGluZ1RodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9qLnJlcXVlc3RJZCwgX2sgPSBfai5hcmcsIGVuZHBvaW50TmFtZV8xID0gX2suZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3NfMSA9IF9rLm9yaWdpbmFsQXJncztcclxuICAgICAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVfMV07XHJcbiAgICAgICAgICAgIHZhciBvblF1ZXJ5U3RhcnRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLm9uUXVlcnlTdGFydGVkO1xyXG4gICAgICAgICAgICBpZiAob25RdWVyeVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaWZlY3ljbGVfMSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5RnVsZmlsbGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZV8xLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZV8xLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlGdWxmaWxsZWQuY2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXSA9IGxpZmVjeWNsZV8xO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yXzEgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV8xXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gb3JpZ2luYWxBcmdzXzEgOiByZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goZnVuY3Rpb24gKF8sIF9fLCBleHRyYTIpIHsgcmV0dXJuIGV4dHJhMjsgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlmZWN5Y2xlQXBpID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbXdBcGkpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVFbnRyeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0b3JfMShtd0FwaS5nZXRTdGF0ZSgpKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gZnVuY3Rpb24gKHVwZGF0ZVJlY2lwZSkgeyByZXR1cm4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZV8xLCBvcmlnaW5hbEFyZ3NfMSwgdXBkYXRlUmVjaXBlKSk7IH0gOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlGdWxmaWxsZWQ6IHF1ZXJ5RnVsZmlsbGVkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9uUXVlcnlTdGFydGVkKG9yaWdpbmFsQXJnc18xLCBsaWZlY3ljbGVBcGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRnVsbGZpbGxlZFRodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9sID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9sLnJlcXVlc3RJZCwgYmFzZVF1ZXJ5TWV0YSA9IF9sLmJhc2VRdWVyeU1ldGE7XHJcbiAgICAgICAgICAgIChfYSA9IGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIG1ldGE6IGJhc2VRdWVyeU1ldGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWplY3RlZFRodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9tID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9tLnJlcXVlc3RJZCwgcmVqZWN0ZWRXaXRoVmFsdWUgPSBfbS5yZWplY3RlZFdpdGhWYWx1ZSwgYmFzZVF1ZXJ5TWV0YSA9IF9tLmJhc2VRdWVyeU1ldGE7XHJcbiAgICAgICAgICAgIChfYyA9IGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVqZWN0KHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAoX2IgPSBhY3Rpb24ucGF5bG9hZCkgIT0gbnVsbCA/IF9iIDogYWN0aW9uLmVycm9yLFxyXG4gICAgICAgICAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2Rldk1pZGRsZXdhcmUudHNcclxudmFyIGJ1aWxkRGV2Q2hlY2tIYW5kbGVyID0gZnVuY3Rpb24gKF9qKSB7XHJcbiAgICB2YXIgYXBpID0gX2ouYXBpLCBhcGlVaWQgPSBfai5jb250ZXh0LmFwaVVpZCwgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkKGFwaVVpZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5wYXlsb2FkID09PSBhcGlVaWQgJiYgKChfYiA9IChfYSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWlkZGxld2FyZVJlZ2lzdGVyZWQpID09PSBcImNvbmZsaWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIGlzIGEgbWlzbWF0Y2ggYmV0d2VlbiBzbGljZSBhbmQgbWlkZGxld2FyZSBmb3IgdGhlIHJlZHVjZXJQYXRoIFxcXCJcIiArIHJlZHVjZXJQYXRoICsgXCJcXFwiLlxcbllvdSBjYW4gb25seSBoYXZlIG9uZSBhcGkgcGVyIHJlZHVjZXIgcGF0aCwgdGhpcyB3aWxsIGxlYWQgdG8gY3Jhc2hlcyBpbiB2YXJpb3VzIHNpdHVhdGlvbnMhXCIgKyAocmVkdWNlclBhdGggPT09IFwiYXBpXCIgPyBcIlxcbklmIHlvdSBoYXZlIG11bHRpcGxlIGFwaXMsIHlvdSAqaGF2ZSogdG8gc3BlY2lmeSB0aGUgcmVkdWNlclBhdGggb3B0aW9uIHdoZW4gdXNpbmcgY3JlYXRlQXBpIVwiIDogXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2JhdGNoQWN0aW9ucy50c1xyXG52YXIgaW1wb3J0X2ltbWVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIHByb21pc2U7XHJcbnZhciBxdWV1ZU1pY3JvdGFza1NoaW0gPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09IFwiZnVuY3Rpb25cIiA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBnbG9iYWxUaGlzKSA6IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpLnRoZW4oY2IpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgdGhyb3cgZXJyO1xyXG59LCAwKTsgfSk7IH07XHJcbnZhciBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGFwaSA9IF9qLmFwaSwgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIGludGVybmFsU3RhdGUgPSBfai5pbnRlcm5hbFN0YXRlO1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvbnNQcmVmaXggPSBhcGkucmVkdWNlclBhdGggKyBcIi9zdWJzY3JpcHRpb25zXCI7XHJcbiAgICB2YXIgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbnVsbDtcclxuICAgIHZhciBkaXNwYXRjaFF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgdmFyIF9rID0gYXBpLmludGVybmFsQWN0aW9ucywgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IF9rLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMsIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQgPSBfay51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChtdXRhYmxlU3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xyXG4gICAgICAgIGlmICh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQgPSBfai5yZXF1ZXN0SWQsIG9wdGlvbnMgPSBfai5vcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoKF9hID0gbXV0YWJsZVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVtyZXF1ZXN0SWRdKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9rID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfay5xdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQgPSBfay5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmIChtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgbXV0YWJsZVN0YXRlW2FjdGlvbi5wYXlsb2FkLnF1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBfbCA9IGFjdGlvbi5tZXRhLCBhcmcgPSBfbC5hcmcsIHJlcXVlc3RJZCA9IF9sLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJzdGF0ZSA9IChfYyA9IG11dGFibGVTdGF0ZVtfYiA9IGFyZy5xdWVyeUNhY2hlS2V5XSkgIT0gbnVsbCA/IF9jIDogbXV0YWJsZVN0YXRlW19iXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IChfZSA9IChfZCA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zKSAhPSBudWxsID8gX2QgOiBzdWJzdGF0ZVtyZXF1ZXN0SWRdKSAhPSBudWxsID8gX2UgOiB7fTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9tID0gYWN0aW9uLm1ldGEsIGNvbmRpdGlvbiA9IF9tLmNvbmRpdGlvbiwgYXJnID0gX20uYXJnLCByZXF1ZXN0SWQgPSBfbS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0YXRlID0gKF9nID0gbXV0YWJsZVN0YXRlW19mID0gYXJnLnF1ZXJ5Q2FjaGVLZXldKSAhPSBudWxsID8gX2cgOiBtdXRhYmxlU3RhdGVbX2ZdID0ge307XHJcbiAgICAgICAgICAgICAgICBzdWJzdGF0ZVtyZXF1ZXN0SWRdID0gKF9pID0gKF9oID0gYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMpICE9IG51bGwgPyBfaCA6IHN1YnN0YXRlW3JlcXVlc3RJZF0pICE9IG51bGwgPyBfaSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91c1N1YnNjcmlwdGlvbnMpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfcHJvYmVTdWJzY3JpcHRpb24ubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgX2ogPSBhY3Rpb24ucGF5bG9hZCwgcXVlcnlDYWNoZUtleSA9IF9qLnF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCA9IF9qLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgdmFyIGhhc1N1YnNjcmlwdGlvbiA9ICEhKChfYSA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVtyZXF1ZXN0SWRdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgaGFzU3Vic2NyaXB0aW9uXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpZE11dGF0ZSA9IGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyhpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zLCBhY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaWRNdXRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXNwYXRjaFF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2tTaGltKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3Vic2NyaXB0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfaiA9ICgwLCBpbXBvcnRfaW1tZXI0LnByb2R1Y2VXaXRoUGF0Y2hlcykocHJldmlvdXNTdWJzY3JpcHRpb25zLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTdWJzY3JpcHRpb25zOyB9KSwgcGF0Y2hlcyA9IF9qWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG13QXBpLm5leHQoYXBpLmludGVybmFsQWN0aW9ucy5zdWJzY3JpcHRpb25zVXBkYXRlZChwYXRjaGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbmV3U3Vic2NyaXB0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gPSAhISgoX2IgPSBhY3Rpb24udHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoc3Vic2NyaXB0aW9uc1ByZWZpeCkpO1xyXG4gICAgICAgICAgICB2YXIgaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uID0gcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbiAmJiAhIWFjdGlvbi5tZXRhLmFyZy5zdWJzY3JpYmU7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25TaG91bGRDb250aW51ZSA9ICFpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uICYmICFpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb247XHJcbiAgICAgICAgICAgIHJldHVybiBbYWN0aW9uU2hvdWxkQ29udGludWUsIGZhbHNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt0cnVlLCBmYWxzZV07XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvaW5kZXgudHNcclxuZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlKGlucHV0KSB7XHJcbiAgICB2YXIgcmVkdWNlclBhdGggPSBpbnB1dC5yZWR1Y2VyUGF0aCwgcXVlcnlUaHVuayA9IGlucHV0LnF1ZXJ5VGh1bmssIGFwaSA9IGlucHV0LmFwaSwgY29udGV4dCA9IGlucHV0LmNvbnRleHQ7XHJcbiAgICB2YXIgYXBpVWlkID0gY29udGV4dC5hcGlVaWQ7XHJcbiAgICB2YXIgYWN0aW9ucyA9IHtcclxuICAgICAgICBpbnZhbGlkYXRlVGFnczogKDAsIGltcG9ydF90b29sa2l0MTMuY3JlYXRlQWN0aW9uKShyZWR1Y2VyUGF0aCArIFwiL2ludmFsaWRhdGVUYWdzXCIpXHJcbiAgICB9O1xyXG4gICAgdmFyIGlzVGhpc0FwaVNsaWNlQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAhIWFjdGlvbiAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYWN0aW9uLnR5cGUuc3RhcnRzV2l0aChyZWR1Y2VyUGF0aCArIFwiL1wiKTtcclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlckJ1aWxkZXJzID0gW1xyXG4gICAgICAgIGJ1aWxkRGV2Q2hlY2tIYW5kbGVyLFxyXG4gICAgICAgIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlcixcclxuICAgICAgICBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIsXHJcbiAgICAgICAgYnVpbGRQb2xsaW5nSGFuZGxlcixcclxuICAgICAgICBidWlsZENhY2hlTGlmZWN5Y2xlSGFuZGxlcixcclxuICAgICAgICBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlclxyXG4gICAgXTtcclxuICAgIHZhciBtaWRkbGV3YXJlID0gZnVuY3Rpb24gKG13QXBpKSB7XHJcbiAgICAgICAgdmFyIGluaXRpYWxpemVkMiA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpbnRlcm5hbFN0YXRlID0ge1xyXG4gICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBidWlsZGVyQXJncyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGlucHV0KSwge1xyXG4gICAgICAgICAgICBpbnRlcm5hbFN0YXRlOiBpbnRlcm5hbFN0YXRlLFxyXG4gICAgICAgICAgICByZWZldGNoUXVlcnk6IHJlZmV0Y2hRdWVyeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IGhhbmRsZXJCdWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkKSB7IHJldHVybiBidWlsZChidWlsZGVyQXJncyk7IH0pO1xyXG4gICAgICAgIHZhciBiYXRjaGVkQWN0aW9uc0hhbmRsZXIgPSBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlcihidWlsZGVyQXJncyk7XHJcbiAgICAgICAgdmFyIHdpbmRvd0V2ZW50c0hhbmRsZXIgPSBidWlsZFdpbmRvd0V2ZW50SGFuZGxlcihidWlsZGVyQXJncyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxpemVkMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtd0FwaVdpdGhOZXh0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbXdBcGkpLCB7IG5leHQ6IG5leHQgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVCZWZvcmUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9qID0gYmF0Y2hlZEFjdGlvbnNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpLCBhY3Rpb25TaG91bGRDb250aW51ZSA9IF9qWzBdLCBoYXNTdWJzY3JpcHRpb24gPSBfalsxXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uU2hvdWxkQ29udGludWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBoYXNTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoISFtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0V2ZW50c0hhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGhpc0FwaVNsaWNlQWN0aW9uKGFjdGlvbikgfHwgY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2sgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19rXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgbWlkZGxld2FyZTogbWlkZGxld2FyZSwgYWN0aW9uczogYWN0aW9ucyB9O1xyXG4gICAgZnVuY3Rpb24gcmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXksIG92ZXJyaWRlKSB7XHJcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBxdWVyeVRodW5rKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxyXG4gICAgICAgICAgICBlbmRwb2ludE5hbWU6IHF1ZXJ5U3ViU3RhdGUuZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IHF1ZXJ5U3ViU3RhdGUub3JpZ2luYWxBcmdzLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXHJcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHF1ZXJ5Q2FjaGVLZXlcclxuICAgICAgICB9LCBvdmVycmlkZSkpO1xyXG4gICAgfVxyXG59XHJcbi8vIHNyYy9xdWVyeS90c0hlbHBlcnMudHNcclxuZnVuY3Rpb24gYXNzZXJ0Q2FzdCh2KSB7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUFzc2lnbih0YXJnZXQpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaiA9IDE7IF9qIDwgYXJndW1lbnRzLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgIGFyZ3NbX2ogLSAxXSA9IGFyZ3VtZW50c1tfal07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX19zcHJlYWRBcnJheShbdGFyZ2V0XSwgYXJncykpO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL21vZHVsZS50c1xyXG52YXIgaW1wb3J0X2ltbWVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIGNvcmVNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xyXG52YXIgY29yZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICBuYW1lOiBjb3JlTW9kdWxlTmFtZSxcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChhcGksIF9qLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGJhc2VRdWVyeSA9IF9qLmJhc2VRdWVyeSwgdGFnVHlwZXMgPSBfai50YWdUeXBlcywgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aCwgc2VyaWFsaXplUXVlcnlBcmdzID0gX2ouc2VyaWFsaXplUXVlcnlBcmdzLCBrZWVwVW51c2VkRGF0YUZvciA9IF9qLmtlZXBVbnVzZWREYXRhRm9yLCByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlID0gX2oucmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSwgcmVmZXRjaE9uRm9jdXMgPSBfai5yZWZldGNoT25Gb2N1cywgcmVmZXRjaE9uUmVjb25uZWN0ID0gX2oucmVmZXRjaE9uUmVjb25uZWN0O1xyXG4gICAgICAgICgwLCBpbXBvcnRfaW1tZXI1LmVuYWJsZVBhdGNoZXMpKCk7XHJcbiAgICAgICAgYXNzZXJ0Q2FzdChzZXJpYWxpemVRdWVyeUFyZ3MpO1xyXG4gICAgICAgIHZhciBhc3NlcnRUYWdUeXBlID0gZnVuY3Rpb24gKHRhZykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdUeXBlcy5pbmNsdWRlcyh0YWcudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGFnIHR5cGUgJ1wiICsgdGFnLnR5cGUgKyBcIicgd2FzIHVzZWQsIGJ1dCBub3Qgc3BlY2lmaWVkIGluIGB0YWdUeXBlc2AhXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YWc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGgsXHJcbiAgICAgICAgICAgIGVuZHBvaW50czoge30sXHJcbiAgICAgICAgICAgIGludGVybmFsQWN0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgb25PbmxpbmU6IG9uT25saW5lLFxyXG4gICAgICAgICAgICAgICAgb25PZmZsaW5lOiBvbk9mZmxpbmUsXHJcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBvbkZvY3VzLFxyXG4gICAgICAgICAgICAgICAgb25Gb2N1c0xvc3Q6IG9uRm9jdXNMb3N0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHV0aWw6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIF9rID0gYnVpbGRUaHVua3Moe1xyXG4gICAgICAgICAgICBiYXNlUXVlcnk6IGJhc2VRdWVyeSxcclxuICAgICAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICBhcGk6IGFwaSxcclxuICAgICAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiBzZXJpYWxpemVRdWVyeUFyZ3MsXHJcbiAgICAgICAgICAgIGFzc2VydFRhZ1R5cGU6IGFzc2VydFRhZ1R5cGVcclxuICAgICAgICB9KSwgcXVlcnlUaHVuayA9IF9rLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfay5tdXRhdGlvblRodW5rLCBwYXRjaFF1ZXJ5RGF0YSA9IF9rLnBhdGNoUXVlcnlEYXRhLCB1cGRhdGVRdWVyeURhdGEgPSBfay51cGRhdGVRdWVyeURhdGEsIHVwc2VydFF1ZXJ5RGF0YSA9IF9rLnVwc2VydFF1ZXJ5RGF0YSwgcHJlZmV0Y2ggPSBfay5wcmVmZXRjaCwgYnVpbGRNYXRjaFRodW5rQWN0aW9ucyA9IF9rLmJ1aWxkTWF0Y2hUaHVua0FjdGlvbnM7XHJcbiAgICAgICAgdmFyIF9sID0gYnVpbGRTbGljZSh7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIHF1ZXJ5VGh1bms6IHF1ZXJ5VGh1bmssXHJcbiAgICAgICAgICAgIG11dGF0aW9uVGh1bms6IG11dGF0aW9uVGh1bmssXHJcbiAgICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aCxcclxuICAgICAgICAgICAgYXNzZXJ0VGFnVHlwZTogYXNzZXJ0VGFnVHlwZSxcclxuICAgICAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25Gb2N1czogcmVmZXRjaE9uRm9jdXMsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IHJlZmV0Y2hPblJlY29ubmVjdCxcclxuICAgICAgICAgICAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U6IHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBrZWVwVW51c2VkRGF0YUZvcjoga2VlcFVudXNlZERhdGFGb3IsXHJcbiAgICAgICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCByZWR1Y2VyID0gX2wucmVkdWNlciwgc2xpY2VBY3Rpb25zID0gX2wuYWN0aW9ucztcclxuICAgICAgICBzYWZlQXNzaWduKGFwaS51dGlsLCB7XHJcbiAgICAgICAgICAgIHBhdGNoUXVlcnlEYXRhOiBwYXRjaFF1ZXJ5RGF0YSxcclxuICAgICAgICAgICAgdXBkYXRlUXVlcnlEYXRhOiB1cGRhdGVRdWVyeURhdGEsXHJcbiAgICAgICAgICAgIHVwc2VydFF1ZXJ5RGF0YTogdXBzZXJ0UXVlcnlEYXRhLFxyXG4gICAgICAgICAgICBwcmVmZXRjaDogcHJlZmV0Y2gsXHJcbiAgICAgICAgICAgIHJlc2V0QXBpU3RhdGU6IHNsaWNlQWN0aW9ucy5yZXNldEFwaVN0YXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGkuaW50ZXJuYWxBY3Rpb25zLCBzbGljZUFjdGlvbnMpO1xyXG4gICAgICAgIHZhciBfbSA9IGJ1aWxkTWlkZGxld2FyZSh7XHJcbiAgICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aCxcclxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgcXVlcnlUaHVuazogcXVlcnlUaHVuayxcclxuICAgICAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICAgICAgYXBpOiBhcGksXHJcbiAgICAgICAgICAgIGFzc2VydFRhZ1R5cGU6IGFzc2VydFRhZ1R5cGVcclxuICAgICAgICB9KSwgbWlkZGxld2FyZSA9IF9tLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmVBY3Rpb25zID0gX20uYWN0aW9ucztcclxuICAgICAgICBzYWZlQXNzaWduKGFwaS51dGlsLCBtaWRkbGV3YXJlQWN0aW9ucyk7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGksIHsgcmVkdWNlcjogcmVkdWNlciwgbWlkZGxld2FyZTogbWlkZGxld2FyZSB9KTtcclxuICAgICAgICB2YXIgX28gPSBidWlsZFNlbGVjdG9ycyh7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogc2VyaWFsaXplUXVlcnlBcmdzLFxyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGhcclxuICAgICAgICB9KSwgYnVpbGRRdWVyeVNlbGVjdG9yID0gX28uYnVpbGRRdWVyeVNlbGVjdG9yLCBidWlsZE11dGF0aW9uU2VsZWN0b3IgPSBfby5idWlsZE11dGF0aW9uU2VsZWN0b3IsIHNlbGVjdEludmFsaWRhdGVkQnkgPSBfby5zZWxlY3RJbnZhbGlkYXRlZEJ5O1xyXG4gICAgICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHsgc2VsZWN0SW52YWxpZGF0ZWRCeTogc2VsZWN0SW52YWxpZGF0ZWRCeSB9KTtcclxuICAgICAgICB2YXIgX3AgPSBidWlsZEluaXRpYXRlKHtcclxuICAgICAgICAgICAgcXVlcnlUaHVuazogcXVlcnlUaHVuayxcclxuICAgICAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICAgICAgYXBpOiBhcGksXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogc2VyaWFsaXplUXVlcnlBcmdzLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgfSksIGJ1aWxkSW5pdGlhdGVRdWVyeSA9IF9wLmJ1aWxkSW5pdGlhdGVRdWVyeSwgYnVpbGRJbml0aWF0ZU11dGF0aW9uID0gX3AuYnVpbGRJbml0aWF0ZU11dGF0aW9uLCBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayA9IF9wLmdldFJ1bm5pbmdNdXRhdGlvblRodW5rLCBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsgPSBfcC5nZXRSdW5uaW5nTXV0YXRpb25zVGh1bmssIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsgPSBfcC5nZXRSdW5uaW5nUXVlcmllc1RodW5rLCBnZXRSdW5uaW5nUXVlcnlUaHVuayA9IF9wLmdldFJ1bm5pbmdRdWVyeVRodW5rLCBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMgPSBfcC5nZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMsIHJlbW92YWxXYXJuaW5nID0gX3AucmVtb3ZhbFdhcm5pbmc7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xyXG4gICAgICAgICAgICBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXM6IGdldFJ1bm5pbmdPcGVyYXRpb25Qcm9taXNlcyxcclxuICAgICAgICAgICAgZ2V0UnVubmluZ09wZXJhdGlvblByb21pc2U6IHJlbW92YWxXYXJuaW5nLFxyXG4gICAgICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuazogZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXHJcbiAgICAgICAgICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuazogZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxyXG4gICAgICAgICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuazogZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXHJcbiAgICAgICAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bms6IGdldFJ1bm5pbmdRdWVyaWVzVGh1bmtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiBjb3JlTW9kdWxlTmFtZSxcclxuICAgICAgICAgICAgaW5qZWN0RW5kcG9pbnQ6IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW55QXBpID0gYXBpO1xyXG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gYW55QXBpLmVuZHBvaW50cylbZW5kcG9pbnROYW1lXSkgIT0gbnVsbCA/IF9iIDogX2FbZW5kcG9pbnROYW1lXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNdXRhdGlvbkRlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlOiBidWlsZEluaXRpYXRlTXV0YXRpb24oZW5kcG9pbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMobXV0YXRpb25UaHVuaywgZW5kcG9pbnROYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59KTsgfTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvaW5kZXgudHNcclxudmFyIGNyZWF0ZUFwaSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydGstcXVlcnkuY2pzLmRldmVsb3BtZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2dlbmVyYXRvciIsInRoaXNBcmciLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwibmV4dCIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwic3RlcCIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsImRvbmUiLCJ2YWx1ZSIsInBvcCIsImxlbmd0aCIsInB1c2giLCJlIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsImkiLCJpbCIsImoiLCJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZQcm9wcyIsImRlZmluZVByb3BlcnRpZXMiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wRGVzY3MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRPd25Qcm9wU3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsImIiLCJwcm9wIiwiX2oiLCJfayIsIl9fc3ByZWFkUHJvcHMiLCJfX21hcmtBc01vZHVsZSIsInRhcmdldCIsIl9fb2JqUmVzdCIsInNvdXJjZSIsImV4Y2x1ZGUiLCJpbmRleE9mIiwiX19leHBvcnQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiX19yZUV4cG9ydCIsIm1vZHVsZTIiLCJkZXNjIiwiX2xvb3BfMSIsIl9fdG9Nb2R1bGUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwiUXVlcnlTdGF0dXMiLCJidWlsZENyZWF0ZUFwaSIsImNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmciLCJjb3JlTW9kdWxlIiwiY29yZU1vZHVsZU5hbWUiLCJjcmVhdGVBcGkiLCJkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIiwiZmFrZUJhc2VRdWVyeSIsImZldGNoQmFzZVF1ZXJ5IiwicmV0cnkiLCJzZXR1cExpc3RlbmVycyIsInNraXBTZWxlY3RvciIsInNraXBUb2tlbiIsIlF1ZXJ5U3RhdHVzMiIsImdldFJlcXVlc3RTdGF0dXNGbGFncyIsInN0YXR1cyIsImlzVW5pbml0aWFsaXplZCIsInVuaW5pdGlhbGl6ZWQiLCJpc0xvYWRpbmciLCJwZW5kaW5nIiwiaXNTdWNjZXNzIiwiaXNFcnJvciIsImlzQWJzb2x1dGVVcmwiLCJ1cmwiLCJSZWdFeHAiLCJ0ZXN0Iiwid2l0aG91dFRyYWlsaW5nU2xhc2giLCJyZXBsYWNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsImpvaW5VcmxzIiwiYmFzZSIsImRlbGltaXRlciIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsImZsYXR0ZW4iLCJhcnIiLCJjb25jYXQiLCJpc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzRG9jdW1lbnRWaXNpYmxlIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJpbXBvcnRfdG9vbGtpdCIsInJlcXVpcmUiLCJpc1BsYWluT2JqZWN0Iiwib2xkT2JqIiwibmV3T2JqIiwiQXJyYXkiLCJpc0FycmF5IiwibmV3S2V5cyIsImtleXMiLCJvbGRLZXlzIiwiaXNTYW1lT2JqZWN0IiwibWVyZ2VPYmoiLCJuZXdLZXlzXzEiLCJpbXBvcnRfdG9vbGtpdDIiLCJkZWZhdWx0RmV0Y2hGbiIsImFyZ3MiLCJhcmd1bWVudHMiLCJmZXRjaCIsImRlZmF1bHRWYWxpZGF0ZVN0YXR1cyIsInJlc3BvbnNlIiwiZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlIiwiaGVhZGVycyIsInN0cmlwVW5kZWZpbmVkIiwiY29weSIsImVudHJpZXMiLCJfbCIsImsiLCJfYSIsIl90aGlzIiwiX2IiLCJiYXNlVXJsIiwicHJlcGFyZUhlYWRlcnMiLCJmZXRjaEZuIiwicGFyYW1zU2VyaWFsaXplciIsImlzSnNvbkNvbnRlbnRUeXBlIiwiX20iLCJqc29uQ29udGVudFR5cGUiLCJqc29uUmVwbGFjZXIiLCJkZWZhdWx0VGltZW91dCIsInRpbWVvdXQiLCJnbG9iYWxSZXNwb25zZUhhbmRsZXIiLCJyZXNwb25zZUhhbmRsZXIiLCJnbG9iYWxWYWxpZGF0ZVN0YXR1cyIsInZhbGlkYXRlU3RhdHVzIiwiYmFzZUZldGNoT3B0aW9ucyIsImNvbnNvbGUiLCJ3YXJuIiwiYXJnIiwiYXBpIiwic2lnbmFsIiwiZ2V0U3RhdGUiLCJleHRyYSIsImVuZHBvaW50IiwiZm9yY2VkIiwidHlwZSIsIm1ldGEiLCJfYTIiLCJwYXJhbXMiLCJfbyIsInJlc3QiLCJjb25maWciLCJfcCIsImlzSnNvbmlmaWFibGUiLCJkaXZpZGVyIiwicXVlcnkiLCJyZXF1ZXN0IiwicmVxdWVzdENsb25lIiwidGltZWRPdXQiLCJ0aW1lb3V0SWQiLCJlXzEiLCJyZXNwb25zZUNsb25lIiwicmVzdWx0RGF0YSIsInJlc3BvbnNlVGV4dCIsImhhbmRsZVJlc3BvbnNlRXJyb3JfMSIsImVfMiIsIl9xIiwiSGVhZGVycyIsInRvSlNPTiIsImhhcyIsInNldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJSZXF1ZXN0Iiwic2V0VGltZW91dCIsImFib3J0IiwiZXJyb3IiLCJTdHJpbmciLCJjbGVhclRpbWVvdXQiLCJjbG9uZSIsImhhbmRsZVJlc3BvbnNlIiwiciIsInRleHQiLCJvcmlnaW5hbFN0YXR1cyIsImRhdGEiLCJwYXJzZSIsIkhhbmRsZWRFcnJvciIsImRlZmF1bHRCYWNrb2ZmIiwiYXR0ZW1wdCIsIm1heFJldHJpZXMiLCJhdHRlbXB0cyIsIk1hdGgiLCJtaW4iLCJyYW5kb20iLCJyZXMiLCJmYWlsIiwiYXNzaWduIiwidGhyb3dJbW1lZGlhdGVseSIsIkVNUFRZX09QVElPTlMiLCJyZXRyeVdpdGhCYWNrb2ZmIiwiYmFzZVF1ZXJ5IiwiZGVmYXVsdE9wdGlvbnMiLCJleHRyYU9wdGlvbnMiLCJwb3NzaWJsZU1heFJldHJpZXMiLCJkZWZhdWx0UmV0cnlDb25kaXRpb24iLCJvcHRpb25zIiwicmV0cnkyIiwicmVzdWx0IiwiZV8zIiwiZmlsdGVyIiwic2xpY2UiLCJfXyIsImJhY2tvZmYiLCJyZXRyeUNvbmRpdGlvbiIsImJhc2VRdWVyeUFwaSIsImltcG9ydF90b29sa2l0MyIsIm9uRm9jdXMiLCJjcmVhdGVBY3Rpb24iLCJvbkZvY3VzTG9zdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwiaW5pdGlhbGl6ZWQiLCJkaXNwYXRjaCIsImN1c3RvbUhhbmRsZXIiLCJkZWZhdWx0SGFuZGxlciIsImhhbmRsZUZvY3VzIiwiaGFuZGxlRm9jdXNMb3N0IiwiaGFuZGxlT25saW5lIiwiaGFuZGxlT2ZmbGluZSIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW1wb3J0X3Rvb2xraXQ3IiwiRGVmaW5pdGlvblR5cGUiLCJEZWZpbml0aW9uVHlwZTIiLCJpc1F1ZXJ5RGVmaW5pdGlvbiIsImlzTXV0YXRpb25EZWZpbml0aW9uIiwibXV0YXRpb24iLCJjYWxjdWxhdGVQcm92aWRlZEJ5IiwiZGVzY3JpcHRpb24iLCJxdWVyeUFyZyIsImFzc2VydFRhZ1R5cGVzIiwiaXNGdW5jdGlvbiIsIm1hcCIsImV4cGFuZFRhZ0Rlc2NyaXB0aW9uIiwiaW1wb3J0X3Rvb2xraXQ2IiwiaXNOb3ROdWxsaXNoIiwiZm9yY2VRdWVyeUZuU3ltYm9sIiwiaXNVcHNlcnRRdWVyeSIsImJ1aWxkSW5pdGlhdGUiLCJzZXJpYWxpemVRdWVyeUFyZ3MiLCJxdWVyeVRodW5rIiwibXV0YXRpb25UaHVuayIsImNvbnRleHQiLCJydW5uaW5nUXVlcmllcyIsIk1hcCIsInJ1bm5pbmdNdXRhdGlvbnMiLCJpbnRlcm5hbEFjdGlvbnMiLCJ1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0IiwicmVtb3ZlTXV0YXRpb25SZXN1bHQiLCJ1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zIiwiYnVpbGRJbml0aWF0ZVF1ZXJ5IiwiYnVpbGRJbml0aWF0ZU11dGF0aW9uIiwiZ2V0UnVubmluZ1F1ZXJ5VGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25UaHVuayIsImdldFJ1bm5pbmdRdWVyaWVzVGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsiLCJnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMiLCJyZW1vdmFsV2FybmluZyIsIkVycm9yIiwicHJvY2VzcyIsImV4dHJhY3QiLCJ2YWx1ZXMiLCJmbGF0TWFwIiwicXVlcmllc0ZvclN0b3JlIiwiZW5kcG9pbnROYW1lIiwicXVlcnlBcmdzIiwiZW5kcG9pbnREZWZpbml0aW9uIiwiZW5kcG9pbnREZWZpbml0aW9ucyIsInF1ZXJ5Q2FjaGVLZXkiLCJfZW5kcG9pbnROYW1lIiwiZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkIiwibWlkZGxld2FyZVdhcm5pbmciLCJ0cmlnZ2VyZWQiLCJyZWdpc3RlcmVkIiwiaW50ZXJuYWxfcHJvYmVTdWJzY3JpcHRpb24iLCJyZXF1ZXN0SWQiLCJyZWR1Y2VyUGF0aCIsInF1ZXJ5QWN0aW9uIiwic3Vic2NyaWJlIiwiZm9yY2VSZWZldGNoIiwic3Vic2NyaXB0aW9uT3B0aW9ucyIsImZvcmNlUXVlcnlGbiIsInRodW5rIiwib3JpZ2luYWxBcmdzIiwic2VsZWN0b3IiLCJlbmRwb2ludHMiLCJzZWxlY3QiLCJ0aHVua1Jlc3VsdCIsInN0YXRlQWZ0ZXIiLCJza2lwcGVkU3luY2hyb25vdXNseSIsInJ1bm5pbmdRdWVyeSIsInNlbGVjdEZyb21TdGF0ZSIsInN0YXRlUHJvbWlzZSIsInVud3JhcCIsInJlZmV0Y2giLCJydW5uaW5nXzEiLCJkZWxldGUiLCJ0cmFjayIsImZpeGVkQ2FjaGVLZXkiLCJyZXR1cm5WYWx1ZVByb21pc2UiLCJjYXRjaCIsInJlc2V0IiwicmV0IiwicnVubmluZyIsImltcG9ydF90b29sa2l0NCIsImltcG9ydF9pbW1lciIsImltcG9ydF90b29sa2l0NSIsImRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZSIsImJhc2VRdWVyeVJldHVyblZhbHVlIiwiYnVpbGRUaHVua3MiLCJhc3NlcnRUYWdUeXBlIiwicGF0Y2hRdWVyeURhdGEiLCJwYXRjaGVzIiwidXBkYXRlUHJvdmlkZWQiLCJxdWVyeVJlc3VsdFBhdGNoZWQiLCJuZXdWYWx1ZSIsInByb3ZpZGVkVGFncyIsInByb3ZpZGVzVGFncyIsInVwZGF0ZVByb3ZpZGVkQnkiLCJ1cGRhdGVRdWVyeURhdGEiLCJ1cGRhdGVSZWNpcGUiLCJjdXJyZW50U3RhdGUiLCJpbnZlcnNlUGF0Y2hlcyIsInVuZG8iLCJ1dGlsIiwiaXNEcmFmdGFibGUiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJwYXRoIiwidXBzZXJ0UXVlcnlEYXRhIiwiaW5pdGlhdGUiLCJleGVjdXRlRW5kcG9pbnQiLCJfMCIsIl8xIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJiYXNlUXVlcnlBcGlfMSIsIndoYXQiLCJlcnIiLCJlcnJvcl8xIiwiY2F0Y2hlZEVycm9yIiwidHJhbnNmb3JtRXJyb3JSZXNwb25zZSIsImVfNCIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJfciIsImlzRm9yY2VkUXVlcnkiLCJxdWVyeUZuIiwiYXJnMiIsImZ1bGZpbGxlZFRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJiYXNlUXVlcnlNZXRhIiwiU0hPVUxEX0FVVE9CQVRDSCIsInN0YXRlIiwiX2MiLCJfZCIsInJlcXVlc3RTdGF0ZSIsInF1ZXJpZXMiLCJiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJyZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlIiwiZnVsZmlsbGVkVmFsIiwicmVmZXRjaFZhbCIsIk51bWJlciIsImNyZWF0ZUFzeW5jVGh1bmsiLCJnZXRQZW5kaW5nTWV0YSIsInN0YXJ0ZWRUaW1lU3RhbXAiLCJjb25kaXRpb24iLCJxdWVyeVRodW5rQXJncyIsImN1cnJlbnRBcmciLCJwcmV2aW91c0FyZyIsImVuZHBvaW50U3RhdGUiLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsImhhc1RoZUZvcmNlIiwiaGFzTWF4QWdlIiwicHJlZmV0Y2giLCJmb3JjZSIsIm1heEFnZSIsImlmT2xkZXJUaGFuIiwiZm9yY2UyIiwibGF0ZXN0U3RhdGVWYWx1ZSIsImxhc3RGdWxmaWxsZWRUcyIsInNob3VsZFJldHJpZ2dlciIsIm1hdGNoZXNFbmRwb2ludCIsImFjdGlvbiIsImJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMiLCJtYXRjaFBlbmRpbmciLCJpc0FsbE9mIiwiaXNQZW5kaW5nIiwibWF0Y2hGdWxmaWxsZWQiLCJpc0Z1bGZpbGxlZCIsIm1hdGNoUmVqZWN0ZWQiLCJpc1JlamVjdGVkIiwiY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rIiwicGF5bG9hZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJpbXBvcnRfaW1tZXIyIiwiaW1wb3J0X2ltbWVyMyIsInVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyIsInVwZGF0ZSIsInN1YnN0YXRlIiwiZ2V0TXV0YXRpb25DYWNoZUtleSIsImlkIiwidXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzIiwiaW5pdGlhbFN0YXRlIiwiYnVpbGRTbGljZSIsImRlZmluaXRpb25zIiwiYXBpVWlkIiwiZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyIsImhhc1JlaHlkcmF0aW9uSW5mbyIsInJlc2V0QXBpU3RhdGUiLCJxdWVyeVNsaWNlIiwiY3JlYXRlU2xpY2UiLCJyZWR1Y2VycyIsInJlbW92ZVF1ZXJ5UmVzdWx0IiwicmVkdWNlciIsImRyYWZ0IiwicHJlcGFyZSIsInByZXBhcmVBdXRvQmF0Y2hlZCIsImFwcGx5UGF0Y2hlcyIsImV4dHJhUmVkdWNlcnMiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInVwc2VydGluZyIsIm1lcmdlIiwiZnVsZmlsbGVkVGltZVN0YW1wXzEiLCJhcmdfMSIsImJhc2VRdWVyeU1ldGFfMSIsInJlcXVlc3RJZF8xIiwibmV3RGF0YSIsImNyZWF0ZU5leHRTdGF0ZSIsImRyYWZ0U3Vic3RhdGVEYXRhIiwic3RydWN0dXJhbFNoYXJpbmciLCJpc0RyYWZ0Iiwib3JpZ2luYWwiLCJhZGRNYXRjaGVyIiwiZW50cnkiLCJtdXRhdGlvblNsaWNlIiwiY2FjaGVLZXkiLCJtdXRhdGlvbnMiLCJpbnZhbGlkYXRpb25TbGljZSIsInRhZ1R5cGVTdWJzY3JpcHRpb25zIiwiaWRTdWJzY3JpcHRpb25zIiwiZm91bmRBdCIsInNwbGljZSIsInByb3ZpZGVkVGFnc18xIiwic3Vic2NyaWJlZFF1ZXJpZXMiLCJhbHJlYWR5U3Vic2NyaWJlZCIsImluY2x1ZGVzIiwiYWN0aW9ucyIsInByb3ZpZGVkIiwiaW5jb21pbmdUYWdzIiwiY2FjaGVLZXlzIiwiY2FjaGVLZXlzXzEiLCJpc0FueU9mIiwiY2FzZVJlZHVjZXJzIiwic3Vic2NyaXB0aW9uU2xpY2UiLCJkIiwiaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UiLCJzdWJzY3JpcHRpb25zVXBkYXRlZCIsImNvbmZpZ1NsaWNlIiwib25saW5lIiwiZm9jdXNlZCIsIm1pZGRsZXdhcmVSZWdpc3RlcmVkIiwiY29tYmluZWRSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwic3Vic2NyaXB0aW9ucyIsIm1hdGNoIiwidW5zdWJzY3JpYmVNdXRhdGlvblJlc3VsdCIsImZvciIsImluaXRpYWxTdWJTdGF0ZSIsImRlZmF1bHRRdWVyeVN1YlN0YXRlIiwiZGVmYXVsdE11dGF0aW9uU3ViU3RhdGUiLCJidWlsZFNlbGVjdG9ycyIsInNlbGVjdFNraXBwZWRRdWVyeSIsInNlbGVjdFNraXBwZWRNdXRhdGlvbiIsImJ1aWxkUXVlcnlTZWxlY3RvciIsImJ1aWxkTXV0YXRpb25TZWxlY3RvciIsInNlbGVjdEludmFsaWRhdGVkQnkiLCJ3aXRoUmVxdWVzdEZsYWdzIiwic2VsZWN0SW50ZXJuYWxTdGF0ZSIsInJvb3RTdGF0ZSIsInNlcmlhbGl6ZWRBcmdzIiwic2VsZWN0UXVlcnlTdWJzdGF0ZSIsImZpbmFsU2VsZWN0UXVlcnlTdWJTdGF0ZSIsImNyZWF0ZVNlbGVjdG9yIiwibXV0YXRpb25JZCIsInNlbGVjdE11dGF0aW9uU3Vic3RhdGUiLCJmaW5hbFNlbGVjdE11dGF0aW9uU3Vic3RhdGUiLCJ0YWdzIiwiYXBpU3RhdGUiLCJ0b0ludmFsaWRhdGUiLCJTZXQiLCJ0YWciLCJpbnZhbGlkYXRlU3Vic2NyaXB0aW9ucyIsImludmFsaWRhdGVTdWJzY3JpcHRpb25zXzEiLCJpbnZhbGlkYXRlIiwiYWRkIiwicXVlcnlTdWJTdGF0ZSIsImltcG9ydF90b29sa2l0OCIsImNhY2hlIiwiV2Vha01hcCIsInNlcmlhbGl6ZWQiLCJjYWNoZWQiLCJzdHJpbmdpZmllZCIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJrZXkyIiwiaW1wb3J0X3Rvb2xraXQ5IiwiaW1wb3J0X3Jlc2VsZWN0IiwibW9kdWxlcyIsImJhc2VDcmVhdGVBcGkiLCJkZWZhdWx0TWVtb2l6ZSIsIm9wdGlvbnNXaXRoRGVmYXVsdHMiLCJrZWVwVW51c2VkRGF0YUZvciIsInJlZmV0Y2hPbkZvY3VzIiwicmVmZXRjaE9uUmVjb25uZWN0IiwicXVlcnlBcmdzQXBpIiwiZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MiLCJlbmRwb2ludFNRQV8xIiwicXVlcnlBcmdzQXBpMiIsImluaXRpYWxSZXN1bHQiLCJ0YWdUeXBlcyIsImJhdGNoIiwiZm4iLCJuYW5vaWQiLCJpbmplY3RFbmRwb2ludHMiLCJlbmhhbmNlRW5kcG9pbnRzIiwiYWRkVGFnVHlwZXMiLCJhZGRUYWdUeXBlc18xIiwiZVQiLCJwYXJ0aWFsRGVmaW5pdGlvbiIsImluaXRpYWxpemVkTW9kdWxlcyIsIm0iLCJpbml0IiwiaW5qZWN0IiwiZXZhbHVhdGVkRW5kcG9pbnRzIiwiZGVmaW5pdGlvbiIsIm92ZXJyaWRlRXhpc3RpbmciLCJpbml0aWFsaXplZE1vZHVsZXNfMSIsImluamVjdEVuZHBvaW50IiwiaW1wb3J0X3Rvb2xraXQxMyIsImlzT2JqZWN0RW1wdHkiLCJUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyIsImJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciIsImludGVybmFsU3RhdGUiLCJhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5IiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJjdXJyZW50UmVtb3ZhbFRpbWVvdXRzIiwiaGFuZGxlciIsIm13QXBpIiwiaW50ZXJuYWxTdGF0ZTIiLCJoYW5kbGVVbnN1YnNjcmliZSIsInF1ZXJ5U3RhdGUiLCJhcGkyIiwiSW5maW5pdHkiLCJmaW5hbEtlZXBVbnVzZWREYXRhRm9yIiwibWF4IiwiY3VycmVudFRpbWVvdXQiLCJpbXBvcnRfdG9vbGtpdDEwIiwiYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyIiwicmVmZXRjaFF1ZXJ5IiwiaXNUaHVua0FjdGlvbldpdGhUYWdzIiwiaW52YWxpZGF0ZVRhZ3MiLCJ2YWx1ZXNBcnJheSIsInZhbHVlc0FycmF5XzEiLCJzdWJzY3JpcHRpb25TdWJTdGF0ZSIsImJ1aWxkUG9sbGluZ0hhbmRsZXIiLCJjdXJyZW50UG9sbHMiLCJ1cGRhdGVQb2xsaW5nSW50ZXJ2YWwiLCJzdGFydE5leHRQb2xsIiwiY2xlYXJQb2xscyIsImxvd2VzdFBvbGxpbmdJbnRlcnZhbCIsImZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwiLCJpc0Zpbml0ZSIsImN1cnJlbnRQb2xsIiwibmV4dFBvbGxUaW1lc3RhbXAiLCJjdXJyZW50SW50ZXJ2YWwiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjbGVhbnVwUG9sbEZvcktleSIsImV4aXN0aW5nUG9sbCIsInN1YnNjcmliZXJzIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJidWlsZFdpbmRvd0V2ZW50SGFuZGxlciIsInJlZmV0Y2hWYWxpZFF1ZXJpZXMiLCJzaG91bGRSZWZldGNoIiwic29tZSIsInN1YiIsImV2ZXJ5IiwiaW1wb3J0X3Rvb2xraXQxMSIsIm5ldmVyUmVzb2x2ZWRFcnJvciIsImJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyIiwiaXNRdWVyeVRodW5rIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiaXNNdXRhdGlvblRodW5rIiwiaXNGdWxmaWxsZWRUaHVuayIsImxpZmVjeWNsZU1hcCIsInN0YXRlQmVmb3JlIiwiZ2V0Q2FjaGVLZXkiLCJvbGRTdGF0ZSIsImhhbmRsZU5ld0tleSIsImxpZmVjeWNsZSIsInZhbHVlUmVzb2x2ZWQiLCJjYWNoZUVudHJ5UmVtb3ZlZCIsImNhY2hlS2V5MiIsIm9uQ2FjaGVFbnRyeUFkZGVkIiwiY2FjaGVEYXRhTG9hZGVkIiwicmFjZSIsImV4dHJhMiIsImxpZmVjeWNsZUFwaSIsImdldENhY2hlRW50cnkiLCJ1cGRhdGVDYWNoZWREYXRhIiwicnVubmluZ0hhbmRsZXIiLCJpbXBvcnRfdG9vbGtpdDEyIiwiYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXIiLCJpc1BlbmRpbmdUaHVuayIsImlzUmVqZWN0ZWRUaHVuayIsImlzRnVsbGZpbGxlZFRodW5rIiwiZW5kcG9pbnROYW1lXzEiLCJvcmlnaW5hbEFyZ3NfMSIsIm9uUXVlcnlTdGFydGVkIiwibGlmZWN5Y2xlXzEiLCJxdWVyeUZ1bGZpbGxlZCIsInNlbGVjdG9yXzEiLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzVW5oYW5kbGVkRXJyb3IiLCJidWlsZERldkNoZWNrSGFuZGxlciIsImltcG9ydF9pbW1lcjQiLCJwcm9taXNlIiwicXVldWVNaWNyb3Rhc2tTaGltIiwicXVldWVNaWNyb3Rhc2siLCJiaW5kIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiYnVpbGRCYXRjaGVkQWN0aW9uc0hhbmRsZXIiLCJzdWJzY3JpcHRpb25zUHJlZml4IiwicHJldmlvdXNTdWJzY3JpcHRpb25zIiwiZGlzcGF0Y2hRdWV1ZWQiLCJhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMiLCJtdXRhYmxlU3RhdGUiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9pIiwiaGFzU3Vic2NyaXB0aW9uIiwiZGlkTXV0YXRlIiwibmV3U3Vic2NyaXB0aW9ucyIsImlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24iLCJpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb24iLCJhY3Rpb25TaG91bGRDb250aW51ZSIsImJ1aWxkTWlkZGxld2FyZSIsImlucHV0IiwiaXNUaGlzQXBpU2xpY2VBY3Rpb24iLCJoYW5kbGVyQnVpbGRlcnMiLCJtaWRkbGV3YXJlIiwiaW5pdGlhbGl6ZWQyIiwiYnVpbGRlckFyZ3MiLCJoYW5kbGVycyIsImJ1aWxkIiwiYmF0Y2hlZEFjdGlvbnNIYW5kbGVyIiwid2luZG93RXZlbnRzSGFuZGxlciIsIm13QXBpV2l0aE5leHQiLCJoYW5kbGVyc18xIiwib3ZlcnJpZGUiLCJhc3NlcnRDYXN0Iiwic2FmZUFzc2lnbiIsImltcG9ydF9pbW1lcjUiLCJlbmFibGVQYXRjaGVzIiwic2xpY2VBY3Rpb25zIiwibWlkZGxld2FyZUFjdGlvbnMiLCJnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZSIsImFueUFwaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancerArray: function() { return /* binding */ EnhancerArray; },\n/* harmony export */   MiddlewareArray: function() { return /* binding */ MiddlewareArray; },\n/* harmony export */   SHOULD_AUTOBATCH: function() { return /* binding */ SHOULD_AUTOBATCH; },\n/* harmony export */   TaskAbortError: function() { return /* binding */ TaskAbortError; },\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes; },\n/* harmony export */   addListener: function() { return /* binding */ addListener; },\n/* harmony export */   applyMiddleware: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware; },\n/* harmony export */   autoBatchEnhancer: function() { return /* binding */ autoBatchEnhancer; },\n/* harmony export */   bindActionCreators: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators; },\n/* harmony export */   clearAllListeners: function() { return /* binding */ clearAllListeners; },\n/* harmony export */   combineReducers: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers; },\n/* harmony export */   compose: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose; },\n/* harmony export */   configureStore: function() { return /* binding */ configureStore; },\n/* harmony export */   createAction: function() { return /* binding */ createAction; },\n/* harmony export */   createActionCreatorInvariantMiddleware: function() { return /* binding */ createActionCreatorInvariantMiddleware; },\n/* harmony export */   createAsyncThunk: function() { return /* binding */ createAsyncThunk; },\n/* harmony export */   createDraftSafeSelector: function() { return /* binding */ createDraftSafeSelector; },\n/* harmony export */   createEntityAdapter: function() { return /* binding */ createEntityAdapter; },\n/* harmony export */   createImmutableStateInvariantMiddleware: function() { return /* binding */ createImmutableStateInvariantMiddleware; },\n/* harmony export */   createListenerMiddleware: function() { return /* binding */ createListenerMiddleware; },\n/* harmony export */   createNextState: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   createReducer: function() { return /* binding */ createReducer; },\n/* harmony export */   createSelector: function() { return /* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector; },\n/* harmony export */   createSerializableStateInvariantMiddleware: function() { return /* binding */ createSerializableStateInvariantMiddleware; },\n/* harmony export */   createSlice: function() { return /* binding */ createSlice; },\n/* harmony export */   createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore; },\n/* harmony export */   current: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current; },\n/* harmony export */   findNonSerializableValue: function() { return /* binding */ findNonSerializableValue; },\n/* harmony export */   freeze: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze; },\n/* harmony export */   getDefaultMiddleware: function() { return /* binding */ getDefaultMiddleware; },\n/* harmony export */   getType: function() { return /* binding */ getType; },\n/* harmony export */   isAction: function() { return /* binding */ isAction; },\n/* harmony export */   isActionCreator: function() { return /* binding */ isActionCreator; },\n/* harmony export */   isAllOf: function() { return /* binding */ isAllOf; },\n/* harmony export */   isAnyOf: function() { return /* binding */ isAnyOf; },\n/* harmony export */   isAsyncThunkAction: function() { return /* binding */ isAsyncThunkAction; },\n/* harmony export */   isDraft: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft; },\n/* harmony export */   isFluxStandardAction: function() { return /* binding */ isFSA; },\n/* harmony export */   isFulfilled: function() { return /* binding */ isFulfilled; },\n/* harmony export */   isImmutableDefault: function() { return /* binding */ isImmutableDefault; },\n/* harmony export */   isPending: function() { return /* binding */ isPending; },\n/* harmony export */   isPlain: function() { return /* binding */ isPlain; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isRejected: function() { return /* binding */ isRejected; },\n/* harmony export */   isRejectedWithValue: function() { return /* binding */ isRejectedWithValue; },\n/* harmony export */   legacy_createStore: function() { return /* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore; },\n/* harmony export */   miniSerializeError: function() { return /* binding */ miniSerializeError; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; },\n/* harmony export */   original: function() { return /* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original; },\n/* harmony export */   prepareAutoBatched: function() { return /* binding */ prepareAutoBatched; },\n/* harmony export */   removeListener: function() { return /* binding */ removeListener; },\n/* harmony export */   unwrapResult: function() { return /* binding */ unwrapResult; }\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(app-pages-browser)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(app-pages-browser)/./node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(app-pages-browser)/./node_modules/redux-thunk/es/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  true && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  true && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return isAction(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    var splitType = type ? (\"\" + type).split(\"/\") : [];\n    var actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return 'Detected an action creator with type \"' + (type || \"unknown\") + \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\" + actionName + \"())` instead of `dispatch(\" + actionName + \")`. This is necessary even if the action has no payload.\";\n}\nfunction createActionCreatorInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isActionCreator, isActionCreator2 = _c === void 0 ? isActionCreator : _c;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n        };\n    };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\nvar EnhancerArray = /** @class */ function(_super) {\n    __extends(EnhancerArray, _super);\n    function EnhancerArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, EnhancerArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(EnhancerArray, Symbol.species, {\n        get: function() {\n            return EnhancerArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EnhancerArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    EnhancerArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return EnhancerArray;\n}(Array);\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(val, function() {}) : val;\n}\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path, checkedObjects) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (checkedObjects === void 0) {\n        checkedObjects = new Set();\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_1 = function(key) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return {\n                value: result\n            };\n        }\n    };\n    for(var key in keysToDetect){\n        var state_1 = _loop_1(key);\n        if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache == null ? void 0 : cache.has(value)) return false;\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_2 = function(key, nestedValue) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                value: {\n                    keyPath: nestedPath,\n                    value: nestedValue\n                }\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return {\n                    value: foundNestedSerializable\n                };\n            }\n        }\n    };\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var state_2 = _loop_2(key, nestedValue);\n        if (typeof state_2 === \"object\") return state_2.value;\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for(var _i = 0, _c = Object.values(value); _i < _c.length; _i++){\n        var nestedValue = _c[_i];\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options.disableCache, disableCache = _k === void 0 ? false : _k;\n    var cache = !disableCache && WeakSet ? new WeakSet() : void 0;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e, _f = options.actionCreatorCheck, actionCreatorCheck = _f === void 0 ? true : _f;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n        if (actionCreatorCheck) {\n            var actionCreatorOptions = {};\n            if (!isBoolean(actionCreatorCheck)) {\n                actionCreatorOptions = actionCreatorCheck;\n            }\n            middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var defaultEnhancers = new EnhancerArray(middlewareEnhancer);\n    var storeEnhancers = defaultEnhancers;\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(defaultEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error(\"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error(\"`builder.addCase` cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nvar hasWarnedAboutObjectNotation = false;\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            if (!hasWarnedAboutObjectNotation) {\n                hasWarnedAboutObjectNotation = true;\n                console.warn(\"The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n            }\n        }\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return freezeDraftable(initialState());\n        };\n    } else {\n        var frozenInitialState_1 = freezeDraftable(initialState);\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nvar hasWarnedAboutObjectNotation2 = false;\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (options.initialState === void 0) {\n            console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n        }\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : freezeDraftable(options.initialState);\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        if (true) {\n            if (typeof options.extraReducers === \"object\") {\n                if (!hasWarnedAboutObjectNotation2) {\n                    hasWarnedAboutObjectNotation2 = true;\n                    console.warn(\"The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n        }\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, function(builder) {\n            for(var key in finalCaseReducers){\n                builder.addCase(key, finalCaseReducers[key]);\n            }\n            for(var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++){\n                var m = actionMatchers_1[_i];\n                builder.addMatcher(m.matcher, m.reducer);\n            }\n            if (defaultCaseReducer) {\n                builder.addDefaultCase(defaultCaseReducer);\n            }\n        });\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.keys(state.entities);\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var appliedUpdates = false;\n        for(var _i = 0, updates_1 = updates; _i < updates_1.length; _i++){\n            var update = updates_1[_i];\n            var entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            var newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = function() {\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n            return {\n                payload: payload,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"fulfilled\"\n                })\n            };\n        });\n        var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n            return {\n                payload: void 0,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"pending\"\n                })\n            };\n        });\n        var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n            return {\n                payload: payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                    condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n                })\n            };\n        });\n        var displayedWarning = false;\n        var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n            function class_1() {\n                this.signal = {\n                    aborted: false,\n                    addEventListener: function() {},\n                    dispatchEvent: function() {\n                        return false;\n                    },\n                    onabort: function() {},\n                    removeEventListener: function() {},\n                    reason: void 0,\n                    throwIfAborted: function() {}\n                };\n            }\n            class_1.prototype.abort = function() {\n                if (true) {\n                    if (!displayedWarning) {\n                        displayedWarning = true;\n                        console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                    }\n                }\n            };\n            return class_1;\n        }();\n        function actionCreator(arg) {\n            return function(dispatch, getState, extra) {\n                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                var abortController = new AC();\n                var abortReason;\n                var started = false;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                var promise2 = function() {\n                    return __async(this, null, function() {\n                        var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;\n                        return __generator(this, function(_c) {\n                            switch(_c.label){\n                                case 0:\n                                    _c.trys.push([\n                                        0,\n                                        4,\n                                        ,\n                                        5\n                                    ]);\n                                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                        getState: getState,\n                                        extra: extra\n                                    });\n                                    if (!isThenable(conditionResult)) return [\n                                        3 /*break*/ ,\n                                        2\n                                    ];\n                                    return [\n                                        4 /*yield*/ ,\n                                        conditionResult\n                                    ];\n                                case 1:\n                                    conditionResult = _c.sent();\n                                    _c.label = 2;\n                                case 2:\n                                    if (conditionResult === false || abortController.signal.aborted) {\n                                        throw {\n                                            name: \"ConditionError\",\n                                            message: \"Aborted due to condition callback returning false.\"\n                                        };\n                                    }\n                                    started = true;\n                                    abortedPromise = new Promise(function(_, reject) {\n                                        return abortController.signal.addEventListener(\"abort\", function() {\n                                            return reject({\n                                                name: \"AbortError\",\n                                                message: abortReason || \"Aborted\"\n                                            });\n                                        });\n                                    });\n                                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                        requestId: requestId,\n                                        arg: arg\n                                    }, {\n                                        getState: getState,\n                                        extra: extra\n                                    })));\n                                    return [\n                                        4 /*yield*/ ,\n                                        Promise.race([\n                                            abortedPromise,\n                                            Promise.resolve(payloadCreator(arg, {\n                                                dispatch: dispatch,\n                                                getState: getState,\n                                                extra: extra,\n                                                requestId: requestId,\n                                                signal: abortController.signal,\n                                                abort: abort,\n                                                rejectWithValue: function(value, meta) {\n                                                    return new RejectWithValue(value, meta);\n                                                },\n                                                fulfillWithValue: function(value, meta) {\n                                                    return new FulfillWithMeta(value, meta);\n                                                }\n                                            })).then(function(result) {\n                                                if (result instanceof RejectWithValue) {\n                                                    throw result;\n                                                }\n                                                if (result instanceof FulfillWithMeta) {\n                                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                                }\n                                                return fulfilled(result, requestId, arg);\n                                            })\n                                        ])\n                                    ];\n                                case 3:\n                                    finalAction = _c.sent();\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 4:\n                                    err_1 = _c.sent();\n                                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 5:\n                                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                    if (!skipDispatch) {\n                                        dispatch(finalAction);\n                                    }\n                                    return [\n                                        2 /*return*/ ,\n                                        finalAction\n                                    ];\n                            }\n                        });\n                    });\n                }();\n                return Object.assign(promise2, {\n                    abort: abort,\n                    requestId: requestId,\n                    arg: arg,\n                    unwrap: function() {\n                        return promise2.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending: pending,\n            rejected: rejected,\n            fulfilled: fulfilled,\n            typePrefix: typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = function() {\n        return createAsyncThunk2;\n    };\n    return createAsyncThunk2;\n}();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise2, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise2.catch(onError);\n    return promise2;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return function() {\n        return abortSignal.removeEventListener(\"abort\", callback);\n    };\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise2) {\n    var cleanup = noop;\n    return new Promise(function(resolve, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise2.finally(function() {\n            return cleanup();\n        }).then(resolve, reject);\n    }).finally(function() {\n        cleanup = noop;\n    });\n}\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise2) {\n        return catchRejection(raceWithSignal(signal, promise2).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal, parentBlockingPromises) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor, opts) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        if (opts == null ? void 0 : opts.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve, reject) {\n                            var stopListening = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                            unsubscribe = function() {\n                                stopListening();\n                                reject();\n                            };\n                        });\n                        promises = [\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            raceWithSignal(signal, Promise.race(promises))\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, autoJoinPromises, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        autoJoinPromises = [];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            6\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            Promise.allSettled(autoJoinPromises)\n                        ];\n                    case 5:\n                        _c.sent();\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (!isAction(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = function() {\n    return function(payload) {\n        var _c;\n        return {\n            payload: payload,\n            meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)\n        };\n    };\n};\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( true ? window : 0) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar createQueueWithTimer = function(timeout) {\n    return function(notify) {\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  true && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\nvar autoBatchEnhancer = function(options) {\n    if (options === void 0) {\n        options = {\n            type: \"raf\"\n        };\n    }\n    return function(next) {\n        return function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var store = next.apply(void 0, args);\n            var notifying = true;\n            var shouldNotifyAtEndOfTick = false;\n            var notificationQueued = false;\n            var listeners = new Set();\n            var queueCallback = options.type === \"tick\" ? queueMicrotaskShim : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            var notifyListeners = function() {\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach(function(l) {\n                        return l();\n                    });\n                }\n            };\n            return Object.assign({}, store, {\n                subscribe: function(listener2) {\n                    var wrappedListener = function() {\n                        return notifying && listener2();\n                    };\n                    var unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return function() {\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                dispatch: function(action) {\n                    var _a;\n                    try {\n                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n    };\n};\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUs7SUFDeEMsSUFBSUMsZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUM5QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1lBQUVDLFdBQVcsRUFBRTtRQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1lBQUlELEVBQUVJLFNBQVMsR0FBR0g7UUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7WUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUFFO1FBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0lBQzVCO0lBQ0EsT0FBTyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJUyxVQUFVLHlCQUF5QkMsT0FBT1YsS0FBSztRQUM3REYsY0FBY0MsR0FBR0M7UUFDakIsU0FBU1c7WUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2I7UUFBRztRQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9ZLE1BQU0sQ0FBQ2IsS0FBTVcsQ0FBQUEsR0FBR0wsU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSUssSUFBRztJQUN0RjtBQUNKO0FBQ0EsSUFBSUcsY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMs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QTtvQkFBSztnQkFDakQ7WUFDSjtZQUNBLE9BQU8xb0IsT0FBT2lXLE1BQU0sQ0FBQyxDQUFDLEdBQUdpUyxPQUFPO2dCQUM1QnpCLFdBQVcsU0FBVWtDLFNBQVM7b0JBQzFCLElBQUlDLGtCQUFrQjt3QkFBYyxPQUFPVCxhQUFhUTtvQkFBYTtvQkFDckUsSUFBSTdFLGNBQWNvRSxNQUFNekIsU0FBUyxDQUFDbUM7b0JBQ2xDTixVQUFVN2IsR0FBRyxDQUFDa2M7b0JBQ2QsT0FBTzt3QkFDSDdFO3dCQUNBd0UsVUFBVTdDLE1BQU0sQ0FBQ2tEO29CQUNyQjtnQkFDSjtnQkFDQS9LLFVBQVUsU0FBVTlWLE1BQU07b0JBQ3RCLElBQUlvVztvQkFDSixJQUFJO3dCQUNBaUssWUFBWSxDQUFFLEVBQUNqSyxLQUFLcFcsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT0gsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJdVcsRUFBRSxDQUFDa0osaUJBQWlCO3dCQUNsR2dCLDBCQUEwQixDQUFDRDt3QkFDM0IsSUFBSUMseUJBQXlCOzRCQUN6QixJQUFJLENBQUNDLG9CQUFvQjtnQ0FDckJBLHFCQUFxQjtnQ0FDckJFLGNBQWNFOzRCQUNsQjt3QkFDSjt3QkFDQSxPQUFPUCxNQUFNdEssUUFBUSxDQUFDOVY7b0JBQzFCLFNBQ1E7d0JBQ0pxZ0IsWUFBWTtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKO0lBQUc7QUFDUDtBQUNBLGVBQWU7QUFDZmxqQixnREFBU0E7QUFDKzBCLENBQ3gxQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcz84Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufTtcclxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcclxudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX3NwcmVhZFByb3BzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOyB9O1xyXG52YXIgX19hc3luYyA9IGZ1bmN0aW9uIChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH07XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8vIHNyYy9pbmRleC50c1xyXG5pbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgY3JlYXRlU2VsZWN0b3IyIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xyXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICB2YXIgd3JhcHBlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWVdLCByZXN0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcclxufTtcclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBhcHBseU1pZGRsZXdhcmUsIGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XHJcbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobm9vcDIpIHtcclxuICAgICAgICByZXR1cm4gbm9vcDI7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC10aHVua1wiO1xyXG4vLyBzcmMvdHNIZWxwZXJzLnRzXHJcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVwYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkXHJcbiAgICAgICAgICAgIH0sIFwibWV0YVwiIGluIHByZXBhcmVkICYmIHsgbWV0YTogcHJlcGFyZWQubWV0YSB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBhcmdzWzBdIH07XHJcbiAgICB9XHJcbiAgICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHR5cGU7IH07XHJcbiAgICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xyXG4gICAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi50eXBlID09PSB0eXBlOyB9O1xyXG4gICAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcclxuICAgIHZhciBzcGxpdFR5cGUgPSB0eXBlID8gKFwiXCIgKyB0eXBlKS5zcGxpdChcIi9cIikgOiBbXTtcclxuICAgIHZhciBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcclxuICAgIHJldHVybiBcIkRldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcXFwiXCIgKyAodHlwZSB8fCBcInVua25vd25cIikgKyBcIlxcXCIgYmVpbmcgZGlzcGF0Y2hlZC4gXFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gYGRpc3BhdGNoKFwiICsgYWN0aW9uTmFtZSArIFwiKCkpYCBpbnN0ZWFkIG9mIGBkaXNwYXRjaChcIiArIGFjdGlvbk5hbWUgKyBcIilgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuXCI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIG5leHQoYWN0aW9uKTsgfTsgfTsgfTtcclxuICAgIH1cclxuICAgIHZhciBfYyA9IG9wdGlvbnMuaXNBY3Rpb25DcmVhdG9yLCBpc0FjdGlvbkNyZWF0b3IyID0gX2MgPT09IHZvaWQgMCA/IGlzQWN0aW9uQ3JlYXRvciA6IF9jO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgfTsgfTsgfTtcclxufVxyXG4vLyBzcmMvdXRpbHMudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcclxuICAgIHZhciBlbGFwc2VkID0gMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVhc3VyZVRpbWU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybklmRXhjZWVkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGZuTmFtZSArIFwiIHRvb2sgXCIgKyBlbGFwc2VkICsgXCJtcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiBcIiArIG1heERlbGF5ICsgXCJtcy4gXFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxudmFyIE1pZGRsZXdhcmVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaWRkbGV3YXJlQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaWRkbGV3YXJlQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pZGRsZXdhcmVBcnJheSwgU3ltYm9sLnNwZWNpZXMsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoTWlkZGxld2FyZUFycmF5LmJpbmQuYXBwbHkoTWlkZGxld2FyZUFycmF5LCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcnIuY29uY2F0KHRoaXMpKSkpKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxufShBcnJheSkpO1xyXG52YXIgRW5oYW5jZXJBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbmhhbmNlckFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW5oYW5jZXJBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFbmhhbmNlckFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuaGFuY2VyQXJyYXksIFN5bWJvbC5zcGVjaWVzLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmhhbmNlckFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5oYW5jZXJBcnJheTtcclxufShBcnJheSkpO1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pIDogdmFsO1xyXG59XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xyXG4gICAgdmFyIHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGV0ZWN0TXV0YXRpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaiwgcGF0aCwgY2hlY2tlZE9iamVjdHMpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChjaGVja2VkT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGNoZWNrZWRPYmplY3RzID0gbmV3IFNldCgpOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xyXG4gICAgICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xyXG4gICAgICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFja2VkO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAoc2FtZVBhcmVudFJlZiA9PT0gdm9pZCAwKSB7IHNhbWVQYXJlbnRSZWYgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgICB2YXIgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICAgIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xyXG4gICAgICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGg6IHBhdGggfTtcclxuICAgIH1cclxuICAgIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzVG9EZXRlY3QgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgICAgICAgdmFyIGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGtleXNUb0RldGVjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShrZXkpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc0ltbXV0YWJsZSwgaXNJbW11dGFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNJbW11dGFibGVEZWZhdWx0IDogX2MsIGlnbm9yZWRQYXRocyA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBfZCA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZCA9PT0gdm9pZCAwID8gMzIgOiBfZCwgaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XHJcbiAgICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlO1xyXG4gICAgdmFyIHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYy5nZXRTdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIicuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJiBpbnZhcmlhbnQoIXJlc3VsdC53YXNNdXRhdGVkLCBcIkEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIi4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiBcIiArIHN0cmluZ2lmeShhY3Rpb24pICsgXCIuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcclxuICAgICAgICB9OyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSkge1xyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgaWYgKGlzU2VyaWFsaXphYmxlID09PSB2b2lkIDApIHsgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluOyB9XHJcbiAgICBpZiAoaWdub3JlZFBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlZFBhdGhzID0gW107IH1cclxuICAgIHZhciBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcclxuICAgIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuaGFzKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoa2V5LCBuZXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgICAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoa2V5LCBuZXN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8yID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMi52YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXHJcbiAgICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgbmVzdGVkVmFsdWUgPSBfY1tfaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc1NlcmlhbGl6YWJsZSwgaXNTZXJpYWxpemFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNQbGFpbiA6IF9jLCBnZXRFbnRyaWVzID0gb3B0aW9ucy5nZXRFbnRyaWVzLCBfZCA9IG9wdGlvbnMuaWdub3JlZEFjdGlvbnMsIGlnbm9yZWRBY3Rpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9uUGF0aHMsIGlnbm9yZWRBY3Rpb25QYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSA6IF9lLCBfZiA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBpZ25vcmVkUGF0aHMgPSBfZiA9PT0gdm9pZCAwID8gW10gOiBfZiwgX2cgPSBvcHRpb25zLndhcm5BZnRlciwgd2FybkFmdGVyID0gX2cgPT09IHZvaWQgMCA/IDMyIDogX2csIF9oID0gb3B0aW9ucy5pZ25vcmVTdGF0ZSwgaWdub3JlU3RhdGUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBvcHRpb25zLmlnbm9yZUFjdGlvbnMsIGlnbm9yZUFjdGlvbnMgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmRpc2FibGVDYWNoZSwgZGlzYWJsZUNhY2hlID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2s7XHJcbiAgICB2YXIgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSwgX2YgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3JDaGVjaywgYWN0aW9uQ3JlYXRvckNoZWNrID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZjtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9jID0gb3B0aW9ucyB8fCB7fSwgX2QgPSBfYy5yZWR1Y2VyLCByZWR1Y2VyID0gX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLCBfZSA9IF9jLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZSA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZSwgX2YgPSBfYy5kZXZUb29scywgZGV2VG9vbHMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9jLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZywgX2ggPSBfYy5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaDtcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdEVuaGFuY2VycyA9IG5ldyBFbmhhbmNlckFycmF5KG1pZGRsZXdhcmVFbmhhbmNlcik7XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBkZWZhdWx0RW5oYW5jZXJzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gX19zcHJlYWRBcnJheShbbWlkZGxld2FyZUVuaGFuY2VyXSwgZW5oYW5jZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gZW5oYW5jZXJzKGRlZmF1bHRFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoZXI6IGZ1bmN0aW9uIChtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyOiBtYXRjaGVyLCByZWR1Y2VyOiByZWR1Y2VyIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlZmF1bHRDYXNlOiBmdW5jdGlvbiAocmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XHJcbiAgICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgIGlmIChhY3Rpb25NYXRjaGVycyA9PT0gdm9pZCAwKSB7IGFjdGlvbk1hdGNoZXJzID0gW107IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSVEsgMi4wLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlUmVkdWNlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfYyA9IHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spIDogW21hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXSwgYWN0aW9uc01hcCA9IF9jWzBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzID0gX2NbMV0sIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyID0gX2NbMl07XHJcbiAgICB2YXIgZ2V0SW5pdGlhbFN0YXRlO1xyXG4gICAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb3plbkluaXRpYWxTdGF0ZV8xOyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTsgfVxyXG4gICAgICAgIHZhciBjYXNlUmVkdWNlcnMgPSBfX3NwcmVhZEFycmF5KFtcclxuICAgICAgICAgICAgYWN0aW9uc01hcFthY3Rpb24udHlwZV1cclxuICAgICAgICBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXIgPSBfYy5tYXRjaGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIHJlZHVjZXIyID0gX2MucmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZXIyO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcihmdW5jdGlvbiAoY3IpIHsgcmV0dXJuICEhY3I7IH0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFmdDIocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIgPSBmYWxzZTtcclxuZnVuY3Rpb24gZ2V0VHlwZTIoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gICAgcmV0dXJuIHNsaWNlICsgXCIvXCIgKyBhY3Rpb25LZXk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpY2Uob3B0aW9ucykge1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxTdGF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxTdGF0ZSA6IGZyZWV6ZURyYWZ0YWJsZShvcHRpb25zLmluaXRpYWxTdGF0ZSk7XHJcbiAgICB2YXIgcmVkdWNlcnMgPSBvcHRpb25zLnJlZHVjZXJzIHx8IHt9O1xyXG4gICAgdmFyIHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgdmFyIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlID0ge307XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VyTmFtZSkge1xyXG4gICAgICAgIHZhciBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUyKG5hbWUsIHJlZHVjZXJOYW1lKTtcclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgdmFyIHByZXBhcmVDYWxsYmFjaztcclxuICAgICAgICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbcmVkdWNlck5hbWVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlcjtcclxuICAgICAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dE9iamVjdE5vdGF0aW9uMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUlRLIDIuMC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYyA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXSwgX2QgPSBfY1swXSwgZXh0cmFSZWR1Y2VycyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBfZSA9IF9jWzFdLCBhY3Rpb25NYXRjaGVycyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IF9jWzJdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Y7XHJcbiAgICAgICAgdmFyIGZpbmFsQ2FzZVJlZHVjZXJzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGV4dHJhUmVkdWNlcnMpLCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYWN0aW9uTWF0Y2hlcnNfMSA9IGFjdGlvbk1hdGNoZXJzOyBfaSA8IGFjdGlvbk1hdGNoZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGFjdGlvbk1hdGNoZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBfcmVkdWNlcjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICByZWR1Y2VyOiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uczogYWN0aW9uQ3JlYXRvcnMsXHJcbiAgICAgICAgY2FzZVJlZHVjZXJzOiBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVkdWNlcilcclxuICAgICAgICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHNcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZSkge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsU3RhdGUgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsU3RhdGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0SWRzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5pZHM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEVudGl0aWVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5lbnRpdGllczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgZnVuY3Rpb24gKGlkcywgZW50aXRpZXMpIHsgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH0pOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0SWQgPSBmdW5jdGlvbiAoXywgaWQpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RCeUlkID0gZnVuY3Rpb24gKGVudGl0aWVzLCBpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgZnVuY3Rpb24gKGlkcykgeyByZXR1cm4gaWRzLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0SWRzOiBzZWxlY3RJZHMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBzZWxlY3RUb3RhbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0SWRzOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgICAgICAgc2VsZWN0QWxsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldFNlbGVjdG9yczogZ2V0U2VsZWN0b3JzIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZTMsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgdmFyIG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcihmdW5jdGlvbiAoXywgc3RhdGUpIHsgcmV0dXJuIG11dGF0b3Ioc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydW5NdXRhdG9yID0gZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNEcmFmdDMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcclxuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XHJcbiAgICB2YXIga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0aWVzO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHZhciBhZGRlZCA9IFtdO1xyXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMSA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzFbX2ldO1xyXG4gICAgICAgIHZhciBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkOiBpZCwgY2hhbmdlczogZW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzIgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMltfaV07XHJcbiAgICAgICAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzMgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfM1tfaV07XHJcbiAgICAgICAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzID0ge307XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gc3RhdGUuZW50aXRpZXM7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgICAgICAgIGlkczogW10sXHJcbiAgICAgICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsMiA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDIsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICB2YXIgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xyXG4gICAgICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAgICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc05ld0tleTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9O1xyXG4gICAgICAgIHZhciB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCksIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSk7IH0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC5rZXlzKHN0YXRlLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB1cGRhdGVzXzEgPSB1cGRhdGVzOyBfaSA8IHVwZGF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYyA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2NbMF0sIHVwZGF0ZWQgPSBfY1sxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcclxuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgZnVuY3Rpb24gKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGFib3J0ZWQ6IChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubmFtZSkgPT09IFwiQWJvcnRFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgQUMgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSBcInVuZGVmaW5lZFwiID8gQWJvcnRDb250cm9sbGVyIDogLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbmFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQWJvcnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRHZW5lcmF0b3IpID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRSZWFzb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBhYm9ydGVkUHJvbWlzZSwgZXJyXzEsIHNraXBEaXNwYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFswLCA0LCAsIDVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kaXRpb25SZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0UGVuZGluZ01ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGFyZzogYXJnIH0sIHsgZ2V0U3RhdGU6IGdldFN0YXRlLCBleHRyYTogZXh0cmEgfSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVycl8xIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVycl8xLnBheWxvYWQsIGVycl8xLm1ldGEpIDogcmVqZWN0ZWQoZXJyXzEsIHJlcXVlc3RJZCwgYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmluYWxBY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTIudGhlbih1bndyYXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XHJcbiAgICAgICAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICAgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXHJcbiAgICAgICAgICAgIHR5cGVQcmVmaXg6IHR5cGVQcmVmaXhcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyOyB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy9tYXRjaGVycy50c1xyXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChtYXRjaGVyLCBhY3Rpb24pIHtcclxuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGlzQW55T2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsT2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XHJcbiAgICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGVuZGluZygpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucGVuZGluZzsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnJlamVjdGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5mdWxmaWxsZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhc3luY1RodW5rc18xID0gYXN5bmNUaHVua3M7IF9pIDwgYXN5bmNUaHVua3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGh1bmsgPSBhc3luY1RodW5rc18xW19pXTtcclxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXHJcbnZhciBhc3NlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGV4cGVjdGVkICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG52YXIgY2F0Y2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZTIsIG9uRXJyb3IpIHtcclxuICAgIGlmIChvbkVycm9yID09PSB2b2lkIDApIHsgb25FcnJvciA9IG5vb3A7IH1cclxuICAgIHByb21pc2UyLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2UyO1xyXG59O1xyXG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYm9ydFNpZ25hbCwgY2FsbGJhY2spIHtcclxuICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7IH07XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZTIpIHtcclxuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZTIuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFudXAgPSBub29wO1xyXG4gICAgfSk7XHJcbn1cclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZTIpIHtcclxuICAgICAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlMikudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKHNpZ25hbCkge1xyXG4gICAgdmFyIHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZW91dE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcyk7IH0pKTtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gZnVuY3Rpb24gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSB7XHJcbiAgICB2YXIgbGlua0NvbnRyb2xsZXJzID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHsgcmV0dXJuIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKTsgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhc2tFeGVjdXRvciwgb3B0cykge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICAgICAgdmFyIGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1blRhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCk7IH0pO1xyXG4gICAgICAgIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmF1dG9Kb2luKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IGZ1bmN0aW9uIChzdGFydExpc3RlbmluZywgc2lnbmFsKSB7XHJcbiAgICB2YXIgdGFrZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlLCB0dXBsZVByb21pc2UsIHByb21pc2VzLCBvdXRwdXQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogZnVuY3Rpb24gKGFjdGlvbiwgbGlzdGVuZXJBcGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCk7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG91dHB1dF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7IH07XHJcbn07XHJcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlLCBhY3Rpb25DcmVhdG9yID0gb3B0aW9ucy5hY3Rpb25DcmVhdG9yLCBtYXRjaGVyID0gb3B0aW9ucy5tYXRjaGVyLCBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZSwgZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3Q7XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcclxuICAgICAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZSkge1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XHJcbiAgICByZXR1cm4geyBwcmVkaWNhdGU6IHByZWRpY2F0ZSwgdHlwZTogdHlwZSwgZWZmZWN0OiBlZmZlY3QgfTtcclxufTtcclxudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZSwgZWZmZWN0ID0gX2MuZWZmZWN0O1xyXG4gICAgdmFyIGlkID0gbmFub2lkKCk7XHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGVmZmVjdDogZWZmZWN0LFxyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXHJcbiAgICAgICAgcGVuZGluZzogbmV3IFNldCgpLFxyXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59O1xyXG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBmdW5jdGlvbiAobGlzdGVuZXJNYXApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBhZGRMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9hZGRcIik7XHJcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVBbGxcIik7XHJcbnZhciByZW1vdmVMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVcIik7XHJcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfX3NwcmVhZEFycmF5KFthbG0gKyBcIi9lcnJvclwiXSwgYXJncykpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBpZiAobWlkZGxld2FyZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlT3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgbGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgZXh0cmEgPSBtaWRkbGV3YXJlT3B0aW9ucy5leHRyYSwgX2MgPSBtaWRkbGV3YXJlT3B0aW9ucy5vbkVycm9yLCBvbkVycm9yID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBfYztcclxuICAgIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcclxuICAgIHZhciBpbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTsgfTtcclxuICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbmNlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbE9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZmluZExpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAoY29tcGFyYXRvcikge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuICAgIHZhciBzdGFydExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkoZnVuY3Rpb24gKGV4aXN0aW5nRW50cnkpIHsgcmV0dXJuIGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdDsgfSk7XHJcbiAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYyA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyksIHR5cGUgPSBfYy50eXBlLCBlZmZlY3QgPSBfYy5lZmZlY3QsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZTtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZW50cnkyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISFlbnRyeTtcclxuICAgIH07XHJcbiAgICB2YXIgbm90aWZ5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSB7IHJldHVybiBfX2FzeW5jKF90aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGludGVybmFsVGFza0NvbnRyb2xsZXIsIHRha2UsIGF1dG9Kb2luUHJvbWlzZXMsIGxpc3RlbmVyRXJyb3JfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAzLCA0LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sIGFzc2lnbih7fSwgYXBpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlOiBnZXRPcmlnaW5hbFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlciwgXywgc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyRXJyb3JfMSA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShsaXN0ZW5lckVycm9yXzEgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvcl8xLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsU2V0dGxlZChhdXRvSm9pblByb21pc2VzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBnZXRPcmlnaW5hbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWxtICsgXCI6IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyRW50cmllc18xID0gbGlzdGVuZXJFbnRyaWVzOyBfaSA8IGxpc3RlbmVyRW50cmllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3RlbmVyRW50cmllc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLFxyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBzdGFydExpc3RlbmluZyxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBzdG9wTGlzdGVuaW5nLFxyXG4gICAgICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcclxudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcclxudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICB2YXIgX2M7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IChfYyA9IHt9LCBfY1tTSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9jKVxyXG4gICAgfSk7XHJcbn07IH07XHJcbnZhciBwcm9taXNlO1xyXG52YXIgcXVldWVNaWNyb3Rhc2tTaGltID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZ2xvYmFsVGhpcykgOiBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IGVycjtcclxufSwgMCk7IH0pOyB9O1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3RpZnkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgdHlwZTogXCJyYWZcIiB9OyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3JlID0gbmV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrU2hpbSA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9OyB9O1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuZW5hYmxlRVM1KCk7XHJcbmV4cG9ydCB7IEVuaGFuY2VyQXJyYXksIE1pZGRsZXdhcmVBcnJheSwgU0hPVUxEX0FVVE9CQVRDSCwgVGFza0Fib3J0RXJyb3IsIGFkZExpc3RlbmVyLCBhdXRvQmF0Y2hFbmhhbmNlciwgY2xlYXJBbGxMaXN0ZW5lcnMsIGNvbmZpZ3VyZVN0b3JlLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWN0aW9uLCBpc0FjdGlvbkNyZWF0b3IsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCBwcmVwYXJlQXV0b0JhdGNoZWQsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiaGFzTWF0Y2hGdW5jdGlvbiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInBheWxvYWQiLCJtZXRhIiwiZXJyb3IiLCJ0b1N0cmluZyIsImFjdGlvbiIsImlzQWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiaW5kZXhPZiIsImdldFR5cGUiLCJnZXRNZXNzYWdlIiwic3BsaXRUeXBlIiwic3BsaXQiLCJhY3Rpb25OYW1lIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwicHJvY2VzcyIsImlzQWN0aW9uQ3JlYXRvcjIiLCJjb25zb2xlIiwid2FybiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRHJhZnRhYmxlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJNaWRkbGV3YXJlQXJyYXkiLCJfc3VwZXIiLCJfdGhpcyIsInNwZWNpZXMiLCJnZXQiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImJpbmQiLCJFbmhhbmNlckFycmF5IiwiZnJlZXplRHJhZnRhYmxlIiwidmFsIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsInN0cmluZ2lmeSIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJnZXRTZXJpYWxpemUiLCJzdGFjayIsInNsaWNlIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwiY2hlY2tlZE9iamVjdHMiLCJTZXQiLCJ0cmFja2VkIiwiaGFzIiwiYWRkIiwiY2hpbGRyZW4iLCJjaGlsZFBhdGgiLCJpZ25vcmVkUGF0aHMiLCJ0cmFja2VkUHJvcGVydHkiLCJzYW1lUGFyZW50UmVmIiwicHJldk9iaiIsInNhbWVSZWYiLCJOdW1iZXIiLCJpc05hTiIsIndhc011dGF0ZWQiLCJrZXlzVG9EZXRlY3QiLCJoYXNJZ25vcmVkUGF0aHMiLCJfbG9vcF8xIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdGF0ZV8xIiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiX2QiLCJ3YXJuQWZ0ZXIiLCJpZ25vcmUiLCJ0cmFjayIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJfbG9vcF8yIiwibmVzdGVkVmFsdWUiLCJlbnRyaWVzXzEiLCJzdGF0ZV8yIiwiaXNOZXN0ZWRGcm96ZW4iLCJ2YWx1ZXMiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJfayIsImRpc2FibGVDYWNoZSIsIldlYWtTZXQiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc0Jvb2xlYW4iLCJjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlIiwiY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJ0aHVuayIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImV4dHJhQXJndW1lbnQiLCJpbW11dGFibGVPcHRpb25zIiwidW5zaGlmdCIsInNlcmlhbGl6YWJsZU9wdGlvbnMiLCJhY3Rpb25DcmVhdG9yT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiZGVmYXVsdEVuaGFuY2VycyIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGVfMSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yIiwiZ2V0VHlwZTIiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsImZvckVhY2giLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsImFjdGlvbk1hdGNoZXJzXzEiLCJtIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwidXBkYXRlc18xIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsImNvbW1vblByb3BlcnRpZXNfMSIsInByb3BlcnR5IiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwicmVxdWVzdElkIiwicmVxdWVzdFN0YXR1cyIsInBlbmRpbmciLCJzZXJpYWxpemVFcnJvciIsInJlamVjdGVkV2l0aFZhbHVlIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImNsYXNzXzEiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhc29uIiwidGhyb3dJZkFib3J0ZWQiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsInByb21pc2UyIiwiX2EiLCJfYiIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiYWJvcnRlZFByb21pc2UiLCJlcnJfMSIsInNraXBEaXNwYXRjaCIsImlzVGhlbmFibGUiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJ3aXRoVHlwZXMiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiaXNQZW5kaW5nIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJoYXNGbGFnIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJhc3luY1RodW5rc18xIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsImVycm9yXzEiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJzZXRUaW1lb3V0IiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJlbnRyeSIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwibGlzdGVuZXJNYXAiLCJjbGVhciIsInNhZmVseU5vdGlmeUVycm9yIiwiZXJyb3JIYW5kbGVyIiwiZXJyb3JUb05vdGlmeSIsImVycm9ySW5mbyIsImVycm9ySGFuZGxlckVycm9yIiwiYWRkTGlzdGVuZXIiLCJjbGVhckFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsImNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVPcHRpb25zIiwiTWFwIiwiaW5zZXJ0RW50cnkiLCJkZWxldGUiLCJzZXQiLCJjYW5jZWxPcHRpb25zIiwiY2FuY2VsQWN0aXZlIiwiZmluZExpc3RlbmVyRW50cnkiLCJjb21wYXJhdG9yIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwiYXV0b0pvaW5Qcm9taXNlcyIsImxpc3RlbmVyRXJyb3JfMSIsIkJvb2xlYW4iLCJmb3JrIiwic3Vic2NyaWJlIiwicmFpc2VkQnkiLCJhbGxTZXR0bGVkIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwibGlzdGVuZXJFbnRyaWVzXzEiLCJydW5MaXN0ZW5lciIsInByZWRpY2F0ZUVycm9yIiwiY2xlYXJMaXN0ZW5lcnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicHJvbWlzZSIsInF1ZXVlTWljcm90YXNrU2hpbSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiZXJyIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJub3RpZnkiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVOb3RpZmljYXRpb24iLCJub3RpZnlMaXN0ZW5lcnMiLCJsIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e) {\n    var t, f, n = \"\";\n    if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n    else if (\"object\" == typeof e) if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n    else for(t in e)e[t] && (n && (n += \" \"), n += t);\n    return n;\n}\nfunction clsx() {\n    for(var e, t, f = 0, n = \"\"; f < arguments.length;)(e = arguments[f++]) && (t = r(e)) && (n && (n += \" \"), n += t);\n    return n;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxFQUFFQyxDQUFDO0lBQUUsSUFBSUMsR0FBRUMsR0FBRUMsSUFBRTtJQUFHLElBQUcsWUFBVSxPQUFPSCxLQUFHLFlBQVUsT0FBT0EsR0FBRUcsS0FBR0g7U0FBTyxJQUFHLFlBQVUsT0FBT0EsR0FBRSxJQUFHSSxNQUFNQyxPQUFPLENBQUNMLElBQUcsSUFBSUMsSUFBRSxHQUFFQSxJQUFFRCxFQUFFTSxNQUFNLEVBQUNMLElBQUlELENBQUMsQ0FBQ0MsRUFBRSxJQUFHQyxDQUFBQSxJQUFFSCxFQUFFQyxDQUFDLENBQUNDLEVBQUUsTUFBS0UsQ0FBQUEsS0FBSUEsQ0FBQUEsS0FBRyxHQUFFLEdBQUdBLEtBQUdELENBQUFBO1NBQVEsSUFBSUQsS0FBS0QsRUFBRUEsQ0FBQyxDQUFDQyxFQUFFLElBQUdFLENBQUFBLEtBQUlBLENBQUFBLEtBQUcsR0FBRSxHQUFHQSxLQUFHRixDQUFBQTtJQUFHLE9BQU9FO0FBQUM7QUFBUSxTQUFTSTtJQUFPLElBQUksSUFBSVAsR0FBRUMsR0FBRUMsSUFBRSxHQUFFQyxJQUFFLElBQUdELElBQUVNLFVBQVVGLE1BQU0sRUFBRSxDQUFDTixJQUFFUSxTQUFTLENBQUNOLElBQUksS0FBSUQsQ0FBQUEsSUFBRUYsRUFBRUMsRUFBQyxLQUFLRyxDQUFBQSxLQUFJQSxDQUFBQSxLQUFHLEdBQUUsR0FBR0EsS0FBR0YsQ0FBQUE7SUFBRyxPQUFPRTtBQUFDO0FBQUMsK0RBQWVJLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanM/NzdhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiXSwibmFtZXMiOlsiciIsImUiLCJ0IiwiZiIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJjbHN4IiwiYXJndW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.m.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar reactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */ var REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    \"$$typeof\": true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    \"$$typeof\": true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\nfunction getStatics(component) {\n    // React v16.11 and below\n    if (reactIs.isMemo(component)) {\n        return MEMO_STATICS;\n    } // React v16.12 and above\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== \"string\") {\n        // don't hoist over string (html) components\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n        var keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        var targetStatics = getStatics(targetComponent);\n        var sourceStatics = getStatics(sourceComponent);\n        for(var i = 0; i < keys.length; ++i){\n            var key = keys[i];\n            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\nmodule.exports = hoistNonReactStatics;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXRCOzs7Q0FHQyxHQUNELElBQUlDLGdCQUFnQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsMEJBQTBCO0lBQzFCQywwQkFBMEI7SUFDMUJDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxNQUFNO0FBQ1I7QUFDQSxJQUFJQyxnQkFBZ0I7SUFDbEJDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLE9BQU87QUFDVDtBQUNBLElBQUlDLHNCQUFzQjtJQUN4QixZQUFZO0lBQ1pDLFFBQVE7SUFDUmpCLGNBQWM7SUFDZEMsYUFBYTtJQUNiSyxXQUFXO0FBQ2I7QUFDQSxJQUFJWSxlQUFlO0lBQ2pCLFlBQVk7SUFDWkMsU0FBUztJQUNUbkIsY0FBYztJQUNkQyxhQUFhO0lBQ2JLLFdBQVc7SUFDWEMsTUFBTTtBQUNSO0FBQ0EsSUFBSWEsZUFBZSxDQUFDO0FBQ3BCQSxZQUFZLENBQUMxQixRQUFRMkIsVUFBVSxDQUFDLEdBQUdMO0FBQ25DSSxZQUFZLENBQUMxQixRQUFRNEIsSUFBSSxDQUFDLEdBQUdKO0FBRTdCLFNBQVNLLFdBQVdDLFNBQVM7SUFDM0IseUJBQXlCO0lBQ3pCLElBQUk5QixRQUFRK0IsTUFBTSxDQUFDRCxZQUFZO1FBQzdCLE9BQU9OO0lBQ1QsRUFBRSx5QkFBeUI7SUFHM0IsT0FBT0UsWUFBWSxDQUFDSSxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUk1QjtBQUNoRDtBQUVBLElBQUk4QixpQkFBaUJDLE9BQU9ELGNBQWM7QUFDMUMsSUFBSUUsc0JBQXNCRCxPQUFPQyxtQkFBbUI7QUFDcEQsSUFBSUMsd0JBQXdCRixPQUFPRSxxQkFBcUI7QUFDeEQsSUFBSUMsMkJBQTJCSCxPQUFPRyx3QkFBd0I7QUFDOUQsSUFBSUMsaUJBQWlCSixPQUFPSSxjQUFjO0FBQzFDLElBQUlDLGtCQUFrQkwsT0FBT2hCLFNBQVM7QUFDdEMsU0FBU3NCLHFCQUFxQkMsZUFBZSxFQUFFQyxlQUFlLEVBQUVDLFNBQVM7SUFDdkUsSUFBSSxPQUFPRCxvQkFBb0IsVUFBVTtRQUN2Qyw0Q0FBNEM7UUFDNUMsSUFBSUgsaUJBQWlCO1lBQ25CLElBQUlLLHFCQUFxQk4sZUFBZUk7WUFFeEMsSUFBSUUsc0JBQXNCQSx1QkFBdUJMLGlCQUFpQjtnQkFDaEVDLHFCQUFxQkMsaUJBQWlCRyxvQkFBb0JEO1lBQzVEO1FBQ0Y7UUFFQSxJQUFJRSxPQUFPVixvQkFBb0JPO1FBRS9CLElBQUlOLHVCQUF1QjtZQUN6QlMsT0FBT0EsS0FBS0MsTUFBTSxDQUFDVixzQkFBc0JNO1FBQzNDO1FBRUEsSUFBSUssZ0JBQWdCakIsV0FBV1c7UUFDL0IsSUFBSU8sZ0JBQWdCbEIsV0FBV1k7UUFFL0IsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlKLEtBQUs1QixNQUFNLEVBQUUsRUFBRWdDLEVBQUc7WUFDcEMsSUFBSUMsTUFBTUwsSUFBSSxDQUFDSSxFQUFFO1lBRWpCLElBQUksQ0FBQ2xDLGFBQWEsQ0FBQ21DLElBQUksSUFBSSxDQUFFUCxDQUFBQSxhQUFhQSxTQUFTLENBQUNPLElBQUksS0FBSyxDQUFFRixDQUFBQSxpQkFBaUJBLGFBQWEsQ0FBQ0UsSUFBSSxLQUFLLENBQUVILENBQUFBLGlCQUFpQkEsYUFBYSxDQUFDRyxJQUFJLEdBQUc7Z0JBQzdJLElBQUlDLGFBQWFkLHlCQUF5QkssaUJBQWlCUTtnQkFFM0QsSUFBSTtvQkFDRiwyQ0FBMkM7b0JBQzNDakIsZUFBZVEsaUJBQWlCUyxLQUFLQztnQkFDdkMsRUFBRSxPQUFPQyxHQUFHLENBQUM7WUFDZjtRQUNGO0lBQ0Y7SUFFQSxPQUFPWDtBQUNUO0FBRUFZLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzPzkxZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG4iXSwibmFtZXMiOlsicmVhY3RJcyIsInJlcXVpcmUiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbnRleHRUeXBlcyIsImRlZmF1bHRQcm9wcyIsImRpc3BsYXlOYW1lIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibWl4aW5zIiwicHJvcFR5cGVzIiwidHlwZSIsIktOT1dOX1NUQVRJQ1MiLCJuYW1lIiwibGVuZ3RoIiwicHJvdG90eXBlIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJndW1lbnRzIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsIkZvcndhcmRSZWYiLCJNZW1vIiwiZ2V0U3RhdGljcyIsImNvbXBvbmVudCIsImlzTWVtbyIsImRlZmluZVByb3BlcnR5IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJibGFja2xpc3QiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJrZXlzIiwiY29uY2F0IiwidGFyZ2V0U3RhdGljcyIsInNvdXJjZVN0YXRpY3MiLCJpIiwia2V5IiwiZGVzY3JpcHRvciIsImUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/immer.cjs.development.js":
/*!**********************************************************!*\
  !*** ./node_modules/immer/dist/immer.cjs.development.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _ref;\n// Should be no imports here!\n// Some things that should be evaluated before all else...\n// We only want to know if non-polyfilled symbols are available\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof /*#__PURE__*/ Symbol(\"x\") === \"symbol\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */ var NOTHING = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */ var DRAFTABLE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\nvar errors = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function _(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function _(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function _(op) {\n        return \"Unsupported patch operation: \" + op;\n    },\n    18: function _(plugin) {\n        return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function _(thing) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\n    },\n    22: function _(thing) {\n        return \"'current' expects a draft, got: \" + thing;\n    },\n    23: function _(thing) {\n        return \"'original' expects a draft, got: \" + thing;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n};\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    {\n        var e = errors[error];\n        var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\n        throw new Error(\"[Immer] \" + msg);\n    }\n}\n/** Returns true if the given value is an Immer draft */ /*#__PURE__*/ function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */ /*#__PURE__*/ function isDraftable(value) {\n    var _value$constructor;\n    if (!value) return false;\n    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString = /*#__PURE__*/ Object.prototype.constructor.toString();\n/*#__PURE__*/ function isPlainObject(value) {\n    if (!value || typeof value !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    if (Ctor === Object) return true;\n    return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(23, value);\n    return value[DRAFT_STATE].base_;\n}\n/*#__PURE__*/ var ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function(obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    ownKeys(target).forEach(function(key) {\n        res[key] = Object.getOwnPropertyDescriptor(target, key);\n    });\n    return res;\n};\nfunction each(obj, iter, enumerableOnly) {\n    if (enumerableOnly === void 0) {\n        enumerableOnly = false;\n    }\n    if (getArchtype(obj) === 0) {\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {\n            if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach(function(entry, index) {\n            return iter(index, entry, obj);\n        });\n    }\n}\n/*#__PURE__*/ function getArchtype(thing) {\n    /* istanbul ignore next */ var state = thing[DRAFT_STATE];\n    return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\n     : state.type_ // others are the same\n     : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0 /* Object */ ;\n}\n/*#__PURE__*/ function has(thing, prop) {\n    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n/*#__PURE__*/ function get(thing, prop) {\n    // @ts-ignore\n    return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];\n}\n/*#__PURE__*/ function set(thing, propOrOldValue, value) {\n    var t = getArchtype(thing);\n    if (t === 2) thing.set(propOrOldValue, value);\n    else if (t === 3) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n/*#__PURE__*/ function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\n/*#__PURE__*/ function isMap(target) {\n    return hasMap && target instanceof Map;\n}\n/*#__PURE__*/ function isSet(target) {\n    return hasSet && target instanceof Set;\n}\n/*#__PURE__*/ function latest(state) {\n    return state.copy_ || state.base_;\n}\n/*#__PURE__*/ function shallowCopy(base) {\n    if (Array.isArray(base)) return Array.prototype.slice.call(base);\n    var descriptors = getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    var keys = ownKeys(descriptors);\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        var desc = descriptors[key];\n        if (desc.writable === false) {\n            desc.writable = true;\n            desc.configurable = true;\n        } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n        // with libraries that trap values, like mobx or vue\n        // unlike object.assign, non-enumerables will be copied as well\n        if (desc.get || desc.set) descriptors[key] = {\n            configurable: true,\n            writable: true,\n            enumerable: desc.enumerable,\n            value: base[key]\n        };\n    }\n    return Object.create(Object.getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n    Object.freeze(obj);\n    if (deep) each(obj, function(key, value) {\n        return freeze(value, true);\n    }, true);\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nfunction isFrozen(obj) {\n    if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\n    return Object.isFrozen(obj);\n}\n/** Plugin utilities */ var plugins = {};\nfunction getPlugin(pluginKey) {\n    var plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(18, pluginKey);\n    } // @ts-ignore\n    return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\nvar currentScope;\nfunction getCurrentScope() {\n    if (!currentScope) die(0);\n    return currentScope;\n}\nfunction createScope(parent_, immer_) {\n    return {\n        drafts_: [],\n        parent_: parent_,\n        immer_: immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0\n    };\n}\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        getPlugin(\"Patches\"); // assert we have the plugin\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft); // @ts-ignore\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nfunction enterScope(immer) {\n    return currentScope = createScope(currentScope, immer);\n}\nfunction revokeDraft(draft) {\n    var state = draft[DRAFT_STATE];\n    if (state.type_ === 0 || state.type_ === 1) state.revoke_();\n    else state.revoked_ = true;\n}\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    var baseDraft = scope.drafts_[0];\n    var isReplaced = result !== undefined && result !== baseDraft;\n    if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            // Finalize the result in case it contains (or is) a subset of the draft.\n            result = finalize(scope, result);\n            if (!scope.parent_) maybeFreeze(scope, result);\n        }\n        if (scope.patches_) {\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n        }\n    } else {\n        // Finalize the base draft.\n        result = finalize(scope, baseDraft, []);\n    }\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : undefined;\n}\nfunction finalize(rootScope, value, path) {\n    // Don't recurse in tho recursive data structures\n    if (isFrozen(value)) return value;\n    var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\n    if (!state) {\n        each(value, function(key, childValue) {\n            return finalizeProperty(rootScope, state, value, key, childValue, path);\n        }, true // See #590, don't recurse into non-enumerable of non drafted objects\n        );\n        return value;\n    } // Never finalize drafts owned by another scope.\n    if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\n    if (!state.modified_) {\n        maybeFreeze(rootScope, state.base_, true);\n        return state.base_;\n    } // Not finalized yet, let's do that now\n    if (!state.finalized_) {\n        state.finalized_ = true;\n        state.scope_.unfinalizedDrafts_--;\n        var result = state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n        // To preserve insertion order in all cases we then clear the set\n        // And we let finalizeProperty know it needs to re-add non-draft children back to the target\n        var resultEach = result;\n        var isSet = false;\n        if (state.type_ === 3) {\n            resultEach = new Set(result);\n            result.clear();\n            isSet = true;\n        }\n        each(resultEach, function(key, childValue) {\n            return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);\n        }); // everything inside is frozen, we can freeze here\n        maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\n        if (path && rootScope.patches_) {\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n        }\n    }\n    return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n    if (childValue === targetObject) die(5);\n    if (isDraft(childValue)) {\n        var path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.\n        !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\n         ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n        var res = finalize(rootScope, childValue, path);\n        set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n        if (isDraft(res)) {\n            rootScope.canAutoFreeze_ = false;\n        } else return;\n    } else if (targetIsSet) {\n        targetObject.add(childValue);\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n            // optimization: if an object is not a draft, and we don't have to\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n            // This benefits especially adding large data tree's without further processing.\n            // See add-data.js perf test\n            return;\n        }\n        finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\n        if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n    }\n}\nfunction maybeFreeze(scope, value, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */ function createProxyProxy(base, parent) {\n    var isArray = Array.isArray(base);\n    var state = {\n        type_: isArray ? 1 : 0,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned_: {},\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false\n    }; // the traps must target something, a bit like the 'real' base.\n    // but also, we need to be able to determine from the target what the relevant state is\n    // (to avoid creating traps per instance to capture the state in closure,\n    // and to avoid creating weird hidden properties as well)\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n    var target = state;\n    var traps = objectTraps;\n    if (isArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return proxy;\n}\n/**\r\n * Object drafts\r\n */ var objectTraps = {\n    get: function get(state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        var source = latest(state);\n        if (!has(source, prop)) {\n            // non-existing or non-own property...\n            return readPropFromProto(state, source, prop);\n        }\n        var value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        } // Check for existing draft in modified state.\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\n        }\n        return value;\n    },\n    has: function has(state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys: function ownKeys(state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set: function set(state, prop, value) {\n        var desc = getDescriptorFromProto(latest(state), prop);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // special case: if this write is captured by a setter, we have\n            // to trigger it with the correct context\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n            // from setting an existing property with value undefined to undefined (which is not a change)\n            var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\n            var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_[prop] = false;\n                return true;\n            }\n            if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && (value !== undefined || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore\n        state.copy_[prop] = value;\n        state.assigned_[prop] = true;\n        return true;\n    },\n    deleteProperty: function deleteProperty(state, prop) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\n            state.assigned_[prop] = false;\n            prepareCopy(state);\n            markChanged(state);\n        } else {\n            // if an originally not assigned property was deleted\n            delete state.assigned_[prop];\n        } // @ts-ignore\n        if (state.copy_) delete state.copy_[prop];\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n        var owner = latest(state);\n        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            writable: true,\n            configurable: state.type_ !== 1 || prop !== \"length\",\n            enumerable: desc.enumerable,\n            value: owner[prop]\n        };\n    },\n    defineProperty: function defineProperty() {\n        die(11);\n    },\n    getPrototypeOf: function getPrototypeOf(state) {\n        return Object.getPrototypeOf(state.base_);\n    },\n    setPrototypeOf: function setPrototypeOf() {\n        die(12);\n    }\n};\n/**\r\n * Array drafts\r\n */ var arrayTraps = {};\neach(objectTraps, function(key, fn) {\n    // @ts-ignore\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) die(13); // @ts-ignore\n    return arrayTraps.set.call(this, state, prop, undefined);\n};\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Access a property without creating an Immer draft.\nfunction peek(draft, prop) {\n    var state = draft[DRAFT_STATE];\n    var source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    var _desc$get;\n    var desc = getDescriptorFromProto(source, prop);\n    return desc ? \"value\" in desc ? desc.value : // prototype, we should invoke it with the draft as context!\n    (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\n}\nfunction getDescriptorFromProto(source, prop) {\n    // 'in' checks proto!\n    if (!(prop in source)) return undefined;\n    var proto = Object.getPrototypeOf(source);\n    while(proto){\n        var desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = Object.getPrototypeOf(proto);\n    }\n    return undefined;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.copy_ = shallowCopy(state.base_);\n    }\n}\nvar Immer = /*#__PURE__*/ function() {\n    var _s = $RefreshSig$();\n    function Immer(config) {\n        var _this = this;\n        this.useProxies_ = hasProxies;\n        this.autoFreeze_ = true;\n        /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */ this.produce = function(base, recipe, patchListener) {\n            // curried invocation\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                var defaultBase = recipe;\n                recipe = base;\n                var self = _this;\n                return function curriedProduce(base) {\n                    var _this2 = this;\n                    if (base === void 0) {\n                        base = defaultBase;\n                    }\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return self.produce(base, function(draft) {\n                        var _recipe;\n                        return (_recipe = recipe).call.apply(_recipe, [\n                            _this2,\n                            draft\n                        ].concat(args));\n                    }); // prettier-ignore\n                };\n            }\n            if (typeof recipe !== \"function\") die(6);\n            if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\n            var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n            if (isDraftable(base)) {\n                var scope = enterScope(_this);\n                var proxy = createProxy(_this, base, undefined);\n                var hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    // finally instead of catch + rethrow better preserves original stack\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                    var _s = $RefreshSig$();\n                    return result.then(_s(function(result) {\n                        _s();\n                        usePatchesInScope(scope, patchListener);\n                        return processResult(result, scope);\n                    }, \"9Yj2pJgE3VJ7jrpVNWdmlDuBWxo=\", false, function() {\n                        return [\n                            usePatchesInScope\n                        ];\n                    }), function(error) {\n                        revokeScope(scope);\n                        throw error;\n                    });\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || typeof base !== \"object\") {\n                result = recipe(base);\n                if (result === undefined) result = base;\n                if (result === NOTHING) result = undefined;\n                if (_this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    var p = [];\n                    var ip = [];\n                    getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(21, base);\n        };\n        this.produceWithPatches = function(base, recipe) {\n            // curried invocation\n            if (typeof base === \"function\") {\n                return function(state) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    return _this.produceWithPatches(state, function(draft) {\n                        return base.apply(void 0, [\n                            draft\n                        ].concat(args));\n                    });\n                };\n            }\n            var patches, inversePatches;\n            var result = _this.produce(base, recipe, function(p, ip) {\n                patches = p;\n                inversePatches = ip;\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then(function(nextState) {\n                    return [\n                        nextState,\n                        patches,\n                        inversePatches\n                    ];\n                });\n            }\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\n        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    }\n    var _proto = Immer.prototype;\n    _proto.createDraft = function createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        var scope = enterScope(this);\n        var proxy = createProxy(this, base, undefined);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    };\n    _proto.finishDraft = _s(function finishDraft(draft, patchListener) {\n        _s();\n        var state = draft && draft[DRAFT_STATE];\n        {\n            if (!state || !state.isManual_) die(9);\n            if (state.finalized_) die(10);\n        }\n        var scope = state.scope_;\n        usePatchesInScope(scope, patchListener);\n        return processResult(undefined, scope);\n    } /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */ , \"9Yj2pJgE3VJ7jrpVNWdmlDuBWxo=\", false, function() {\n        return [\n            usePatchesInScope\n        ];\n    });\n    _proto.setAutoFreeze = function setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    } /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */ ;\n    _proto.setUseProxies = function setUseProxies(value) {\n        if (value && !hasProxies) {\n            die(20);\n        }\n        this.useProxies_ = value;\n    };\n    _proto.applyPatches = function applyPatches(base, patches) {\n        // If a patch replaces the entire state, take that replacement as base\n        // before applying patches\n        var i;\n        for(i = patches.length - 1; i >= 0; i--){\n            var patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        } // If there was a patch that replaced the entire state, start from the\n        // patch after that.\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n        if (isDraft(base)) {\n            // N.B: never hits if some patch a replacement, patches are never drafts\n            return applyPatchesImpl(base, patches);\n        } // Otherwise, produce a copy of the base state.\n        return this.produce(base, function(draft) {\n            return applyPatchesImpl(draft, patches);\n        });\n    };\n    return Immer;\n}();\nfunction createProxy(immer, value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\n    var scope = parent ? parent.scope_ : getCurrentScope();\n    scope.drafts_.push(draft);\n    return draft;\n}\nfunction current(value) {\n    if (!isDraft(value)) die(22, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value)) return value;\n    var state = value[DRAFT_STATE];\n    var copy;\n    var archType = getArchtype(value);\n    if (state) {\n        if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\n        state.finalized_ = true;\n        copy = copyHelper(value, archType);\n        state.finalized_ = false;\n    } else {\n        copy = copyHelper(value, archType);\n    }\n    each(copy, function(key, childValue) {\n        if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\n        set(copy, key, currentImpl(childValue));\n    }); // In the future, we might consider freezing here, based on the current settings\n    return archType === 3 ? new Set(copy) : copy;\n}\nfunction copyHelper(value, archType) {\n    // creates a shallow copy, even if it is a map or set\n    switch(archType){\n        case 2:\n            return new Map(value);\n        case 3:\n            // Set will be cloned as array temporarily, so that we can replace individual items\n            return Array.from(value);\n    }\n    return shallowCopy(value);\n}\nfunction enableES5() {\n    function willFinalizeES5_(scope, result, isReplaced) {\n        if (!isReplaced) {\n            if (scope.patches_) {\n                markChangesRecursively(scope.drafts_[0]);\n            } // This is faster when we don't care about which attributes changed.\n            markChangesSweep(scope.drafts_);\n        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\n            markChangesSweep(scope.drafts_);\n        }\n    }\n    function createES5Draft(isArray, base) {\n        if (isArray) {\n            var draft = new Array(base.length);\n            for(var i = 0; i < base.length; i++){\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\n            }\n            return draft;\n        } else {\n            var _descriptors = getOwnPropertyDescriptors(base);\n            delete _descriptors[DRAFT_STATE];\n            var keys = ownKeys(_descriptors);\n            for(var _i = 0; _i < keys.length; _i++){\n                var key = keys[_i];\n                _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\n            }\n            return Object.create(Object.getPrototypeOf(base), _descriptors);\n        }\n    }\n    function createES5Proxy_(base, parent) {\n        var isArray = Array.isArray(base);\n        var draft = createES5Draft(isArray, base);\n        var state = {\n            type_: isArray ? 5 : 4,\n            scope_: parent ? parent.scope_ : getCurrentScope(),\n            modified_: false,\n            finalized_: false,\n            assigned_: {},\n            parent_: parent,\n            // base is the object we are drafting\n            base_: base,\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n            draft_: draft,\n            copy_: null,\n            revoked_: false,\n            isManual_: false\n        };\n        Object.defineProperty(draft, DRAFT_STATE, {\n            value: state,\n            // enumerable: false <- the default\n            writable: true\n        });\n        return draft;\n    } // property descriptors are recycled to make sure we don't create a get and set closure per property,\n    // but share them all instead\n    var descriptors = {};\n    function proxyProperty(prop, enumerable) {\n        var desc = descriptors[prop];\n        if (desc) {\n            desc.enumerable = enumerable;\n        } else {\n            descriptors[prop] = desc = {\n                configurable: true,\n                enumerable: enumerable,\n                get: function get() {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    return objectTraps.get(state, prop);\n                },\n                set: function set(value) {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    objectTraps.set(state, prop, value);\n                }\n            };\n        }\n        return desc;\n    } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n    function markChangesSweep(drafts) {\n        // The natural order of drafts in the `scope` array is based on when they\n        // were accessed. By processing drafts in reverse natural order, we have a\n        // better chance of processing leaf nodes first. When a leaf node is known to\n        // have changed, we can avoid any traversal of its ancestor nodes.\n        for(var i = drafts.length - 1; i >= 0; i--){\n            var state = drafts[i][DRAFT_STATE];\n            if (!state.modified_) {\n                switch(state.type_){\n                    case 5:\n                        if (hasArrayChanges(state)) markChanged(state);\n                        break;\n                    case 4:\n                        if (hasObjectChanges(state)) markChanged(state);\n                        break;\n                }\n            }\n        }\n    }\n    function markChangesRecursively(object) {\n        if (!object || typeof object !== \"object\") return;\n        var state = object[DRAFT_STATE];\n        if (!state) return;\n        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;\n        if (type_ === 4) {\n            // Look for added keys.\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n            // unnecessary work.\n            // also: probably we can store the information we detect here, to speed up tree finalization!\n            each(draft_, function(key) {\n                if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\n                if (base_[key] === undefined && !has(base_, key)) {\n                    assigned_[key] = true;\n                    markChanged(state);\n                } else if (!assigned_[key]) {\n                    // Only untouched properties trigger recursion.\n                    markChangesRecursively(draft_[key]);\n                }\n            }); // Look for removed keys.\n            each(base_, function(key) {\n                // The `undefined` check is a fast path for pre-existing keys.\n                if (draft_[key] === undefined && !has(draft_, key)) {\n                    assigned_[key] = false;\n                    markChanged(state);\n                }\n            });\n        } else if (type_ === 5) {\n            if (hasArrayChanges(state)) {\n                markChanged(state);\n                assigned_.length = true;\n            }\n            if (draft_.length < base_.length) {\n                for(var i = draft_.length; i < base_.length; i++){\n                    assigned_[i] = false;\n                }\n            } else {\n                for(var _i2 = base_.length; _i2 < draft_.length; _i2++){\n                    assigned_[_i2] = true;\n                }\n            } // Minimum count is enough, the other parts has been processed.\n            var min = Math.min(draft_.length, base_.length);\n            for(var _i3 = 0; _i3 < min; _i3++){\n                // Only untouched indices trigger recursion.\n                if (!draft_.hasOwnProperty(_i3)) {\n                    assigned_[_i3] = true;\n                }\n                if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\n            }\n        }\n    }\n    function hasObjectChanges(state) {\n        var base_ = state.base_, draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\n        // non-numeric keys are ordered by time of definition on the object.\n        var keys = ownKeys(draft_);\n        for(var i = keys.length - 1; i >= 0; i--){\n            var key = keys[i];\n            if (key === DRAFT_STATE) continue;\n            var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\n            if (baseValue === undefined && !has(base_, key)) {\n                return true;\n            } else {\n                var value = draft_[key];\n                var _state = value && value[DRAFT_STATE];\n                if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\n                    return true;\n                }\n            }\n        } // At this point, no keys were added or changed.\n        // Compare key count to determine if keys were deleted.\n        var baseIsDraft = !!base_[DRAFT_STATE];\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\n    }\n    function hasArrayChanges(state) {\n        var draft_ = state.draft_;\n        if (draft_.length !== state.base_.length) return true; // See #116\n        // If we first shorten the length, our array interceptors will be removed.\n        // If after that new items are added, result in the same original length,\n        // those last items will have no intercepting property.\n        // So if there is no own descriptor on the last position, we know that items were removed and added\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n        // the last one\n        // last descriptor can be not a trap, if the array was extended\n        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n        if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\n        for(var i = 0; i < draft_.length; i++){\n            if (!draft_.hasOwnProperty(i)) return true;\n        } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n        return false;\n    }\n    function hasChanges_(state) {\n        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"ES5\", {\n        createES5Proxy_: createES5Proxy_,\n        willFinalizeES5_: willFinalizeES5_,\n        hasChanges_: hasChanges_\n    });\n}\nfunction enablePatches() {\n    var REPLACE = \"replace\";\n    var ADD = \"add\";\n    var REMOVE = \"remove\";\n    function generatePatches_(state, basePath, patches, inversePatches) {\n        switch(state.type_){\n            case 0:\n            case 4:\n            case 2:\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n            case 5:\n            case 1:\n                return generateArrayPatches(state, basePath, patches, inversePatches);\n            case 3:\n                return generateSetPatches(state, basePath, patches, inversePatches);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, assigned_ = state.assigned_;\n        var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\n        if (copy_.length < base_.length) {\n            var _ref = [\n                copy_,\n                base_\n            ];\n            base_ = _ref[0];\n            copy_ = _ref[1];\n            var _ref2 = [\n                inversePatches,\n                patches\n            ];\n            patches = _ref2[0];\n            inversePatches = _ref2[1];\n        } // Process replaced indices.\n        for(var i = 0; i < base_.length; i++){\n            if (assigned_[i] && copy_[i] !== base_[i]) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path: path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copy_[i])\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path: path,\n                    value: clonePatchValueIfNeeded(base_[i])\n                });\n            }\n        } // Process added indices.\n        for(var _i = base_.length; _i < copy_.length; _i++){\n            var _path = basePath.concat([\n                _i\n            ]);\n            patches.push({\n                op: ADD,\n                path: _path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[_i])\n            });\n        }\n        if (base_.length < copy_.length) {\n            inversePatches.push({\n                op: REPLACE,\n                path: basePath.concat([\n                    \"length\"\n                ]),\n                value: base_.length\n            });\n        }\n    } // This is used for both Map objects and normal objects.\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        each(state.assigned_, function(key, assignedValue) {\n            var origValue = get(base_, key);\n            var value = get(copy_, key);\n            var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            var path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op: op,\n                path: path\n            } : {\n                op: op,\n                path: path,\n                value: value\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path: path\n            } : op === REMOVE ? {\n                op: ADD,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        var i = 0;\n        base_.forEach(function(value) {\n            if (!copy_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach(function(value) {\n            if (!base_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n        patches.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? undefined : replacement\n        });\n        inversePatches.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach(function(patch) {\n            var path = patch.path, op = patch.op;\n            var base = draft;\n            for(var i = 0; i < path.length - 1; i++){\n                var parentType = getArchtype(base);\n                var p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                } // See #738, avoid prototype pollution\n                if ((parentType === 0 || parentType === 1) && (p === \"__proto__\" || p === \"constructor\")) die(24);\n                if (typeof base === \"function\" && p === \"prototype\") die(24);\n                base = get(base, p);\n                if (typeof base !== \"object\") die(15, path.join(\"/\"));\n            }\n            var type = getArchtype(base);\n            var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n            var key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2:\n                            return base.set(key, value);\n                        /* istanbul ignore next */ case 3:\n                            die(16);\n                        default:\n                            // if value is an object, then it's assigned by reference\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\n                            // so we use value from the cloned patch\n                            // @ts-ignore\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1:\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2:\n                            return base.set(key, value);\n                        case 3:\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1:\n                            return base.splice(key, 1);\n                        case 2:\n                            return base.delete(key);\n                        case 3:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(17, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function(_ref3) {\n            var k = _ref3[0], v = _ref3[1];\n            return [\n                k,\n                deepClonePatchValue(v)\n            ];\n        }));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        var cloned = Object.create(Object.getPrototypeOf(obj));\n        for(var key in obj){\n            cloned[key] = deepClonePatchValue(obj[key]);\n        }\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(\"Patches\", {\n        applyPatches_: applyPatches_,\n        generatePatches_: generatePatches_,\n        generateReplacementPatches_: generateReplacementPatches_\n    });\n}\n// types only!\nfunction enableMapSet() {\n    /* istanbul ignore next */ var _extendStatics = function extendStatics(d, b) {\n        _extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b){\n                if (b.hasOwnProperty(p)) d[p] = b[p];\n            }\n        };\n        return _extendStatics(d, b);\n    }; // Ugly hack to resolve #502 and inherit built in Map / Set\n    function __extends(d, b) {\n        _extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = (__.prototype = b.prototype, new __());\n    }\n    var DraftMap = function(_super) {\n        __extends(DraftMap, _super); // Create class manually, cause #502\n        function DraftMap(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 2,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                assigned_: undefined,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false\n            };\n            return this;\n        }\n        var p = DraftMap.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: false,\n        });\n        p.has = function(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        };\n        p.set = function(key, value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        };\n        p.delete = function(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = new Map();\n                each(state.base_, function(key) {\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        };\n        p.forEach = function(cb, thisArg) {\n            var _this = this;\n            var state = this[DRAFT_STATE];\n            latest(state).forEach(function(_value, key, _map) {\n                cb.call(thisArg, _this.get(key), key, _this);\n            });\n        };\n        p.get = function(key) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            var value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value; // either already drafted or reassigned\n            } // despite what it looks, this creates a draft only once, see above condition\n            var draft = createProxy(state.scope_.immer_, value, state);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        };\n        p.keys = function() {\n            return latest(this[DRAFT_STATE]).keys();\n        };\n        p.values = function() {\n            var _this2 = this, _ref;\n            var iterator = this.keys();\n            return _ref = {}, _ref[iteratorSymbol] = function() {\n                return _this2.values();\n            }, _ref.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this2.get(r.value);\n                return {\n                    done: false,\n                    value: value\n                };\n            }, _ref;\n        };\n        p.entries = function() {\n            var _this3 = this, _ref2;\n            var iterator = this.keys();\n            return _ref2 = {}, _ref2[iteratorSymbol] = function() {\n                return _this3.entries();\n            }, _ref2.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this3.get(r.value);\n                return {\n                    done: false,\n                    value: [\n                        r.value,\n                        value\n                    ]\n                };\n            }, _ref2;\n        };\n        p[iteratorSymbol] = function() {\n            return this.entries();\n        };\n        return DraftMap;\n    }(Map);\n    function proxyMap_(target, parent) {\n        // @ts-ignore\n        return new DraftMap(target, parent);\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    var DraftSet = function(_super) {\n        __extends(DraftSet, _super); // Create class manually, cause #502\n        function DraftSet(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 3,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                base_: target,\n                draft_: this,\n                drafts_: new Map(),\n                revoked_: false,\n                isManual_: false\n            };\n            return this;\n        }\n        var p = DraftSet.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: true,\n        });\n        p.has = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        };\n        p.add = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        };\n        p.delete = function(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        };\n        p.values = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        };\n        p.entries = function entries() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        };\n        p.keys = function() {\n            return this.values();\n        };\n        p[iteratorSymbol] = function() {\n            return this.values();\n        };\n        p.forEach = function forEach(cb, thisArg) {\n            var iterator = this.values();\n            var result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        };\n        return DraftSet;\n    }(Set);\n    function proxySet_(target, parent) {\n        // @ts-ignore\n        return new DraftSet(target, parent);\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            // create drafts for all entries to preserve insertion order\n            state.copy_ = new Set();\n            state.base_.forEach(function(value) {\n                if (isDraftable(value)) {\n                    var draft = createProxy(state.scope_.immer_, value, state);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"MapSet\", {\n        proxyMap_: proxyMap_,\n        proxySet_: proxySet_\n    });\n}\nfunction enableAllPlugins() {\n    enableES5();\n    enableMapSet();\n    enablePatches();\n}\nvar immer = /*#__PURE__*/ new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */ var produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */ var produceWithPatches = /*#__PURE__*/ immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */ var setAutoFreeze = /*#__PURE__*/ immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */ var setUseProxies = /*#__PURE__*/ immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */ var applyPatches = /*#__PURE__*/ immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */ var createDraft = /*#__PURE__*/ immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */ var finishDraft = /*#__PURE__*/ immer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */ function castDraft(value) {\n    return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */ function castImmutable(value) {\n    return value;\n}\nexports.Immer = Immer;\nexports.applyPatches = applyPatches;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.createDraft = createDraft;\nexports.current = current;\nexports[\"default\"] = produce;\nexports.enableAllPlugins = enableAllPlugins;\nexports.enableES5 = enableES5;\nexports.enableMapSet = enableMapSet;\nexports.enablePatches = enablePatches;\nexports.finishDraft = finishDraft;\nexports.freeze = freeze;\nexports.immerable = DRAFTABLE;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.nothing = NOTHING;\nexports.original = original;\nexports.produce = produce;\nexports.produceWithPatches = produceWithPatches;\nexports.setAutoFreeze = setAutoFreeze;\nexports.setUseProxies = setUseProxies; //# sourceMappingURL=immer.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQztBQUVKLDZCQUE2QjtBQUM3QiwwREFBMEQ7QUFDMUQsK0RBQStEO0FBQy9ELElBQUlDLFlBQVksT0FBT0MsV0FBVyxlQUFlLE9BQ2pELFdBQVcsR0FDWEEsT0FBTyxTQUFTO0FBQ2hCLElBQUlDLFNBQVMsT0FBT0MsUUFBUTtBQUM1QixJQUFJQyxTQUFTLE9BQU9DLFFBQVE7QUFDNUIsSUFBSUMsYUFBYSxPQUFPQyxVQUFVLGVBQWUsT0FBT0EsTUFBTUMsU0FBUyxLQUFLLGVBQWUsT0FBT0MsWUFBWTtBQUM5Rzs7Q0FFQyxHQUVELElBQUlDLFVBQVVWLFlBQ2QsV0FBVyxHQUNYQyxPQUFPVSxHQUFHLENBQUMsbUJBQW9CWixDQUFBQSxPQUFPLENBQUMsR0FBR0EsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE1BQU1BLElBQUc7QUFDM0U7Ozs7Ozs7Q0FPQyxHQUVELElBQUlhLFlBQVlaLFlBQ2hCLFdBQVcsR0FDWEMsT0FBT1UsR0FBRyxDQUFDLHFCQUFxQjtBQUNoQyxJQUFJRSxjQUFjYixZQUNsQixXQUFXLEdBQ1hDLE9BQU9VLEdBQUcsQ0FBQyxpQkFBaUIsa0JBQWtCLHlEQUF5RDtBQUV2RyxJQUFJRyxpQkFBaUIsT0FBT2IsVUFBVSxlQUFlQSxPQUFPYyxRQUFRLElBQUk7QUFFeEUsSUFBSUMsU0FBUztJQUNYLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUcsU0FBU0MsRUFBRUMsSUFBSTtRQUNoQixPQUFPLHlIQUF5SEE7SUFDbEk7SUFDQSxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFD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dEJqTixlQUFlLEdBQUc0SztBQUNsQjVLLGtCQUFlLEdBQUcwTDtBQUNsQjFMLHdCQUF3QixHQUFHd1M7QUFDM0J4UyxpQkFBaUIsR0FBR2lPO0FBQ3BCak8sb0JBQW9CLEdBQUdpUjtBQUN2QmpSLHFCQUFxQixHQUFHdVA7QUFDeEJ2UCxtQkFBbUIsR0FBR2tOO0FBQ3RCbE4sY0FBYyxHQUFHbUc7QUFDakJuRyxpQkFBaUIsR0FBR2U7QUFDcEJmLGVBQWUsR0FBR3NDO0FBQ2xCdEMsbUJBQW1CLEdBQUd1QztBQUN0QnZDLGVBQWUsR0FBR2E7QUFDbEJiLGdCQUFnQixHQUFHdUQ7QUFDbkJ2RCxlQUFlLEdBQUcwTDtBQUNsQjFMLDBCQUEwQixHQUFHc007QUFDN0J0TSxxQkFBcUIsR0FBRytNO0FBQ3hCL00scUJBQXFCLEdBQUc2TSxlQUN4QixpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIuY2pzLmRldmVsb3BtZW50LmpzPzlhOTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX3JlZjtcblxuLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcbi8vIFNvbWUgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGV2YWx1YXRlZCBiZWZvcmUgYWxsIGVsc2UuLi5cbi8vIFdlIG9ubHkgd2FudCB0byBrbm93IGlmIG5vbi1wb2x5ZmlsbGVkIHN5bWJvbHMgYXJlIGF2YWlsYWJsZVxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mXG4vKiNfX1BVUkVfXyovXG5TeW1ib2woXCJ4XCIpID09PSBcInN5bWJvbFwiO1xudmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXNQcm94aWVzID0gdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBQcm94eS5yZXZvY2FibGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCI7XG4vKipcclxuICogVGhlIHNlbnRpbmVsIHZhbHVlIHJldHVybmVkIGJ5IHByb2R1Y2VycyB0byByZXBsYWNlIHRoZSBkcmFmdCB3aXRoIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBOT1RISU5HID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpIDogKF9yZWYgPSB7fSwgX3JlZltcImltbWVyLW5vdGhpbmdcIl0gPSB0cnVlLCBfcmVmKTtcbi8qKlxyXG4gKiBUbyBsZXQgSW1tZXIgdHJlYXQgeW91ciBjbGFzcyBpbnN0YW5jZXMgYXMgcGxhaW4gaW1tdXRhYmxlIG9iamVjdHNcclxuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcclxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxyXG4gKlxyXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxyXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXHJcbiAqL1xuXG52YXIgRFJBRlRBQkxFID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIikgOiBcIl9fJGltbWVyX2RyYWZ0YWJsZVwiO1xudmFyIERSQUZUX1NUQVRFID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKSA6IFwiX18kaW1tZXJfc3RhdGVcIjsgLy8gRXZlbiBhIHBvbHlmaWxsZWQgU3ltYm9sIG1pZ2h0IHByb3ZpZGUgU3ltYm9sLml0ZXJhdG9yXG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbnZhciBlcnJvcnMgPSB7XG4gIDA6IFwiSWxsZWdhbCBzdGF0ZVwiLFxuICAxOiBcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIsXG4gIDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcbiAgMzogZnVuY3Rpb24gXyhkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIDQ6IFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgNTogXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgNjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgNzogXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgODogXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICAxMDogXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIixcbiAgMTE6IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgMTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgMTM6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG4gIDE0OiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgMTU6IGZ1bmN0aW9uIF8ocGF0aCkge1xuICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aDtcbiAgfSxcbiAgMTY6ICdTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJyxcbiAgMTc6IGZ1bmN0aW9uIF8ob3ApIHtcbiAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gIH0sXG4gIDE4OiBmdW5jdGlvbiBfKHBsdWdpbikge1xuICAgIHJldHVybiBcIlRoZSBwbHVnaW4gZm9yICdcIiArIHBsdWdpbiArIFwiJyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgYGVuYWJsZVwiICsgcGx1Z2luICsgXCIoKWAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5cIjtcbiAgfSxcbiAgMjA6IFwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLFxuICAyMTogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiICsgdGhpbmcgKyBcIidcIjtcbiAgfSxcbiAgMjI6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCInY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiICsgdGhpbmc7XG4gIH0sXG4gIDIzOiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIgKyB0aGluZztcbiAgfSxcbiAgMjQ6IFwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwiXG59O1xuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgZSA9IGVycm9yc1tlcnJvcl07XG4gICAgdmFyIG1zZyA9ICFlID8gXCJ1bmtub3duIGVycm9yIG5yOiBcIiArIGVycm9yIDogdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xuICAgIHRocm93IG5ldyBFcnJvcihcIltJbW1lcl0gXCIgKyBtc2cpO1xuICB9XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEltbWVyIGRyYWZ0ICovXG5cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG5cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcbiAgdmFyIF92YWx1ZSRjb25zdHJ1Y3RvcjtcblxuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISEoKF92YWx1ZSRjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfdmFsdWUkY29uc3RydWN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92YWx1ZSRjb25zdHJ1Y3RvcltEUkFGVEFCTEVdKSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xufVxudmFyIG9iamVjdEN0b3JTdHJpbmcgPVxuLyojX19QVVJFX18qL1xuT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgQ3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICBpZiAoQ3RvciA9PT0gT2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDIzLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG4vKiNfX1BVUkVfXyovXG5cbnZhciBvd25LZXlzID0gdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5vd25LZXlzID8gUmVmbGVjdC5vd25LZXlzIDogdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGFyZ2V0KSB7XG4gIC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuICB2YXIgcmVzID0ge307XG4gIG93bktleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXNba2V5XSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgZW51bWVyYWJsZU9ubHkpIHtcbiAgaWYgKGVudW1lcmFibGVPbmx5ID09PSB2b2lkIDApIHtcbiAgICBlbnVtZXJhYmxlT25seSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IDBcbiAgLyogT2JqZWN0ICovXG4gICkge1xuICAgICAgKGVudW1lcmFibGVPbmx5ID8gT2JqZWN0LmtleXMgOiBvd25LZXlzKShvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWVudW1lcmFibGVPbmx5IHx8IHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIpIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopO1xuICAgIH0pO1xuICB9XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciBzdGF0ZSA9IHRoaW5nW0RSQUZUX1NUQVRFXTtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUudHlwZV8gPiAzID8gc3RhdGUudHlwZV8gLSA0IC8vIGNhdXNlIE9iamVjdCBhbmQgQXJyYXkgbWFwIGJhY2sgZnJvbSA0IGFuZCA1XG4gIDogc3RhdGUudHlwZV8gLy8gb3RoZXJzIGFyZSB0aGUgc2FtZVxuICA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMVxuICAvKiBBcnJheSAqL1xuICA6IGlzTWFwKHRoaW5nKSA/IDJcbiAgLyogTWFwICovXG4gIDogaXNTZXQodGhpbmcpID8gM1xuICAvKiBTZXQgKi9cbiAgOiAwXG4gIC8qIE9iamVjdCAqL1xuICA7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyXG4gIC8qIE1hcCAqL1xuICA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGdldCh0aGluZywgcHJvcCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcbiAgLyogTWFwICovXG4gID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XG4gIHZhciB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpO1xuICBpZiAodCA9PT0gMlxuICAvKiBNYXAgKi9cbiAgKSB0aGluZy5zZXQocHJvcE9yT2xkVmFsdWUsIHZhbHVlKTtlbHNlIGlmICh0ID09PSAzXG4gIC8qIFNldCAqL1xuICApIHtcbiAgICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xuICByZXR1cm4gaGFzTWFwICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hcDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG4gIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gIHZhciBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuXG4gICAgaWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICB9IC8vIGxpa2Ugb2JqZWN0LmFzc2lnbiwgd2Ugd2lsbCByZWFkIGFueSBfb3duXywgZ2V0L3NldCBhY2Nlc3NvcnMuIFRoaXMgaGVscHMgaW4gZGVhbGluZ1xuICAgIC8vIHdpdGggbGlicmFyaWVzIHRoYXQgdHJhcCB2YWx1ZXMsIGxpa2UgbW9ieCBvciB2dWVcbiAgICAvLyB1bmxpa2Ugb2JqZWN0LmFzc2lnbiwgbm9uLWVudW1lcmFibGVzIHdpbGwgYmUgY29waWVkIGFzIHdlbGxcblxuXG4gICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuXG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMVxuICAvKiBNYXAgb3IgU2V0ICovXG4gICkge1xuICAgICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICAgIH1cblxuICBPYmplY3QuZnJlZXplKG9iaik7XG4gIGlmIChkZWVwKSBlYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnJlZXplKHZhbHVlLCB0cnVlKTtcbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcbiAgZGllKDIpO1xufVxuXG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiB0cnVlOyAvLyBTZWUgIzYwMCwgSUUgZGllcyBvbiBub24tb2JqZWN0cyBpbiBPYmplY3QuaXNGcm96ZW5cblxuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbi8qKiBQbHVnaW4gdXRpbGl0aWVzICovXG5cbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIHZhciBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XG5cbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMTgsIHBsdWdpbktleSk7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xuICBpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbnZhciBjdXJyZW50U2NvcGU7XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIGlmICggIWN1cnJlbnRTY29wZSkgZGllKDApO1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZShwYXJlbnRfLCBpbW1lcl8pIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfOiBwYXJlbnRfLFxuICAgIGltbWVyXzogaW1tZXJfLFxuICAgIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuICAgIGNhbkF1dG9GcmVlemVfOiB0cnVlLFxuICAgIHVuZmluYWxpemVkRHJhZnRzXzogMFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7IC8vIGFzc2VydCB3ZSBoYXZlIHRoZSBwbHVnaW5cblxuICAgIHNjb3BlLnBhdGNoZXNfID0gW107XG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiByZXZva2VTY29wZShzY29wZSkge1xuICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTsgLy8gQHRzLWlnbm9yZVxuXG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIpO1xufVxuXG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMFxuICAvKiBQcm94eU9iamVjdCAqL1xuICB8fCBzdGF0ZS50eXBlXyA9PT0gMVxuICAvKiBQcm94eUFycmF5ICovXG4gICkgc3RhdGUucmV2b2tlXygpO2Vsc2Ugc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcbiAgc2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGg7XG4gIHZhciBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICB2YXIgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpZiAoIXNjb3BlLmltbWVyXy51c2VQcm94aWVzXykgZ2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCk7XG5cbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgIGRpZSg0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuICAgICAgLy8gRmluYWxpemUgdGhlIHJlc3VsdCBpbiBjYXNlIGl0IGNvbnRhaW5zIChvciBpcykgYSBzdWJzZXQgb2YgdGhlIGRyYWZ0LlxuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgICBpZiAoIXNjb3BlLnBhcmVudF8pIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXywgcmVzdWx0LCBzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluYWxpemUgdGhlIGJhc2UgZHJhZnQuXG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG5cbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuXG4gIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xuICAvLyBEb24ndCByZWN1cnNlIGluIHRobyByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzXG4gIGlmIChpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdOyAvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgfSwgdHJ1ZSAvLyBTZWUgIzU5MCwgZG9uJ3QgcmVjdXJzZSBpbnRvIG5vbi1lbnVtZXJhYmxlIG9mIG5vbiBkcmFmdGVkIG9iamVjdHNcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSAvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblxuXG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSkgcmV0dXJuIHZhbHVlOyAvLyBVbm1vZGlmaWVkIGRyYWZ0LCByZXR1cm4gdGhlIChmcm96ZW4pIG9yaWdpbmFsXG5cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH0gLy8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cblxuICBpZiAoIXN0YXRlLmZpbmFsaXplZF8pIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XG4gICAgdmFyIHJlc3VsdCA9IC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cbiAgICBzdGF0ZS50eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgIHx8IHN0YXRlLnR5cGVfID09PSA1XG4gICAgLyogRVM1QXJyYXkgKi9cbiAgICA/IHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuZHJhZnRfKSA6IHN0YXRlLmNvcHlfOyAvLyBGaW5hbGl6ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvcHlcbiAgICAvLyBGb3Igc2V0cyB3ZSBjbG9uZSBiZWZvcmUgaXRlcmF0aW5nLCBvdGhlcndpc2Ugd2UgY2FuIGdldCBpbiBlbmRsZXNzIGxvb3AgZHVlIHRvIG1vZGlmeWluZyBkdXJpbmcgaXRlcmF0aW9uLCBzZWUgIzYyOFxuICAgIC8vIFRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBpbiBhbGwgY2FzZXMgd2UgdGhlbiBjbGVhciB0aGUgc2V0XG4gICAgLy8gQW5kIHdlIGxldCBmaW5hbGl6ZVByb3BlcnR5IGtub3cgaXQgbmVlZHMgdG8gcmUtYWRkIG5vbi1kcmFmdCBjaGlsZHJlbiBiYWNrIHRvIHRoZSB0YXJnZXRcblxuICAgIHZhciByZXN1bHRFYWNoID0gcmVzdWx0O1xuICAgIHZhciBpc1NldCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzXG4gICAgLyogU2V0ICovXG4gICAgKSB7XG4gICAgICAgIHJlc3VsdEVhY2ggPSBuZXcgU2V0KHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgICBpc1NldCA9IHRydWU7XG4gICAgICB9XG5cbiAgICBlYWNoKHJlc3VsdEVhY2gsIGZ1bmN0aW9uIChrZXksIGNoaWxkVmFsdWUpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldCk7XG4gICAgfSk7IC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXG5cbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpOyAvLyBmaXJzdCB0aW1lIGZpbmFsaXppbmcsIGxldCdzIGNyZWF0ZSB0aG9zZSBwYXRjaGVzXG5cbiAgICBpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgcGF0aCwgcm9vdFNjb3BlLnBhdGNoZXNfLCByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcbiAgaWYgKCBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpIGRpZSg1KTtcblxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIHZhciBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDNcbiAgICAvKiBTZXQgKi9cbiAgICAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxuICAgICFoYXMocGFyZW50U3RhdGUuYXNzaWduZWRfLCBwcm9wKSAvLyBTa2lwIGRlZXAgcGF0Y2hlcyBmb3IgYXNzaWduZWQga2V5cy5cbiAgICA/IHJvb3RQYXRoLmNvbmNhdChwcm9wKSA6IHVuZGVmaW5lZDsgLy8gRHJhZnRzIG93bmVkIGJ5IGBzY29wZWAgYXJlIGZpbmFsaXplZCBoZXJlLlxuXG4gICAgdmFyIHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTsgLy8gRHJhZnRzIGZyb20gYW5vdGhlciBzY29wZSBtdXN0IHByZXZlbnRlZCB0byBiZSBmcm96ZW5cbiAgICAvLyBpZiB3ZSBnb3QgYSBkcmFmdCBiYWNrIGZyb20gZmluYWxpemUsIHdlJ3JlIGluIGEgbmVzdGVkIHByb2R1Y2UgYW5kIHNob3VsZG4ndCBmcmVlemVcblxuICAgIGlmIChpc0RyYWZ0KHJlcykpIHtcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xuICAgIH0gZWxzZSByZXR1cm47XG4gIH0gZWxzZSBpZiAodGFyZ2V0SXNTZXQpIHtcbiAgICB0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpO1xuICB9IC8vIFNlYXJjaCBuZXcgb2JqZWN0cyBmb3IgdW5maW5hbGl6ZWQgZHJhZnRzLiBGcm96ZW4gb2JqZWN0cyBzaG91bGQgbmV2ZXIgY29udGFpbiBkcmFmdHMuXG5cblxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG4gICAgaWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG4gICAgICAvLyBvcHRpbWl6YXRpb246IGlmIGFuIG9iamVjdCBpcyBub3QgYSBkcmFmdCwgYW5kIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIGRlZXBmcmVlemUgZXZlcnl0aGluZywgYW5kIHdlIGFyZSBzdXJlIHRoYXQgbm8gZHJhZnRzIGFyZSBsZWZ0IGluIHRoZSByZW1haW5pbmcgb2JqZWN0XG4gICAgICAvLyBjYXVzZSB3ZSBzYXcgYW5kIGZpbmFsaXplZCBhbGwgZHJhZnRzIGFscmVhZHk7IHdlIGNhbiBzdG9wIHZpc2l0aW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICAgICAgLy8gVGhpcyBiZW5lZml0cyBlc3BlY2lhbGx5IGFkZGluZyBsYXJnZSBkYXRhIHRyZWUncyB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgIC8vIFNlZSBhZGQtZGF0YS5qcyBwZXJmIHRlc3RcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpOyAvLyBpbW1lciBkZWVwIGZyZWV6ZXMgcGxhaW4gb2JqZWN0cywgc28gaWYgdGhlcmUgaXMgbm8gcGFyZW50IHN0YXRlLCB3ZSBmcmVlemUgYXMgd2VsbFxuXG4gICAgaWYgKCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGUsIHZhbHVlLCBkZWVwKSB7XG4gIGlmIChkZWVwID09PSB2b2lkIDApIHtcbiAgICBkZWVwID0gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSBuZXZlciBmcmVlemUgZm9yIGEgbm9uLXJvb3Qgc2NvcGU7IGFzIGl0IHdvdWxkIHByZXZlbnQgcHJ1bmluZyBmb3IgZHJhZnRzIGluc2lkZSB3cmFwcGluZyBvYmplY3RzXG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGRyYWZ0IG9mIHRoZSBgYmFzZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBwYXJlbnQgZHJhZnQtc3RhdGUgKHVzZWQgaW50ZXJuYWxseSkuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0eXBlXzogaXNBcnJheSA/IDFcbiAgICAvKiBQcm94eUFycmF5ICovXG4gICAgOiAwXG4gICAgLyogUHJveHlPYmplY3QgKi9cbiAgICAsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgYXNzaWduZWRfOiB7fSxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2VcbiAgfTsgLy8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG4gIC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuICAvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG4gIC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuICAvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG4gIC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblxuICB2YXIgdGFyZ2V0ID0gc3RhdGU7XG4gIHZhciB0cmFwcyA9IG9iamVjdFRyYXBzO1xuXG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cblxuICB2YXIgX1Byb3h5JHJldm9jYWJsZSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKSxcbiAgICAgIHJldm9rZSA9IF9Qcm94eSRyZXZvY2FibGUucmV2b2tlLFxuICAgICAgcHJveHkgPSBfUHJveHkkcmV2b2NhYmxlLnByb3h5O1xuXG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG4vKipcclxuICogT2JqZWN0IGRyYWZ0c1xyXG4gKi9cblxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlO1xuICAgIHZhciBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuXG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuICAgICAgLy8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cbiAgICAgIHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG4gICAgLy8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cblxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXM6IGZ1bmN0aW9uIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSwgcHJvcFxuICAvKiBzdHJpY3RseSBub3QsIGJ1dCBoZWxwcyBUUyAqL1xuICAsIHZhbHVlKSB7XG4gICAgdmFyIGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuXG4gICAgaWYgKGRlc2MgPT09IG51bGwgfHwgZGVzYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVzYy5zZXQpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZTogaWYgdGhpcyB3cml0ZSBpcyBjYXB0dXJlZCBieSBhIHNldHRlciwgd2UgaGF2ZVxuICAgICAgLy8gdG8gdHJpZ2dlciBpdCB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiAgICAgIGRlc2Muc2V0LmNhbGwoc3RhdGUuZHJhZnRfLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgLy8gdGhlIGxhc3QgY2hlY2sgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggc2V0dGluZyBhIG5vbi1leGlzdGluZyB0byB1bmRlZmluZWQgKHdoaWNoIGlzIGEgY2hhbmdlKVxuICAgICAgLy8gZnJvbSBzZXR0aW5nIGFuIGV4aXN0aW5nIHByb3BlcnR5IHdpdGggdmFsdWUgdW5kZWZpbmVkIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgbm90IGEgY2hhbmdlKVxuICAgICAgdmFyIGN1cnJlbnQgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApOyAvLyBzcGVjaWFsIGNhc2UsIGlmIHdlIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gYSBkcmFmdCwgd2UgY2FuIGlnbm9yZSB0aGUgYXNzaWdubWVudFxuXG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50W0RSQUZUX1NUQVRFXTtcblxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50KSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSkgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmNvcHlfW3Byb3BdID09PSB2YWx1ZSAmJiAoIC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXG4gICAgdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSkgcmV0dXJuIHRydWU7IC8vIEB0cy1pZ25vcmVcblxuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wKSB7XG4gICAgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYW4gb3JpZ2luYWxseSBub3QgYXNzaWduZWQgcHJvcGVydHkgd2FzIGRlbGV0ZWRcbiAgICAgIGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF07XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIGlmIChzdGF0ZS5jb3B5XykgZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG4gICAgdmFyIG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICB2YXIgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKTtcbiAgICBpZiAoIWRlc2MpIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDFcbiAgICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICAgIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogb3duZXJbcHJvcF1cbiAgICB9O1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgZGllKDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXyk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZigpIHtcbiAgICBkaWUoMTIpO1xuICB9XG59O1xuLyoqXHJcbiAqIEFycmF5IGRyYWZ0c1xyXG4gKi9cblxudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gIGlmICggaXNOYU4ocGFyc2VJbnQocHJvcCkpKSBkaWUoMTMpOyAvLyBAdHMtaWdub3JlXG5cbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHVuZGVmaW5lZCk7XG59O1xuXG5hcnJheVRyYXBzLnNldCA9IGZ1bmN0aW9uIChzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKCBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSkgZGllKDE0KTtcbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTsgLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cblxuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIHZhciBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgdmFyIHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0O1xuICByZXR1cm4gc291cmNlW3Byb3BdO1xufVxuXG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIHZhciBfZGVzYyRnZXQ7XG5cbiAgdmFyIGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gXCJ2YWx1ZVwiIGluIGRlc2MgPyBkZXNjLnZhbHVlIDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgKF9kZXNjJGdldCA9IGRlc2MuZ2V0KSA9PT0gbnVsbCB8fCBfZGVzYyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZXNjJGdldC5jYWxsKHN0YXRlLmRyYWZ0XykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKSB7XG4gIC8vICdpbicgY2hlY2tzIHByb3RvIVxuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpIHJldHVybiB1bmRlZmluZWQ7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuXG4gIHdoaWxlIChwcm90bykge1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG4gICAgaWYgKGRlc2MpIHJldHVybiBkZXNjO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcblxuICAgIGlmIChzdGF0ZS5wYXJlbnRfKSB7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZS5wYXJlbnRfKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weV8pIHtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KHN0YXRlLmJhc2VfKTtcbiAgfVxufVxuXG52YXIgSW1tZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbW1lcihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy51c2VQcm94aWVzXyA9IGhhc1Byb3hpZXM7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICAgICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gICAgICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXHJcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxyXG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcclxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICAgICAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxyXG4gICAgICovXG5cbiAgICB0aGlzLnByb2R1Y2UgPSBmdW5jdGlvbiAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSB7XG4gICAgICAvLyBjdXJyaWVkIGludm9jYXRpb25cbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgZGVmYXVsdEJhc2UgPSByZWNpcGU7XG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBiYXNlID0gZGVmYXVsdEJhc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvZHVjZShiYXNlLCBmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICAgICAgICAgIHZhciBfcmVjaXBlO1xuXG4gICAgICAgICAgICByZXR1cm4gKF9yZWNpcGUgPSByZWNpcGUpLmNhbGwuYXBwbHkoX3JlY2lwZSwgW190aGlzMiwgZHJhZnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSBkaWUoNik7XG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg3KTtcbiAgICAgIHZhciByZXN1bHQ7IC8vIE9ubHkgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBhbmQgXCJpbW1lcmFibGUgY2xhc3Nlc1wiIGFyZSBkcmFmdGVkLlxuXG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gZW50ZXJTY29wZShfdGhpcyk7XG4gICAgICAgIHZhciBwcm94eSA9IGNyZWF0ZVByb3h5KF90aGlzLCBiYXNlLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgaGFzRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIGZpbmFsbHkgaW5zdGVhZCBvZiBjYXRjaCArIHJldGhyb3cgYmV0dGVyIHByZXNlcnZlcyBvcmlnaW5hbCBzdGFja1xuICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV2b2tlU2NvcGUoc2NvcGUpO2Vsc2UgbGVhdmVTY29wZShzY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWJhc2UgfHwgdHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2U7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF90aGlzLmF1dG9GcmVlemVfKSBmcmVlemUocmVzdWx0LCB0cnVlKTtcblxuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIHZhciBwID0gW107XG4gICAgICAgICAgdmFyIGlwID0gW107XG4gICAgICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCBwLCBpcCk7XG4gICAgICAgICAgcGF0Y2hMaXN0ZW5lcihwLCBpcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIGRpZSgyMSwgYmFzZSk7XG4gICAgfTtcblxuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gZnVuY3Rpb24gKGJhc2UsIHJlY2lwZSkge1xuICAgICAgLy8gY3VycmllZCBpbnZvY2F0aW9uXG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5hcHBseSh2b2lkIDAsIFtkcmFmdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIGZ1bmN0aW9uIChwLCBpcCkge1xuICAgICAgICBwYXRjaGVzID0gcDtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMgPSBpcDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudXNlUHJveGllcykgPT09IFwiYm9vbGVhblwiKSB0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnLnVzZVByb3hpZXMpO1xuICAgIGlmICh0eXBlb2YgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvRnJlZXplKSA9PT0gXCJib29sZWFuXCIpIHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWcuYXV0b0ZyZWV6ZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW1tZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jcmVhdGVEcmFmdCA9IGZ1bmN0aW9uIGNyZWF0ZURyYWZ0KGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIGJhc2UgPSBjdXJyZW50KGJhc2UpO1xuICAgIHZhciBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgdmFyIHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbmlzaERyYWZ0ID0gZnVuY3Rpb24gZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICB2YXIgc3RhdGUgPSBkcmFmdCAmJiBkcmFmdFtEUkFGVF9TVEFURV07XG5cbiAgICB7XG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pIGRpZSg5KTtcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfKSBkaWUoMTApO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlXztcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodW5kZWZpbmVkLCBzY29wZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRBdXRvRnJlZXplID0gZnVuY3Rpb24gc2V0QXV0b0ZyZWV6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcclxuICAgKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRVc2VQcm94aWVzID0gZnVuY3Rpb24gc2V0VXNlUHJveGllcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhaGFzUHJveGllcykge1xuICAgICAgZGllKDIwKTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVByb3hpZXNfID0gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGx5UGF0Y2hlcyA9IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKSB7XG4gICAgLy8gSWYgYSBwYXRjaCByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCB0YWtlIHRoYXQgcmVwbGFjZW1lbnQgYXMgYmFzZVxuICAgIC8vIGJlZm9yZSBhcHBseWluZyBwYXRjaGVzXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuXG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXG4gICAgLy8gcGF0Y2ggYWZ0ZXIgdGhhdC5cblxuXG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xuICAgIH1cblxuICAgIHZhciBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfO1xuXG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcyk7XG4gICAgfSAvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBjb3B5IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG5cbiAgICByZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBJbW1lcjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGltbWVyLCB2YWx1ZSwgcGFyZW50KSB7XG4gIC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuICB2YXIgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KSA6IGltbWVyLnVzZVByb3hpZXNfID8gY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KSA6IGdldFBsdWdpbihcIkVTNVwiKS5jcmVhdGVFUzVQcm94eV8odmFsdWUsIHBhcmVudCk7XG4gIHZhciBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgcmV0dXJuIGRyYWZ0O1xufVxuXG5mdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgyMiwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIHZhciBjb3B5O1xuICB2YXIgYXJjaFR5cGUgPSBnZXRBcmNodHlwZSh2YWx1ZSk7XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8gJiYgKHN0YXRlLnR5cGVfIDwgNCB8fCAhZ2V0UGx1Z2luKFwiRVM1XCIpLmhhc0NoYW5nZXNfKHN0YXRlKSkpIHJldHVybiBzdGF0ZS5iYXNlXzsgLy8gT3B0aW1pemF0aW9uOiBhdm9pZCBnZW5lcmF0aW5nIG5ldyBkcmFmdHMgZHVyaW5nIGNvcHlpbmdcblxuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSk7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSk7XG4gIH1cblxuICBlYWNoKGNvcHksIGZ1bmN0aW9uIChrZXksIGNoaWxkVmFsdWUpIHtcbiAgICBpZiAoc3RhdGUgJiYgZ2V0KHN0YXRlLmJhc2VfLCBrZXkpID09PSBjaGlsZFZhbHVlKSByZXR1cm47IC8vIG5vIG5lZWQgdG8gY29weSBvciBzZWFyY2ggaW4gc29tZXRoaW5nIHRoYXQgZGlkbid0IGNoYW5nZVxuXG4gICAgc2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpO1xuICB9KTsgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgY29uc2lkZXIgZnJlZXppbmcgaGVyZSwgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2V0dGluZ3NcblxuICByZXR1cm4gYXJjaFR5cGUgPT09IDNcbiAgLyogU2V0ICovXG4gID8gbmV3IFNldChjb3B5KSA6IGNvcHk7XG59XG5cbmZ1bmN0aW9uIGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKSB7XG4gIC8vIGNyZWF0ZXMgYSBzaGFsbG93IGNvcHksIGV2ZW4gaWYgaXQgaXMgYSBtYXAgb3Igc2V0XG4gIHN3aXRjaCAoYXJjaFR5cGUpIHtcbiAgICBjYXNlIDJcbiAgICAvKiBNYXAgKi9cbiAgICA6XG4gICAgICByZXR1cm4gbmV3IE1hcCh2YWx1ZSk7XG5cbiAgICBjYXNlIDNcbiAgICAvKiBTZXQgKi9cbiAgICA6XG4gICAgICAvLyBTZXQgd2lsbCBiZSBjbG9uZWQgYXMgYXJyYXkgdGVtcG9yYXJpbHksIHNvIHRoYXQgd2UgY2FuIHJlcGxhY2UgaW5kaXZpZHVhbCBpdGVtc1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWxsb3dDb3B5KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRVM1KCkge1xuICBmdW5jdGlvbiB3aWxsRmluYWxpemVFUzVfKHNjb3BlLCByZXN1bHQsIGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoIWlzUmVwbGFjZWQpIHtcbiAgICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c19bMF0pO1xuICAgICAgfSAvLyBUaGlzIGlzIGZhc3RlciB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hpY2ggYXR0cmlidXRlcyBjaGFuZ2VkLlxuXG5cbiAgICAgIG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXyk7XG4gICAgfSAvLyBXaGVuIGEgY2hpbGQgZHJhZnQgaXMgcmV0dXJuZWQsIGxvb2sgZm9yIGNoYW5nZXMuXG4gICAgZWxzZSBpZiAoaXNEcmFmdChyZXN1bHQpICYmIHJlc3VsdFtEUkFGVF9TVEFURV0uc2NvcGVfID09PSBzY29wZSkge1xuICAgICAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSkge1xuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICB2YXIgZHJhZnQgPSBuZXcgQXJyYXkoYmFzZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBcIlwiICsgaSwgcHJveHlQcm9wZXJ0eShpLCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG5cbiAgICAgIGRlbGV0ZSBfZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICAgICAgdmFyIGtleXMgPSBvd25LZXlzKF9kZXNjcmlwdG9ycyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tfaV07XG4gICAgICAgIF9kZXNjcmlwdG9yc1trZXldID0gcHJveHlQcm9wZXJ0eShrZXksIGlzQXJyYXkgfHwgISFfZGVzY3JpcHRvcnNba2V5XS5lbnVtZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBfZGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVTNVByb3h5XyhiYXNlLCBwYXJlbnQpIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gICAgdmFyIGRyYWZ0ID0gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSk7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgdHlwZV86IGlzQXJyYXkgPyA1XG4gICAgICAvKiBFUzVBcnJheSAqL1xuICAgICAgOiA0XG4gICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgICxcbiAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgYXNzaWduZWRfOiB7fSxcbiAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgIC8vIGJhc2UgaXMgdGhlIG9iamVjdCB3ZSBhcmUgZHJhZnRpbmdcbiAgICAgIGJhc2VfOiBiYXNlLFxuICAgICAgLy8gZHJhZnQgaXMgdGhlIGRyYWZ0IG9iamVjdCBpdHNlbGYsIHRoYXQgdHJhcHMgYWxsIHJlYWRzIGFuZCByZWFkcyBmcm9tIGVpdGhlciB0aGUgYmFzZSAoaWYgdW5tb2RpZmllZCkgb3IgY29weSAoaWYgbW9kaWZpZWQpXG4gICAgICBkcmFmdF86IGRyYWZ0LFxuICAgICAgY29weV86IG51bGwsXG4gICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIERSQUZUX1NUQVRFLCB7XG4gICAgICB2YWx1ZTogc3RhdGUsXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZHJhZnQ7XG4gIH0gLy8gcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIHJlY3ljbGVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjcmVhdGUgYSBnZXQgYW5kIHNldCBjbG9zdXJlIHBlciBwcm9wZXJ0eSxcbiAgLy8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHByb3h5UHJvcGVydHkocHJvcCwgZW51bWVyYWJsZSkge1xuICAgIHZhciBkZXNjID0gZGVzY3JpcHRvcnNbcHJvcF07XG5cbiAgICBpZiAoZGVzYykge1xuICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvcnNbcHJvcF0gPSBkZXNjID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIHJldHVybiBvYmplY3RUcmFwcy5nZXQoc3RhdGUsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIG9iamVjdFRyYXBzLnNldChzdGF0ZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9IC8vIFRoaXMgbG9va3MgZXhwZW5zaXZlLCBidXQgb25seSBwcm94aWVzIGFyZSB2aXNpdGVkLCBhbmQgb25seSBvYmplY3RzIHdpdGhvdXQga25vd24gY2hhbmdlcyBhcmUgc2Nhbm5lZC5cblxuXG4gIGZ1bmN0aW9uIG1hcmtDaGFuZ2VzU3dlZXAoZHJhZnRzKSB7XG4gICAgLy8gVGhlIG5hdHVyYWwgb3JkZXIgb2YgZHJhZnRzIGluIHRoZSBgc2NvcGVgIGFycmF5IGlzIGJhc2VkIG9uIHdoZW4gdGhleVxuICAgIC8vIHdlcmUgYWNjZXNzZWQuIEJ5IHByb2Nlc3NpbmcgZHJhZnRzIGluIHJldmVyc2UgbmF0dXJhbCBvcmRlciwgd2UgaGF2ZSBhXG4gICAgLy8gYmV0dGVyIGNoYW5jZSBvZiBwcm9jZXNzaW5nIGxlYWYgbm9kZXMgZmlyc3QuIFdoZW4gYSBsZWFmIG5vZGUgaXMga25vd24gdG9cbiAgICAvLyBoYXZlIGNoYW5nZWQsIHdlIGNhbiBhdm9pZCBhbnkgdHJhdmVyc2FsIG9mIGl0cyBhbmNlc3RvciBub2Rlcy5cbiAgICBmb3IgKHZhciBpID0gZHJhZnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgc3RhdGUgPSBkcmFmdHNbaV1bRFJBRlRfU1RBVEVdO1xuXG4gICAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG4gICAgICAgICAgY2FzZSA1XG4gICAgICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgICAgICA6XG4gICAgICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDRcbiAgICAgICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgICAgICA6XG4gICAgICAgICAgICBpZiAoaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NoYW5nZXNSZWN1cnNpdmVseShvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgdmFyIHN0YXRlID0gb2JqZWN0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XyxcbiAgICAgICAgYXNzaWduZWRfID0gc3RhdGUuYXNzaWduZWRfLFxuICAgICAgICB0eXBlXyA9IHN0YXRlLnR5cGVfO1xuXG4gICAgaWYgKHR5cGVfID09PSA0XG4gICAgLyogRVM1T2JqZWN0ICovXG4gICAgKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGFkZGVkIGtleXMuXG4gICAgICAgIC8vIHByb2JhYmx5IHRoZXJlIGlzIGEgZmFzdGVyIHdheSB0byBkZXRlY3QgY2hhbmdlcywgYXMgc3dlZXAgKyByZWN1cnNlIHNlZW1zIHRvIGRvIHNvbWVcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yay5cbiAgICAgICAgLy8gYWxzbzogcHJvYmFibHkgd2UgY2FuIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiB3ZSBkZXRlY3QgaGVyZSwgdG8gc3BlZWQgdXAgdHJlZSBmaW5hbGl6YXRpb24hXG4gICAgICAgIGVhY2goZHJhZnRfLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIHJldHVybjsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgICAgIGlmIChiYXNlX1trZXldID09PSB1bmRlZmluZWQgJiYgIWhhcyhiYXNlXywga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWFzc2lnbmVkX1trZXldKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICAgICAgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9ba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gTG9vayBmb3IgcmVtb3ZlZCBrZXlzLlxuXG4gICAgICAgIGVhY2goYmFzZV8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgICAgICAgIGlmIChkcmFmdF9ba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoZHJhZnRfLCBrZXkpKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9ba2V5XSA9IGZhbHNlO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSA1XG4gICAgLyogRVM1QXJyYXkgKi9cbiAgICApIHtcbiAgICAgICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgYXNzaWduZWRfLmxlbmd0aCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZnRfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1tpXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSBiYXNlXy5sZW5ndGg7IF9pMiA8IGRyYWZ0Xy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9bX2kyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE1pbmltdW0gY291bnQgaXMgZW5vdWdoLCB0aGUgb3RoZXIgcGFydHMgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXG5cbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGRyYWZ0Xy5sZW5ndGgsIGJhc2VfLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbWluOyBfaTMrKykge1xuICAgICAgICAgIC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG4gICAgICAgICAgaWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoX2kzKSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW19pM10gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhc3NpZ25lZF9bX2kzXSA9PT0gdW5kZWZpbmVkKSBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1tfaTNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBkcmFmdF8gPSBzdGF0ZS5kcmFmdF87IC8vIFNlYXJjaCBmb3IgYWRkZWQga2V5cyBhbmQgY2hhbmdlZCBrZXlzLiBTdGFydCBhdCB0aGUgYmFjaywgYmVjYXVzZVxuICAgIC8vIG5vbi1udW1lcmljIGtleXMgYXJlIG9yZGVyZWQgYnkgdGltZSBvZiBkZWZpbml0aW9uIG9uIHRoZSBvYmplY3QuXG5cbiAgICB2YXIga2V5cyA9IG93bktleXMoZHJhZnRfKTtcblxuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09IERSQUZUX1NUQVRFKSBjb250aW51ZTtcbiAgICAgIHZhciBiYXNlVmFsdWUgPSBiYXNlX1trZXldOyAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXG4gICAgICBpZiAoYmFzZVZhbHVlID09PSB1bmRlZmluZWQgJiYgIWhhcyhiYXNlXywga2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gT25jZSBhIGJhc2Uga2V5IGlzIGRlbGV0ZWQsIGZ1dHVyZSBjaGFuZ2VzIGdvIHVuZGV0ZWN0ZWQsIGJlY2F1c2UgaXRzXG4gICAgICAvLyBkZXNjcmlwdG9yIGlzIGVyYXNlZC4gVGhpcyBicmFuY2ggZGV0ZWN0cyBhbnkgbWlzc2VkIGNoYW5nZXMuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkcmFmdF9ba2V5XTtcblxuICAgICAgICAgIHZhciBfc3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV07XG5cbiAgICAgICAgICBpZiAoX3N0YXRlID8gX3N0YXRlLmJhc2VfICE9PSBiYXNlVmFsdWUgOiAhaXModmFsdWUsIGJhc2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbm8ga2V5cyB3ZXJlIGFkZGVkIG9yIGNoYW5nZWQuXG4gICAgLy8gQ29tcGFyZSBrZXkgY291bnQgdG8gZGV0ZXJtaW5lIGlmIGtleXMgd2VyZSBkZWxldGVkLlxuXG5cbiAgICB2YXIgYmFzZUlzRHJhZnQgPSAhIWJhc2VfW0RSQUZUX1NUQVRFXTtcbiAgICByZXR1cm4ga2V5cy5sZW5ndGggIT09IG93bktleXMoYmFzZV8pLmxlbmd0aCArIChiYXNlSXNEcmFmdCA/IDAgOiAxKTsgLy8gKyAxIHRvIGNvcnJlY3QgZm9yIERSQUZUX1NUQVRFXG4gIH1cblxuICBmdW5jdGlvbiBoYXNBcnJheUNoYW5nZXMoc3RhdGUpIHtcbiAgICB2YXIgZHJhZnRfID0gc3RhdGUuZHJhZnRfO1xuICAgIGlmIChkcmFmdF8ubGVuZ3RoICE9PSBzdGF0ZS5iYXNlXy5sZW5ndGgpIHJldHVybiB0cnVlOyAvLyBTZWUgIzExNlxuICAgIC8vIElmIHdlIGZpcnN0IHNob3J0ZW4gdGhlIGxlbmd0aCwgb3VyIGFycmF5IGludGVyY2VwdG9ycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgLy8gSWYgYWZ0ZXIgdGhhdCBuZXcgaXRlbXMgYXJlIGFkZGVkLCByZXN1bHQgaW4gdGhlIHNhbWUgb3JpZ2luYWwgbGVuZ3RoLFxuICAgIC8vIHRob3NlIGxhc3QgaXRlbXMgd2lsbCBoYXZlIG5vIGludGVyY2VwdGluZyBwcm9wZXJ0eS5cbiAgICAvLyBTbyBpZiB0aGVyZSBpcyBubyBvd24gZGVzY3JpcHRvciBvbiB0aGUgbGFzdCBwb3NpdGlvbiwgd2Uga25vdyB0aGF0IGl0ZW1zIHdlcmUgcmVtb3ZlZCBhbmQgYWRkZWRcbiAgICAvLyBOLkIuOiBzcGxpY2UsIHVuc2hpZnQsIGV0YyBvbmx5IHNoaWZ0IHZhbHVlcyBhcm91bmQsIGJ1dCBub3QgcHJvcCBkZXNjcmlwdG9ycywgc28gd2Ugb25seSBoYXZlIHRvIGNoZWNrXG4gICAgLy8gdGhlIGxhc3Qgb25lXG4gICAgLy8gbGFzdCBkZXNjcmlwdG9yIGNhbiBiZSBub3QgYSB0cmFwLCBpZiB0aGUgYXJyYXkgd2FzIGV4dGVuZGVkXG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZHJhZnRfLCBkcmFmdF8ubGVuZ3RoIC0gMSk7IC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cbiAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5nZXQpIHJldHVybiB0cnVlOyAvLyBpZiB3ZSBtaXNzIGEgcHJvcGVydHksIGl0IGhhcyBiZWVuIGRlbGV0ZWQsIHNvIGFycmF5IHByb2JvYmFseSBjaGFuZ2VkXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWZ0Xy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiB0cnVlO1xuICAgIH0gLy8gRm9yIGFsbCBvdGhlciBjYXNlcywgd2UgZG9uJ3QgaGF2ZSB0byBjb21wYXJlLCBhcyB0aGV5IHdvdWxkIGhhdmUgYmVlbiBwaWNrZWQgdXAgYnkgdGhlIGluZGV4IHNldHRlcnNcblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2hhbmdlc18oc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUudHlwZV8gPT09IDRcbiAgICAvKiBFUzVPYmplY3QgKi9cbiAgICA/IGhhc09iamVjdENoYW5nZXMoc3RhdGUpIDogaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZVxuICAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovXG4gICkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcbiAgfVxuXG4gIGxvYWRQbHVnaW4oXCJFUzVcIiwge1xuICAgIGNyZWF0ZUVTNVByb3h5XzogY3JlYXRlRVM1UHJveHlfLFxuICAgIHdpbGxGaW5hbGl6ZUVTNV86IHdpbGxGaW5hbGl6ZUVTNV8sXG4gICAgaGFzQ2hhbmdlc186IGhhc0NoYW5nZXNfXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICB2YXIgUkVQTEFDRSA9IFwicmVwbGFjZVwiO1xuICB2YXIgQUREID0gXCJhZGRcIjtcbiAgdmFyIFJFTU9WRSA9IFwicmVtb3ZlXCI7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgY2FzZSAwXG4gICAgICAvKiBQcm94eU9iamVjdCAqL1xuICAgICAgOlxuICAgICAgY2FzZSA0XG4gICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgMlxuICAgICAgLyogTWFwICovXG4gICAgICA6XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICAgIGNhc2UgNVxuICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgMVxuICAgICAgLyogUHJveHlBcnJheSAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICAgIGNhc2UgM1xuICAgICAgLyogU2V0ICovXG4gICAgICA6XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBhc3NpZ25lZF8gPSBzdGF0ZS5hc3NpZ25lZF87XG4gICAgdmFyIGNvcHlfID0gc3RhdGUuY29weV87IC8vIFJlZHVjZSBjb21wbGV4aXR5IGJ5IGVuc3VyaW5nIGBiYXNlYCBpcyBuZXZlciBsb25nZXIuXG5cbiAgICBpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICB2YXIgX3JlZiA9IFtjb3B5XywgYmFzZV9dO1xuICAgICAgYmFzZV8gPSBfcmVmWzBdO1xuICAgICAgY29weV8gPSBfcmVmWzFdO1xuICAgICAgdmFyIF9yZWYyID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcbiAgICAgIHBhdGNoZXMgPSBfcmVmMlswXTtcbiAgICAgIGludmVyc2VQYXRjaGVzID0gX3JlZjJbMV07XG4gICAgfSAvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG4gICAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBQcm9jZXNzIGFkZGVkIGluZGljZXMuXG5cblxuICAgIGZvciAodmFyIF9pID0gYmFzZV8ubGVuZ3RoOyBfaSA8IGNvcHlfLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtfaV0pO1xuXG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9bX2ldKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VfLmxlbmd0aCA8IGNvcHlfLmxlbmd0aCkge1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICBwYXRoOiBiYXNlUGF0aC5jb25jYXQoW1wibGVuZ3RoXCJdKSxcbiAgICAgICAgdmFsdWU6IGJhc2VfLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCBmdW5jdGlvbiAoa2V5LCBhc3NpZ25lZFZhbHVlKSB7XG4gICAgICB2YXIgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gZ2V0KGNvcHlfLCBrZXkpO1xuICAgICAgdmFyIG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREO1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICBwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHtcbiAgICAgICAgb3A6IG9wLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9IDoge1xuICAgICAgICBvcDogb3AsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKG9wID09PSBBREQgPyB7XG4gICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0gOiBvcCA9PT0gUkVNT1ZFID8ge1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKVxuICAgICAgfSA6IHtcbiAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgdmFyIGkgPSAwO1xuICAgIGJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWNvcHlfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSk7XG4gICAgaSA9IDA7XG4gICAgY29weV8uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlVmFsdWUsIHJlcGxhY2VtZW50LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdW5kZWZpbmVkIDogcmVwbGFjZW1lbnRcbiAgICB9KTtcbiAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogYmFzZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRjaCkge1xuICAgICAgdmFyIHBhdGggPSBwYXRjaC5wYXRoLFxuICAgICAgICAgIG9wID0gcGF0Y2gub3A7XG4gICAgICB2YXIgYmFzZSA9IGRyYWZ0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwID0gXCJcIiArIHA7XG4gICAgICAgIH0gLy8gU2VlICM3MzgsIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cblxuXG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMFxuICAgICAgICAvKiBPYmplY3QgKi9cbiAgICAgICAgfHwgcGFyZW50VHlwZSA9PT0gMVxuICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICApICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpIGRpZSgyNCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpIGRpZSgyNCk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgZGllKDE1LCBwYXRoLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpOyAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cbiAgICAgIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBSRVBMQUNFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICBkaWUoMTYpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQUREOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcIi1cIiA/IGJhc2UucHVzaCh2YWx1ZSkgOiBiYXNlLnNwbGljZShrZXksIDAsIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgIGNhc2UgM1xuICAgICAgICAgICAgLyogU2V0ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRpZSgxNywgb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpO1xuICAgIGlmIChpc01hcChvYmopKSByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBrID0gX3JlZjNbMF0sXG4gICAgICAgICAgdiA9IF9yZWYzWzFdO1xuICAgICAgcmV0dXJuIFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXTtcbiAgICB9KSk7XG4gICAgaWYgKGlzU2V0KG9iaikpIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIHZhciBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9iaikge1xuICAgIGlmIChpc0RyYWZ0KG9iaikpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XG4gICAgfSBlbHNlIHJldHVybiBvYmo7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXzogYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfOiBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXzogZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG4gIH0pO1xufVxuXG4vLyB0eXBlcyBvbmx5IVxuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9OyAvLyBVZ2x5IGhhY2sgdG8gcmVzb2x2ZSAjNTAyIGFuZCBpbmhlcml0IGJ1aWx0IGluIE1hcCAvIFNldFxuXG5cbiAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSAoIC8vIEB0cy1pZ25vcmVcbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9XG5cbiAgdmFyIERyYWZ0TWFwID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmFmdE1hcCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICAgIGZ1bmN0aW9uIERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDJcbiAgICAgICAgLyogTWFwICovXG4gICAgICAgICxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB1bmRlZmluZWQsXG4gICAgICAgIGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRNYXAucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgLy8gY29uZmlndXJhYmxlOiB0cnVlXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfTtcblxuICAgIHAuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcC5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBrZXksIF9tYXApIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCBfdGhpcy5nZXQoa2V5KSwga2V5LCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcC5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICB2YXIgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuXG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7IC8vIGVpdGhlciBhbHJlYWR5IGRyYWZ0ZWQgb3IgcmVhc3NpZ25lZFxuICAgICAgfSAvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXG5cbiAgICAgIHZhciBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfTtcblxuICAgIHAua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9O1xuXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICBfcmVmO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnZhbHVlcygpO1xuICAgICAgfSwgX3JlZi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMyLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwgX3JlZjtcbiAgICB9O1xuXG4gICAgcC5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXMsXG4gICAgICAgICAgX3JlZjI7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5lbnRyaWVzKCk7XG4gICAgICB9LCBfcmVmMi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMzLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9LCBfcmVmMjtcbiAgICB9O1xuXG4gICAgcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdE1hcDtcbiAgfShNYXApO1xuXG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cblxuICB2YXIgRHJhZnRTZXQgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWZ0U2V0LCBfc3VwZXIpOyAvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblxuXG4gICAgZnVuY3Rpb24gRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogM1xuICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHVuZGVmaW5lZCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiBuZXcgTWFwKCksXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRTZXQucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblxuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHAuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDpcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmYWxzZSk7XG4gICAgfTtcblxuICAgIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBwLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9O1xuXG4gICAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdFNldDtcbiAgfShTZXQpO1xuXG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgLy8gY3JlYXRlIGRyYWZ0cyBmb3IgYWxsIGVudHJpZXMgdG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyXG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xuICApIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtcbiAgICBwcm94eU1hcF86IHByb3h5TWFwXyxcbiAgICBwcm94eVNldF86IHByb3h5U2V0X1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcbiAgZW5hYmxlRVM1KCk7XG4gIGVuYWJsZU1hcFNldCgpO1xuICBlbmFibGVQYXRjaGVzKCk7XG59XG5cbnZhciBpbW1lciA9XG4vKiNfX1BVUkVfXyovXG5uZXcgSW1tZXIoKTtcbi8qKlxyXG4gKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gKlxyXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICpcclxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxyXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICovXG5cbnZhciBwcm9kdWNlID0gaW1tZXIucHJvZHVjZTtcbi8qKlxyXG4gKiBMaWtlIGBwcm9kdWNlYCwgYnV0IGBwcm9kdWNlV2l0aFBhdGNoZXNgIGFsd2F5cyByZXR1cm5zIGEgdHVwbGVcclxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXHJcbiAqL1xuXG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gKlxyXG4gKiBBbHdheXMgZnJlZXplIGJ5IGRlZmF1bHQsIGV2ZW4gaW4gcHJvZHVjdGlvbiBtb2RlXHJcbiAqL1xuXG52YXIgc2V0QXV0b0ZyZWV6ZSA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xyXG4gKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxyXG4gKi9cblxudmFyIHNldFVzZVByb3hpZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuc2V0VXNlUHJveGllcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cclxuICovXG5cbnZhciBhcHBseVBhdGNoZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIENyZWF0ZSBhbiBJbW1lciBkcmFmdCBmcm9tIHRoZSBnaXZlbiBiYXNlIHN0YXRlLCB3aGljaCBtYXkgYmUgYSBkcmFmdCBpdHNlbGYuXHJcbiAqIFRoZSBkcmFmdCBjYW4gYmUgbW9kaWZpZWQgdW50aWwgeW91IGZpbmFsaXplIGl0IHdpdGggdGhlIGBmaW5pc2hEcmFmdGAgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgY3JlYXRlRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogRmluYWxpemUgYW4gSW1tZXIgZHJhZnQgZnJvbSBhIGBjcmVhdGVEcmFmdGAgY2FsbCwgcmV0dXJuaW5nIHRoZSBiYXNlIHN0YXRlXHJcbiAqIChpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZSkgb3IgYSBtb2RpZmllZCBjb3B5LiBUaGUgZHJhZnQgbXVzdCAqbm90KiBiZVxyXG4gKiBtdXRhdGVkIGFmdGVyd2FyZHMuXHJcbiAqXHJcbiAqIFBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIGdlbmVyYXRlIEltbWVyIHBhdGNoZXMgYmFzZWQgb24gdGhlXHJcbiAqIGNoYW5nZXMgdGhhdCB3ZXJlIG1hZGUuXHJcbiAqL1xuXG52YXIgZmluaXNoRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcclxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLkltbWVyID0gSW1tZXI7XG5leHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcbmV4cG9ydHMuY2FzdERyYWZ0ID0gY2FzdERyYWZ0O1xuZXhwb3J0cy5jYXN0SW1tdXRhYmxlID0gY2FzdEltbXV0YWJsZTtcbmV4cG9ydHMuY3JlYXRlRHJhZnQgPSBjcmVhdGVEcmFmdDtcbmV4cG9ydHMuY3VycmVudCA9IGN1cnJlbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9kdWNlO1xuZXhwb3J0cy5lbmFibGVBbGxQbHVnaW5zID0gZW5hYmxlQWxsUGx1Z2lucztcbmV4cG9ydHMuZW5hYmxlRVM1ID0gZW5hYmxlRVM1O1xuZXhwb3J0cy5lbmFibGVNYXBTZXQgPSBlbmFibGVNYXBTZXQ7XG5leHBvcnRzLmVuYWJsZVBhdGNoZXMgPSBlbmFibGVQYXRjaGVzO1xuZXhwb3J0cy5maW5pc2hEcmFmdCA9IGZpbmlzaERyYWZ0O1xuZXhwb3J0cy5mcmVlemUgPSBmcmVlemU7XG5leHBvcnRzLmltbWVyYWJsZSA9IERSQUZUQUJMRTtcbmV4cG9ydHMuaXNEcmFmdCA9IGlzRHJhZnQ7XG5leHBvcnRzLmlzRHJhZnRhYmxlID0gaXNEcmFmdGFibGU7XG5leHBvcnRzLm5vdGhpbmcgPSBOT1RISU5HO1xuZXhwb3J0cy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuZXhwb3J0cy5wcm9kdWNlID0gcHJvZHVjZTtcbmV4cG9ydHMucHJvZHVjZVdpdGhQYXRjaGVzID0gcHJvZHVjZVdpdGhQYXRjaGVzO1xuZXhwb3J0cy5zZXRBdXRvRnJlZXplID0gc2V0QXV0b0ZyZWV6ZTtcbmV4cG9ydHMuc2V0VXNlUHJveGllcyA9IHNldFVzZVByb3hpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcmVmIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiaGFzTWFwIiwiTWFwIiwiaGFzU2V0IiwiU2V0IiwiaGFzUHJveGllcyIsIlByb3h5IiwicmV2b2NhYmxlIiwiUmVmbGVjdCIsIk5PVEhJTkciLCJmb3IiLCJEUkFGVEFCTEUiLCJEUkFGVF9TVEFURSIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJlcnJvcnMiLCJfIiwiZGF0YSIsInBhdGgiLCJvcCIsInBsdWdpbiIsInRoaW5nIiwiZGllIiwiZXJyb3IiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImUiLCJtc2ciLCJhcHBseSIsIkVycm9yIiwiaXNEcmFmdCIsImlzRHJhZnRhYmxlIiwiX3ZhbHVlJGNvbnN0cnVjdG9yIiwiaXNQbGFpbk9iamVjdCIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsImlzTWFwIiwiaXNTZXQiLCJvYmplY3RDdG9yU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiQ3RvciIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkZ1bmN0aW9uIiwib3JpZ2luYWwiLCJiYXNlXyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInRhcmdldCIsInJlcyIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlYWNoIiwiaXRlciIsImVudW1lcmFibGVPbmx5IiwiZ2V0QXJjaHR5cGUiLCJrZXlzIiwiZW50cnkiLCJpbmRleCIsInN0YXRlIiwidHlwZV8iLCJoYXMiLCJwcm9wIiwiZ2V0Iiwic2V0IiwicHJvcE9yT2xkVmFsdWUiLCJ0IiwiYWRkIiwiaXMiLCJ4IiwieSIsImxhdGVzdCIsImNvcHlfIiwic2hhbGxvd0NvcHkiLCJiYXNlIiwic2xpY2UiLCJkZXNjcmlwdG9ycyIsImkiLCJkZXNjIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiY3JlYXRlIiwiZnJlZXplIiwiZGVlcCIsImlzRnJvemVuIiwiY2xlYXIiLCJkZWxldGUiLCJkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMiLCJwbHVnaW5zIiwiZ2V0UGx1Z2luIiwicGx1Z2luS2V5IiwibG9hZFBsdWdpbiIsImltcGxlbWVudGF0aW9uIiwiY3VycmVudFNjb3BlIiwiZ2V0Q3VycmVudFNjb3BlIiwiY3JlYXRlU2NvcGUiLCJwYXJlbnRfIiwiaW1tZXJfIiwiZHJhZnRzXyIsImNhbkF1dG9GcmVlemVfIiwidW5maW5hbGl6ZWREcmFmdHNfIiwidXNlUGF0Y2hlc0luU2NvcGUiLCJzY29wZSIsInBhdGNoTGlzdGVuZXIiLCJwYXRjaGVzXyIsImludmVyc2VQYXRjaGVzXyIsInBhdGNoTGlzdGVuZXJfIiwicmV2b2tlU2NvcGUiLCJsZWF2ZVNjb3BlIiwicmV2b2tlRHJhZnQiLCJlbnRlclNjb3BlIiwiaW1tZXIiLCJkcmFmdCIsInJldm9rZV8iLCJyZXZva2VkXyIsInByb2Nlc3NSZXN1bHQiLCJyZXN1bHQiLCJiYXNlRHJhZnQiLCJpc1JlcGxhY2VkIiwidW5kZWZpbmVkIiwidXNlUHJveGllc18iLCJ3aWxsRmluYWxpemVFUzVfIiwibW9kaWZpZWRfIiwiZmluYWxpemUiLCJtYXliZUZyZWV6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsInJvb3RTY29wZSIsImNoaWxkVmFsdWUiLCJmaW5hbGl6ZVByb3BlcnR5Iiwic2NvcGVfIiwiZmluYWxpemVkXyIsImRyYWZ0XyIsInJlc3VsdEVhY2giLCJnZW5lcmF0ZVBhdGNoZXNfIiwicGFyZW50U3RhdGUiLCJ0YXJnZXRPYmplY3QiLCJyb290UGF0aCIsInRhcmdldElzU2V0IiwiYXNzaWduZWRfIiwiYXV0b0ZyZWV6ZV8iLCJjcmVhdGVQcm94eVByb3h5IiwicGFyZW50IiwiaXNNYW51YWxfIiwidHJhcHMiLCJvYmplY3RUcmFwcyIsImFycmF5VHJhcHMiLCJfUHJveHkkcmV2b2NhYmxlIiwicmV2b2tlIiwicHJveHkiLCJzb3VyY2UiLCJyZWFkUHJvcEZyb21Qcm90byIsInBlZWsiLCJwcmVwYXJlQ29weSIsImNyZWF0ZVByb3h5IiwiZ2V0RGVzY3JpcHRvckZyb21Qcm90byIsImN1cnJlbnQiLCJjdXJyZW50U3RhdGUiLCJtYXJrQ2hhbmdlZCIsIk51bWJlciIsImlzTmFOIiwiZGVsZXRlUHJvcGVydHkiLCJvd25lciIsInNldFByb3RvdHlwZU9mIiwiZm4iLCJwYXJzZUludCIsIl9kZXNjJGdldCIsIkltbWVyIiwiY29uZmlnIiwiX3RoaXMiLCJwcm9kdWNlIiwicmVjaXBlIiwiZGVmYXVsdEJhc2UiLCJzZWxmIiwiY3VycmllZFByb2R1Y2UiLCJfdGhpczIiLCJfcmVjaXBlIiwiaGFzRXJyb3IiLCJQcm9taXNlIiwidGhlbiIsInAiLCJpcCIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsIl9sZW4yIiwiX2tleTIiLCJwYXRjaGVzIiwiaW52ZXJzZVBhdGNoZXMiLCJuZXh0U3RhdGUiLCJ1c2VQcm94aWVzIiwic2V0VXNlUHJveGllcyIsImF1dG9GcmVlemUiLCJzZXRBdXRvRnJlZXplIiwiX3Byb3RvIiwiY3JlYXRlRHJhZnQiLCJmaW5pc2hEcmFmdCIsImFwcGx5UGF0Y2hlcyIsInBhdGNoIiwiYXBwbHlQYXRjaGVzSW1wbCIsImFwcGx5UGF0Y2hlc18iLCJwcm94eU1hcF8iLCJwcm94eVNldF8iLCJjcmVhdGVFUzVQcm94eV8iLCJwdXNoIiwiY3VycmVudEltcGwiLCJjb3B5IiwiYXJjaFR5cGUiLCJoYXNDaGFuZ2VzXyIsImNvcHlIZWxwZXIiLCJmcm9tIiwiZW5hYmxlRVM1IiwibWFya0NoYW5nZXNSZWN1cnNpdmVseSIsIm1hcmtDaGFuZ2VzU3dlZXAiLCJjcmVhdGVFUzVEcmFmdCIsInByb3h5UHJvcGVydHkiLCJfZGVzY3JpcHRvcnMiLCJfaSIsImFzc2VydFVucmV2b2tlZCIsImRyYWZ0cyIsImhhc0FycmF5Q2hhbmdlcyIsImhhc09iamVjdENoYW5nZXMiLCJvYmplY3QiLCJfaTIiLCJtaW4iLCJNYXRoIiwiX2kzIiwiYmFzZVZhbHVlIiwiX3N0YXRlIiwiYmFzZUlzRHJhZnQiLCJkZXNjcmlwdG9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImVuYWJsZVBhdGNoZXMiLCJSRVBMQUNFIiwiQUREIiwiUkVNT1ZFIiwiYmFzZVBhdGgiLCJnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQiLCJnZW5lcmF0ZUFycmF5UGF0Y2hlcyIsImdlbmVyYXRlU2V0UGF0Y2hlcyIsIl9yZWYyIiwiY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQiLCJfcGF0aCIsImFzc2lnbmVkVmFsdWUiLCJvcmlnVmFsdWUiLCJ1bnNoaWZ0IiwicmVwbGFjZW1lbnQiLCJwYXJlbnRUeXBlIiwiam9pbiIsInR5cGUiLCJkZWVwQ2xvbmVQYXRjaFZhbHVlIiwic3BsaWNlIiwibWFwIiwiZW50cmllcyIsIl9yZWYzIiwiayIsInYiLCJjbG9uZWQiLCJlbmFibGVNYXBTZXQiLCJfZXh0ZW5kU3RhdGljcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIl9fcHJvdG9fXyIsIl9fZXh0ZW5kcyIsIl9fIiwiRHJhZnRNYXAiLCJfc3VwZXIiLCJzaXplIiwicHJlcGFyZU1hcENvcHkiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfbWFwIiwidmFsdWVzIiwibmV4dCIsInIiLCJkb25lIiwiX3RoaXMzIiwiRHJhZnRTZXQiLCJwcmVwYXJlU2V0Q29weSIsImVuYWJsZUFsbFBsdWdpbnMiLCJiaW5kIiwiY2FzdERyYWZ0IiwiY2FzdEltbXV0YWJsZSIsImRlZmF1bHQiLCJpbW1lcmFibGUiLCJub3RoaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/immer.cjs.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/immer/dist/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"(app-pages-browser)/./node_modules/immer/dist/immer.cjs.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUNBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLGdKQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbmRleC5qcz83N2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n        // nor polyfill, then a plain number is used for performance.\n        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n        // (unstable) APIs that have been removed. Can we remove the symbols?\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 0xeacf;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 0xead1;\n        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 0xead8;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 0xead3;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 0xead4;\n        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 0xead9;\n        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 0xead5;\n        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 0xead6;\n        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 0xead7;\n        function isValidElementType(type) {\n            return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n        }\n        function typeOf(object) {\n            if (typeof object === \"object\" && object !== null) {\n                var $$typeof = object.$$typeof;\n                switch($$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var type = object.type;\n                        switch(type){\n                            case REACT_ASYNC_MODE_TYPE:\n                            case REACT_CONCURRENT_MODE_TYPE:\n                            case REACT_FRAGMENT_TYPE:\n                            case REACT_PROFILER_TYPE:\n                            case REACT_STRICT_MODE_TYPE:\n                            case REACT_SUSPENSE_TYPE:\n                                return type;\n                            default:\n                                var $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                        }\n                    case REACT_PORTAL_TYPE:\n                        return $$typeof;\n                }\n            }\n            return undefined;\n        } // AsyncMode is deprecated along with isAsyncMode\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n        function isAsyncMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 17+. Update your code to use \" + \"ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n                }\n            }\n            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n        function isConcurrentMode(object) {\n            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n        function isContextConsumer(object) {\n            return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n            return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n            return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n            return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n            return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n            return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n            return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n            return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        exports.AsyncMode = AsyncMode;\n        exports.ConcurrentMode = ConcurrentMode;\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n        exports.isValidElementType = isValidElementType;\n        exports.typeOf = typeOf;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQyxHQUVEO0FBSUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsbUZBQW1GO1FBQ25GLDZEQUE2RDtRQUM3RCxJQUFJQyxZQUFZLE9BQU9DLFdBQVcsY0FBY0EsT0FBT0MsR0FBRztRQUMxRCxJQUFJQyxxQkFBcUJILFlBQVlDLE9BQU9DLEdBQUcsQ0FBQyxtQkFBbUI7UUFDbkUsSUFBSUUsb0JBQW9CSixZQUFZQyxPQUFPQyxHQUFHLENBQUMsa0JBQWtCO1FBQ2pFLElBQUlHLHNCQUFzQkwsWUFBWUMsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtRQUNyRSxJQUFJSSx5QkFBeUJOLFlBQVlDLE9BQU9DLEdBQUcsQ0FBQyx1QkFBdUI7UUFDM0UsSUFBSUssc0JBQXNCUCxZQUFZQyxPQUFPQyxHQUFHLENBQUMsb0JBQW9CO1FBQ3JFLElBQUlNLHNCQUFzQlIsWUFBWUMsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtRQUNyRSxJQUFJTyxxQkFBcUJULFlBQVlDLE9BQU9DLEdBQUcsQ0FBQyxtQkFBbUIsUUFBUSw4RUFBOEU7UUFDekoscUVBQXFFO1FBRXJFLElBQUlRLHdCQUF3QlYsWUFBWUMsT0FBT0MsR0FBRyxDQUFDLHNCQUFzQjtRQUN6RSxJQUFJUyw2QkFBNkJYLFlBQVlDLE9BQU9DLEdBQUcsQ0FBQywyQkFBMkI7UUFDbkYsSUFBSVUseUJBQXlCWixZQUFZQyxPQUFPQyxHQUFHLENBQUMsdUJBQXVCO1FBQzNFLElBQUlXLHNCQUFzQmIsWUFBWUMsT0FBT0MsR0FBRyxDQUFDLG9CQUFvQjtRQUNyRSxJQUFJWSwyQkFBMkJkLFlBQVlDLE9BQU9DLEdBQUcsQ0FBQyx5QkFBeUI7UUFDL0UsSUFBSWEsa0JBQWtCZixZQUFZQyxPQUFPQyxHQUFHLENBQUMsZ0JBQWdCO1FBQzdELElB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QUdSO1FBQ3ZCUSxrQkFBa0IsR0FBR1A7UUFDckJPLGNBQWMsR0FBR047UUFDakJNLGNBQWMsR0FBR0w7UUFDakJLLGdCQUFnQixHQUFHSjtRQUNuQkksa0JBQWtCLEdBQUdIO1FBQ3JCRyxvQkFBb0IsR0FBR0Y7UUFDdkJFLGtCQUFrQixHQUFHRDtRQUNyQkMsMEJBQTBCLEdBQUduQztRQUM3Qm1DLGNBQWMsR0FBR2hDO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzPzQ5NmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsImhhc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0FTWU5DX01PREVfVFlQRSIsIlJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1JFU1BPTkRFUl9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsImlzVmFsaWRFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsInR5cGVPZiIsIm9iamVjdCIsIiQkdHlwZW9mVHlwZSIsInVuZGVmaW5lZCIsIkFzeW5jTW9kZSIsIkNvbmN1cnJlbnRNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRWxlbWVudCIsIkZvcndhcmRSZWYiLCJGcmFnbWVudCIsIkxhenkiLCJNZW1vIiwiUG9ydGFsIiwiUHJvZmlsZXIiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSIsImlzQXN5bmNNb2RlIiwiY29uc29sZSIsImlzQ29uY3VycmVudE1vZGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzQ29udGV4dFByb3ZpZGVyIiwiaXNFbGVtZW50IiwiaXNGb3J3YXJkUmVmIiwiaXNGcmFnbWVudCIsImlzTGF6eSIsImlzTWVtbyIsImlzUG9ydGFsIiwiaXNQcm9maWxlciIsImlzU3RyaWN0TW9kZSIsImlzU3VzcGVuc2UiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxvSkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzP2IzMTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/components/Context.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-redux/es/components/Context.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReactReduxContext: function() { return /* binding */ ReactReduxContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst ContextKey = Symbol.for(\"react-redux-context\");\nconst gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    var _gT$ContextKey;\n    if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n    const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = new Map();\n    let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n    if (!realContext) {\n        realContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n    }\n    return realContext;\n}\nconst ReactReduxContext = /*#__PURE__*/ getContext();\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactReduxContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBQy9CLE1BQU1DLGFBQWFDLE9BQU9DLEdBQUcsQ0FBRTtBQUMvQixNQUFNQyxLQUFLLE9BQU9DLGVBQWUsY0FBY0EsYUFDL0Msd0ZBQXdGLEdBQ3hGLENBQUM7QUFFRCxTQUFTQztJQUNQLElBQUlDO0lBRUosSUFBSSxDQUFDUCxnREFBbUIsRUFBRSxPQUFPLENBQUM7SUFDbEMsTUFBTVMsYUFBYSxDQUFDRixpQkFBaUJILEVBQUUsQ0FBQ0gsV0FBVyxLQUFLLE9BQU9NLGlCQUFpQkgsRUFBRSxDQUFDSCxXQUFXLEdBQUcsSUFBSVM7SUFDckcsSUFBSUMsY0FBY0YsV0FBV0csR0FBRyxDQUFDWixnREFBbUI7SUFFcEQsSUFBSSxDQUFDVyxhQUFhO1FBQ2hCQSw0QkFBY1gsZ0RBQW1CLENBQUM7UUFFbEMsSUFBSWEsSUFBeUIsRUFBYztZQUN6Q0YsWUFBWUcsV0FBVyxHQUFHO1FBQzVCO1FBRUFMLFdBQVdNLEdBQUcsQ0FBQ2YsZ0RBQW1CLEVBQUVXO0lBQ3RDO0lBRUEsT0FBT0E7QUFDVDtBQUVPLE1BQU1LLG9CQUFvQixXQUFXLEdBQUVWLGFBQWE7QUFDM0QsK0RBQWVVLGlCQUFpQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Db250ZXh0LmpzPzRiZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuY29uc3QgQ29udGV4dEtleSA9IFN5bWJvbC5mb3IoYHJlYWN0LXJlZHV4LWNvbnRleHRgKTtcbmNvbnN0IGdUID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDpcbi8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xue307XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHZhciBfZ1QkQ29udGV4dEtleTtcblxuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpIHJldHVybiB7fTtcbiAgY29uc3QgY29udGV4dE1hcCA9IChfZ1QkQ29udGV4dEtleSA9IGdUW0NvbnRleHRLZXldKSAhPSBudWxsID8gX2dUJENvbnRleHRLZXkgOiBnVFtDb250ZXh0S2V5XSA9IG5ldyBNYXAoKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFyZWFsQ29udGV4dCkge1xuICAgIHJlYWxDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSZWFjdFJlZHV4JztcbiAgICB9XG5cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVhbENvbnRleHQ7XG59XG5cbmV4cG9ydCBjb25zdCBSZWFjdFJlZHV4Q29udGV4dCA9IC8qI19fUFVSRV9fKi9nZXRDb250ZXh0KCk7XG5leHBvcnQgZGVmYXVsdCBSZWFjdFJlZHV4Q29udGV4dDsiXSwibmFtZXMiOlsiUmVhY3QiLCJDb250ZXh0S2V5IiwiU3ltYm9sIiwiZm9yIiwiZ1QiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dCIsIl9nVCRDb250ZXh0S2V5IiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHRNYXAiLCJNYXAiLCJyZWFsQ29udGV4dCIsImdldCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsInNldCIsIlJlYWN0UmVkdXhDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/components/Provider.js":
/*!************************************************************!*\
  !*** ./node_modules/react-redux/es/components/Provider.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Subscription */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/Subscription.js\");\n/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nfunction Provider(param) {\n    let { store, context, children, serverState, stabilityCheck = \"once\", noopCheck = \"once\" } = param;\n    _s();\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const subscription = (0,_utils_Subscription__WEBPACK_IMPORTED_MODULE_2__.createSubscription)(store);\n        return {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : undefined,\n            stabilityCheck,\n            noopCheck\n        };\n    }, [\n        store,\n        serverState,\n        stabilityCheck,\n        noopCheck\n    ]);\n    const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>store.getState(), [\n        store\n    ]);\n    (0,_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect)(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = undefined;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || _Context__WEBPACK_IMPORTED_MODULE_1__.ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\n_s(Provider, \"UYZUOdaFWZnoeXRb2Yd5sJGEKkk=\", false, function() {\n    return [\n        _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__.useIsomorphicLayoutEffect\n    ];\n});\n_c = Provider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Provider);\nvar _c;\n$RefreshReg$(_c, \"Provider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDZTtBQUNhO0FBQ29CO0FBRS9FLFNBQVNJLFNBQVMsS0FPakI7UUFQaUIsRUFDaEJDLEtBQUssRUFDTEMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLFdBQVcsRUFDWEMsaUJBQWlCLE1BQU0sRUFDdkJDLFlBQVksTUFBTSxFQUNuQixHQVBpQjs7SUFRaEIsTUFBTUMsZUFBZVgsMENBQWEsQ0FBQztRQUNqQyxNQUFNYSxlQUFlWCx1RUFBa0JBLENBQUNHO1FBQ3hDLE9BQU87WUFDTEE7WUFDQVE7WUFDQUMsZ0JBQWdCTixjQUFjLElBQU1BLGNBQWNPO1lBQ2xETjtZQUNBQztRQUNGO0lBQ0YsR0FBRztRQUFDTDtRQUFPRztRQUFhQztRQUFnQkM7S0FBVTtJQUNsRCxNQUFNTSxnQkFBZ0JoQiwwQ0FBYSxDQUFDLElBQU1LLE1BQU1ZLFFBQVEsSUFBSTtRQUFDWjtLQUFNO0lBQ25FRiwyRkFBeUJBLENBQUM7UUFDeEIsTUFBTSxFQUNKVSxZQUFZLEVBQ2IsR0FBR0Y7UUFDSkUsYUFBYUssYUFBYSxHQUFHTCxhQUFhTSxnQkFBZ0I7UUFDMUROLGFBQWFPLFlBQVk7UUFFekIsSUFBSUosa0JBQWtCWCxNQUFNWSxRQUFRLElBQUk7WUFDdENKLGFBQWFNLGdCQUFnQjtRQUMvQjtRQUVBLE9BQU87WUFDTE4sYUFBYVEsY0FBYztZQUMzQlIsYUFBYUssYUFBYSxHQUFHSDtRQUMvQjtJQUNGLEdBQUc7UUFBQ0o7UUFBY0s7S0FBYztJQUNoQyxNQUFNTSxVQUFVaEIsV0FBV0wsdURBQWlCQSxFQUFFLDZIQUE2SDtJQUUzSyxPQUFPLFdBQVcsR0FBRUQsZ0RBQW1CLENBQUNzQixRQUFRbEIsUUFBUSxFQUFFO1FBQ3hEb0IsT0FBT2I7SUFDVCxHQUFHSjtBQUNMO0dBeENTSDs7UUFtQlBELHVGQUF5QkE7OztLQW5CbEJDO0FBMENULCtEQUFlQSxRQUFRQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzP2RiYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcblxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHNlcnZlclN0YXRlLFxuICBzdGFiaWxpdHlDaGVjayA9ICdvbmNlJyxcbiAgbm9vcENoZWNrID0gJ29uY2UnXG59KSB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGU6IHNlcnZlclN0YXRlID8gKCkgPT4gc2VydmVyU3RhdGUgOiB1bmRlZmluZWQsXG4gICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgIG5vb3BDaGVja1xuICAgIH07XG4gIH0sIFtzdG9yZSwgc2VydmVyU3RhdGUsIHN0YWJpbGl0eUNoZWNrLCBub29wQ2hlY2tdKTtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjb250ZXh0VmFsdWU7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG5cbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0OyAvLyBAdHMtaWdub3JlICdBbnlBY3Rpb24nIGlzIGFzc2lnbmFibGUgdG8gdGhlIGNvbnN0cmFpbnQgb2YgdHlwZSAnQScsIGJ1dCAnQScgY291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBkaWZmZXJlbnQgc3VidHlwZVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb3ZpZGVyOyJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0UmVkdXhDb250ZXh0IiwiY3JlYXRlU3Vic2NyaXB0aW9uIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIlByb3ZpZGVyIiwic3RvcmUiLCJjb250ZXh0IiwiY2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZSIsInN0YWJpbGl0eUNoZWNrIiwibm9vcENoZWNrIiwiY29udGV4dFZhbHVlIiwidXNlTWVtbyIsInN1YnNjcmlwdGlvbiIsImdldFNlcnZlclN0YXRlIiwidW5kZWZpbmVkIiwicHJldmlvdXNTdGF0ZSIsImdldFN0YXRlIiwib25TdGF0ZUNoYW5nZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJ0cnlTdWJzY3JpYmUiLCJ0cnlVbnN1YnNjcmliZSIsIkNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/components/Provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/components/connect.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-redux/es/components/connect.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeConnect: function() { return /* binding */ initializeConnect; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hoist-non-react-statics */ \"(app-pages-browser)/./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/index.js\");\n/* harmony import */ var _connect_selectorFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../connect/selectorFactory */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/selectorFactory.js\");\n/* harmony import */ var _connect_mapDispatchToProps__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../connect/mapDispatchToProps */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/mapDispatchToProps.js\");\n/* harmony import */ var _connect_mapStateToProps__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../connect/mapStateToProps */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/mapStateToProps.js\");\n/* harmony import */ var _connect_mergeProps__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../connect/mergeProps */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/mergeProps.js\");\n/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/Subscription */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/Subscription.js\");\n/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\");\n/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/shallowEqual */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/shallowEqual.js\");\n/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/warning */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/warning.js\");\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _utils_useSyncExternalStore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/useSyncExternalStore */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/useSyncExternalStore.js\");\nvar _s = $RefreshSig$();\n\n\nconst _excluded = [\n    \"reactReduxForwardedRef\"\n];\n/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */ \n\n\n\n\n\n\n\n\n\n\n\n\nlet useSyncExternalStore = _utils_useSyncExternalStore__WEBPACK_IMPORTED_MODULE_14__.notInitialized;\nconst initializeConnect = (fn)=>{\n    useSyncExternalStore = fn;\n}; // Define some constant arrays just to avoid re-creating these\nconst EMPTY_ARRAY = [\n    null,\n    0\n];\nconst NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n]; // Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\nconst stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    _s();\n    (0,_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect)(()=>effectFunc(...effectArgs), dependencies);\n} // Effect callback, extracted: assign the latest props values to refs for later usage\n_s(useIsomorphicLayoutEffectWithArgs, \"Vd+jpwighRca2oU8HoLqd+zm4Bo=\", false, function() {\n    return [\n        _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect\n    ];\n});\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    // We want to capture the wrapper props and child props we used for later comparisons\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n} // Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    // If we're not subscribed to the store, nothing to do here\n    if (!shouldHandleStateChanges) return ()=>{}; // Capture values for checking if and when this component unmounts\n    let didUnsubscribe = false;\n    let lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            // Don't run stale listeners.\n            // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n            return;\n        } // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            // Actually run the selector with the most recent store state and wrapper props\n            // to determine what the child props should be\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        } // If the child props haven't changed, nothing to do here - cascade the subscription update\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            // Save references to the new child props.  Note that we track the \"child props from store update\"\n            // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n            // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n            // forcing another re-render, which we don't want.\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true; // TODO This is hacky and not how `uSES` is meant to be used\n            // Trigger the React `useSyncExternalStore` subscriber\n            additionalSubscribeListener();\n        }\n    }; // Actually subscribe to the nearest connected ancestor (or store)\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe(); // Pull data from the store after first render in case the store has\n    // changed since we began.\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            // It's possible that we caught an error due to a bad mapState function, but the\n            // parent re-rendered without this component and we're about to unmount.\n            // This shouldn't happen as long as we do top-down subscriptions correctly, but\n            // if we ever do those wrong, this throw will surface the error in our tests.\n            // In that case, throw the error from here so it doesn't get lost.\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n} // Reducer initial state creation for our update reducer\nconst initStateUpdates = ()=>EMPTY_ARRAY;\nfunction strictEqual(a, b) {\n    return a === b;\n}\n/**\r\n * Infers the type of props that a connector will inject into a component.\r\n */ let hasWarnedAboutDeprecatedPureOption = false;\n/**\r\n * Connects a React component to a Redux store.\r\n *\r\n * - Without arguments, just wraps the component, without changing the behavior / props\r\n *\r\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\r\n * is to override ownProps (as stated in the docs), so what remains is everything that's\r\n * not a state or dispatch prop\r\n *\r\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\r\n * should be valid component props, because it depends on mergeProps implementation.\r\n * As such, it is the user's responsibility to extend ownProps interface from state or\r\n * dispatch props or both when applicable\r\n *\r\n * @param mapStateToProps A function that extracts values from state\r\n * @param mapDispatchToProps Setup for dispatching actions\r\n * @param mergeProps Optional callback to merge state and dispatch props together\r\n * @param options Options for configuring the connection\r\n *\r\n */ function connect(mapStateToProps, mapDispatchToProps, mergeProps) {\n    let { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n    // @ts-ignore\n    pure, areStatesEqual = strictEqual, areOwnPropsEqual = _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_11__[\"default\"], areStatePropsEqual = _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_11__[\"default\"], areMergedPropsEqual = _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_11__[\"default\"], // use React's forwardRef to expose a ref of the wrapped component\n    forwardRef = false, // the context consumer to use\n    context = _Context__WEBPACK_IMPORTED_MODULE_13__.ReactReduxContext } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (true) {\n        if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            (0,_utils_warning__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = (0,_connect_mapStateToProps__WEBPACK_IMPORTED_MODULE_7__.mapStateToPropsFactory)(mapStateToProps);\n    const initMapDispatchToProps = (0,_connect_mapDispatchToProps__WEBPACK_IMPORTED_MODULE_6__.mapDispatchToPropsFactory)(mapDispatchToProps);\n    const initMergeProps = (0,_connect_mergeProps__WEBPACK_IMPORTED_MODULE_8__.mergePropsFactory)(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        var _s = $RefreshSig$();\n        if ( true && !(0,react_is__WEBPACK_IMPORTED_MODULE_4__.isValidElementType)(WrappedComponent)) {\n            throw new Error(\"You must pass a component to the function returned by connect. Instead received \".concat(stringifyComponent(WrappedComponent)));\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = \"Connect(\".concat(wrappedComponentName, \")\");\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            // @ts-ignore\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            _s();\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                // Distinguish between actual \"data\" props that were passed to the wrapper component,\n                // and values needed to control behavior (forwarded refs, alternate context instances).\n                // To maintain the wrapperProps object reference, memoize this destructuring.\n                const { reactReduxForwardedRef } = props, wrapperProps = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(props, _excluded);\n                return [\n                    props.context,\n                    reactReduxForwardedRef,\n                    wrapperProps\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n                // Memoize the check that determines which context instance we should use.\n                return propsContext && propsContext.Consumer && // @ts-ignore\n                (0,react_is__WEBPACK_IMPORTED_MODULE_4__.isContextConsumer)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(propsContext.Consumer, null)) ? propsContext : Context;\n            }, [\n                propsContext,\n                Context\n            ]); // Retrieve the store and ancestor subscription via context, if available\n            const contextValue = react__WEBPACK_IMPORTED_MODULE_3__.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.\n            // We'll check to see if it _looks_ like a Redux store first.\n            // This allows us to pass through a `store` prop that is just a plain value.\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error('Could not find \"store\" in the context of ' + '\"'.concat(displayName, '\". Either wrap the root component in a <Provider>, ') + \"or pass a custom React context provider to <Provider> and the corresponding \" + \"React context consumer to \".concat(displayName, \" in connect options.\"));\n            } // Based on the previous check, one of these must be true\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                // The child props selector needs the store reference as an input.\n                // Re-create this selector whenever the store changes.\n                return (0,_connect_selectorFactory__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component\n                // connected to the store via props shouldn't use subscription from context, or vice versa.\n                const subscription = (0,_utils_Subscription__WEBPACK_IMPORTED_MODULE_9__.createSubscription)(store, didStoreComeFromProps ? undefined : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n                // the middle of the notification loop, where `subscription` will then be null. This can\n                // probably be avoided if Subscription's listeners logic is changed to not call listeners\n                // that have been unsubscribed in the  middle of the notification loop.\n                const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);\n                return [\n                    subscription,\n                    notifyNestedSubs\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]); // Determine what {store, subscription} value should be put into nested context, if necessary,\n            // and memoize that value to avoid unnecessary context updates.\n            const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    // This component is directly subscribed to a store from props.\n                    // We don't want descendants reading from this store - pass down whatever\n                    // the existing context value is from the nearest connected ancestor.\n                    return contextValue;\n                } // Otherwise, put this component's subscription instance into context, so that\n                // connected descendants won't update until after this component is done\n                return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, contextValue, {\n                    subscription\n                });\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]); // Set up refs to coordinate values between the subscription effect and the render logic\n            const lastChildProps = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n            const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_3__.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n            const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n            const isProcessingDispatch = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n            const isMounted = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n            const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n            (0,_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect)(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                const selector = ()=>{\n                    // Tricky logic here:\n                    // - This render may have been triggered by a Redux store update that produced new child props\n                    // - However, we may have gotten new wrapper props after that\n                    // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n                    // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n                    // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    } // TODO We're reading the store directly in render() here. Bad idea?\n                    // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n                    // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n                    // to determine what the child props should be.\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]); // We need this to execute synchronously every time we re-render. However, React warns\n            // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n            // just useEffect instead to avoid the warning, since neither will run anyway.\n            const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = useSyncExternalStore(subscribeForReact, // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n                }\n                throw err;\n            }\n            (0,_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect)(()=>{\n                latestSubscriptionCallbackError.current = undefined;\n                childPropsFromStoreUpdate.current = undefined;\n                lastChildProps.current = actualChildProps;\n            }); // Now that all that's done, we can finally try to actually render the child component.\n            // We memoize the elements for the rendered child component as an optimization.\n            const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                return(/*#__PURE__*/ // @ts-ignore\n                react__WEBPACK_IMPORTED_MODULE_3__.createElement(WrappedComponent, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, actualChildProps, {\n                    ref: reactReduxForwardedRef\n                })));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]); // If React sees the exact same element reference as last time, it bails out of re-rendering\n            // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n            const renderedChild = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    // If this component is subscribed to store updates, we need to pass its own\n                    // subscription instance down to our descendants. That means rendering the same\n                    // Context instance, and putting a different value into the context.\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        _s(ConnectFunction, \"YlsbgChiRX6N9qJQvI85/COlsOk=\", false, function() {\n            return [\n                _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect,\n                useIsomorphicLayoutEffectWithArgs,\n                _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_10__.useIsomorphicLayoutEffect\n            ];\n        });\n        const _Connect = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.memo(ConnectFunction);\n        // Add a hacky cast to get the right output type\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(function forwardConnectRef(props, ref) {\n                // @ts-ignore\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(Connect, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n                    reactReduxForwardedRef: ref\n                }));\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(forwarded, WrappedComponent);\n        }\n        return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (connect);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMwQztBQUNwRyxNQUFNRSxZQUFZO0lBQUM7Q0FBeUI7QUFFNUMsaUVBQWlFLEdBQ2Q7QUFDcEI7QUFDa0M7QUFDRDtBQUNVO0FBQ047QUFDVjtBQUNDO0FBQ29CO0FBQzlCO0FBQ1Y7QUFDTztBQUNpQjtBQUMvRCxJQUFJZSx1QkFBdUJELHdFQUFjQTtBQUNsQyxNQUFNRSxvQkFBb0JDLENBQUFBO0lBQy9CRix1QkFBdUJFO0FBQ3pCLEVBQUUsQ0FBQyw4REFBOEQ7QUFFakUsTUFBTUMsY0FBYztJQUFDO0lBQU07Q0FBRTtBQUM3QixNQUFNQyx3QkFBd0I7SUFBQztJQUFNO0NBQUssRUFBRSw0RUFBNEU7QUFDeEgsa0NBQWtDO0FBRWxDLE1BQU1DLHFCQUFxQkMsQ0FBQUE7SUFDekIsSUFBSTtRQUNGLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDeEIsRUFBRSxPQUFPRyxLQUFLO1FBQ1osT0FBT0MsT0FBT0o7SUFDaEI7QUFDRjtBQUVBLGtFQUFrRTtBQUNsRSwwRUFBMEU7QUFDMUUsd0VBQXdFO0FBQ3hFLDZCQUE2QjtBQUM3QixTQUFTSyxrQ0FBa0NDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxZQUFZOztJQUM3RW5CLDRGQUF5QkEsQ0FBQyxJQUFNaUIsY0FBY0MsYUFBYUM7QUFDN0QsRUFBRSxxRkFBcUY7R0FGOUVIOztRQUNQaEIsd0ZBQXlCQTs7O0FBSTNCLFNBQVNvQixvQkFBb0JDLGdCQUFnQixFQUFFQyxjQUFjLEVBQUVDLGlCQUFpQixFQUFFQyxZQUFZLEVBQzlGQyx5QkFBeUIsRUFBRUMsZ0JBQWdCO0lBQ3pDLHFGQUFxRjtJQUNyRkwsaUJBQWlCTSxPQUFPLEdBQUdIO0lBQzNCRCxrQkFBa0JJLE9BQU8sR0FBRyxPQUFPLG9HQUFvRztJQUV2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Z0JBQzFCO1lBQ0Y7WUFFQSxNQUFNUyxZQUFZRjtZQUNsQkUsVUFBVXhDLFdBQVcsR0FBR0E7WUFDeEJ3QyxVQUFVM0MsZ0JBQWdCLEdBQUdBO1lBQzdCLE9BQU9oRiw4REFBWUEsQ0FBQzJILFdBQVczQztRQUNqQztRQUVBLE9BQU9oRiw4REFBWUEsQ0FBQ3dILFNBQVN4QztJQUMvQjtJQUVBLE9BQU9EO0FBQ1Q7QUFFQSwrREFBZWxCLE9BQU9BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdC5qcz84NWE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5jb25zdCBfZXhjbHVkZWQgPSBbXCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXCJdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSwgaXNDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSBmcm9tICcuLi9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeSc7XG5pbXBvcnQgeyBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMnO1xuaW1wb3J0IHsgbWFwU3RhdGVUb1Byb3BzRmFjdG9yeSB9IGZyb20gJy4uL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCB7IG1lcmdlUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tZXJnZVByb3BzJztcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7IG5vdEluaXRpYWxpemVkIH0gZnJvbSAnLi4vdXRpbHMvdXNlU3luY0V4dGVybmFsU3RvcmUnO1xubGV0IHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbm90SW5pdGlhbGl6ZWQ7XG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUNvbm5lY3QgPSBmbiA9PiB7XG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gZm47XG59OyAvLyBEZWZpbmUgc29tZSBjb25zdGFudCBhcnJheXMganVzdCB0byBhdm9pZCByZS1jcmVhdGluZyB0aGVzZVxuXG5jb25zdCBFTVBUWV9BUlJBWSA9IFtudWxsLCAwXTtcbmNvbnN0IE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTsgLy8gQXR0ZW1wdHMgdG8gc3RyaW5naWZ5IHdoYXRldmVyIG5vdC1yZWFsbHktYS1jb21wb25lbnQgdmFsdWUgd2Ugd2VyZSBnaXZlblxuLy8gZm9yIGxvZ2dpbmcgaW4gYW4gZXJyb3IgbWVzc2FnZVxuXG5jb25zdCBzdHJpbmdpZnlDb21wb25lbnQgPSBDb21wID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQ29tcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcoQ29tcCk7XG4gIH1cbn07XG5cbi8vIFRoaXMgaXMgXCJqdXN0XCIgYSBgdXNlTGF5b3V0RWZmZWN0YCwgYnV0IHdpdGggdHdvIG1vZGlmaWNhdGlvbnM6XG4vLyAtIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGB1c2VFZmZlY3RgIGluIFNTUiB0byBhdm9pZCBhbm5veWluZyB3YXJuaW5nc1xuLy8gLSB3ZSBleHRyYWN0IHRoaXMgdG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCBjbG9zaW5nIG92ZXIgdmFsdWVzXG4vLyAgIGFuZCBjYXVzaW5nIG1lbW9yeSBsZWFrc1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59IC8vIEVmZmVjdCBjYWxsYmFjaywgZXh0cmFjdGVkOiBhc3NpZ24gdGhlIGxhdGVzdCBwcm9wcyB2YWx1ZXMgdG8gcmVmcyBmb3IgbGF0ZXIgdXNhZ2VcblxuXG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCAvLyBhY3R1YWxDaGlsZFByb3BzOiB1bmtub3duLFxuY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICAvLyBXZSB3YW50IHRvIGNhcHR1cmUgdGhlIHdyYXBwZXIgcHJvcHMgYW5kIGNoaWxkIHByb3BzIHdlIHVzZWQgZm9yIGxhdGVyIGNvbXBhcmlzb25zXG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlOyAvLyBJZiB0aGUgcmVuZGVyIHdhcyBmcm9tIGEgc3RvcmUgdXBkYXRlLCBjbGVhciBvdXQgdGhhdCByZWZlcmVuY2UgYW5kIGNhc2NhZGUgdGhlIHN1YnNjcmliZXIgdXBkYXRlXG5cbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59IC8vIEVmZmVjdCBjYWxsYmFjaywgZXh0cmFjdGVkOiBzdWJzY3JpYmUgdG8gdGhlIFJlZHV4IHN0b3JlIG9yIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLFxuLy8gY2hlY2sgZm9yIHVwZGF0ZXMgYWZ0ZXIgZGlzcGF0Y2hlZCBhY3Rpb25zLCBhbmQgdHJpZ2dlciByZS1yZW5kZXJzLlxuXG5cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCAvLyBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxhbnk+LFxuYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKSB7XG4gIC8vIElmIHdlJ3JlIG5vdCBzdWJzY3JpYmVkIHRvIHRoZSBzdG9yZSwgbm90aGluZyB0byBkbyBoZXJlXG4gIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gKCkgPT4ge307IC8vIENhcHR1cmUgdmFsdWVzIGZvciBjaGVja2luZyBpZiBhbmQgd2hlbiB0aGlzIGNvbXBvbmVudCB1bm1vdW50c1xuXG4gIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xuICBsZXQgbGFzdFRocm93bkVycm9yID0gbnVsbDsgLy8gV2UnbGwgcnVuIHRoaXMgY2FsbGJhY2sgZXZlcnkgdGltZSBhIHN0b3JlIHN1YnNjcmlwdGlvbiB1cGRhdGUgcHJvcGFnYXRlcyB0byB0aGlzIGNvbXBvbmVudFxuXG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUgfHwgIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAvLyBEb24ndCBydW4gc3RhbGUgbGlzdGVuZXJzLlxuICAgICAgLy8gUmVkdXggZG9lc24ndCBndWFyYW50ZWUgdW5zdWJzY3JpcHRpb25zIGhhcHBlbiB1bnRpbCBuZXh0IGRpc3BhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVE9ETyBXZSdyZSBjdXJyZW50bHkgY2FsbGluZyBnZXRTdGF0ZSBvdXJzZWx2ZXMgaGVyZSwgcmF0aGVyIHRoYW4gbGV0dGluZyBgdVNFU2AgZG8gaXRcblxuXG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgbGV0IG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFjdHVhbGx5IHJ1biB0aGUgc2VsZWN0b3Igd2l0aCB0aGUgbW9zdCByZWNlbnQgc3RvcmUgc3RhdGUgYW5kIHdyYXBwZXIgcHJvcHNcbiAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmVcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IobGF0ZXN0U3RvcmVTdGF0ZSwgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfSAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgaGF2ZW4ndCBjaGFuZ2VkLCBub3RoaW5nIHRvIGRvIGhlcmUgLSBjYXNjYWRlIHRoZSBzdWJzY3JpcHRpb24gdXBkYXRlXG5cblxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTYXZlIHJlZmVyZW5jZXMgdG8gdGhlIG5ldyBjaGlsZCBwcm9wcy4gIE5vdGUgdGhhdCB3ZSB0cmFjayB0aGUgXCJjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZVwiXG4gICAgICAvLyBhcyBhIHJlZiBpbnN0ZWFkIG9mIGEgdXNlU3RhdGUvdXNlUmVkdWNlciBiZWNhdXNlIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoYXQgdmFsdWUgaGFzXG4gICAgICAvLyBiZWVuIHByb2Nlc3NlZC4gIElmIHRoaXMgd2VudCBpbnRvIHVzZVN0YXRlL3VzZVJlZHVjZXIsIHdlIGNvdWxkbid0IGNsZWFyIG91dCB0aGUgdmFsdWUgd2l0aG91dFxuICAgICAgLy8gZm9yY2luZyBhbm90aGVyIHJlLXJlbmRlciwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlOyAvLyBUT0RPIFRoaXMgaXMgaGFja3kgYW5kIG5vdCBob3cgYHVTRVNgIGlzIG1lYW50IHRvIGJlIHVzZWRcbiAgICAgIC8vIFRyaWdnZXIgdGhlIFJlYWN0IGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgc3Vic2NyaWJlclxuXG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07IC8vIEFjdHVhbGx5IHN1YnNjcmliZSB0byB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IgKG9yIHN0b3JlKVxuXG5cbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTsgLy8gUHVsbCBkYXRhIGZyb20gdGhlIHN0b3JlIGFmdGVyIGZpcnN0IHJlbmRlciBpbiBjYXNlIHRoZSBzdG9yZSBoYXNcbiAgLy8gY2hhbmdlZCBzaW5jZSB3ZSBiZWdhbi5cblxuICBjaGVja0ZvclVwZGF0ZXMoKTtcblxuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcblxuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3ZSBjYXVnaHQgYW4gZXJyb3IgZHVlIHRvIGEgYmFkIG1hcFN0YXRlIGZ1bmN0aW9uLCBidXQgdGhlXG4gICAgICAvLyBwYXJlbnQgcmUtcmVuZGVyZWQgd2l0aG91dCB0aGlzIGNvbXBvbmVudCBhbmQgd2UncmUgYWJvdXQgdG8gdW5tb3VudC5cbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBhcyBsb25nIGFzIHdlIGRvIHRvcC1kb3duIHN1YnNjcmlwdGlvbnMgY29ycmVjdGx5LCBidXRcbiAgICAgIC8vIGlmIHdlIGV2ZXIgZG8gdGhvc2Ugd3JvbmcsIHRoaXMgdGhyb3cgd2lsbCBzdXJmYWNlIHRoZSBlcnJvciBpbiBvdXIgdGVzdHMuXG4gICAgICAvLyBJbiB0aGF0IGNhc2UsIHRocm93IHRoZSBlcnJvciBmcm9tIGhlcmUgc28gaXQgZG9lc24ndCBnZXQgbG9zdC5cbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn0gLy8gUmVkdWNlciBpbml0aWFsIHN0YXRlIGNyZWF0aW9uIGZvciBvdXIgdXBkYXRlIHJlZHVjZXJcblxuXG5jb25zdCBpbml0U3RhdGVVcGRhdGVzID0gKCkgPT4gRU1QVFlfQVJSQVk7XG5cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG4vKipcclxuICogSW5mZXJzIHRoZSB0eXBlIG9mIHByb3BzIHRoYXQgYSBjb25uZWN0b3Igd2lsbCBpbmplY3QgaW50byBhIGNvbXBvbmVudC5cclxuICovXG5cblxubGV0IGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcbi8qKlxyXG4gKiBDb25uZWN0cyBhIFJlYWN0IGNvbXBvbmVudCB0byBhIFJlZHV4IHN0b3JlLlxyXG4gKlxyXG4gKiAtIFdpdGhvdXQgYXJndW1lbnRzLCBqdXN0IHdyYXBzIHRoZSBjb21wb25lbnQsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGJlaGF2aW9yIC8gcHJvcHNcclxuICpcclxuICogLSBJZiAyIHBhcmFtcyBhcmUgcGFzc2VkICgzcmQgcGFyYW0sIG1lcmdlUHJvcHMsIGlzIHNraXBwZWQpLCBkZWZhdWx0IGJlaGF2aW9yXHJcbiAqIGlzIHRvIG92ZXJyaWRlIG93blByb3BzIChhcyBzdGF0ZWQgaW4gdGhlIGRvY3MpLCBzbyB3aGF0IHJlbWFpbnMgaXMgZXZlcnl0aGluZyB0aGF0J3NcclxuICogbm90IGEgc3RhdGUgb3IgZGlzcGF0Y2ggcHJvcFxyXG4gKlxyXG4gKiAtIFdoZW4gM3JkIHBhcmFtIGlzIHBhc3NlZCwgd2UgZG9uJ3Qga25vdyBpZiBvd25Qcm9wcyBwcm9wYWdhdGUgYW5kIHdoZXRoZXIgdGhleVxyXG4gKiBzaG91bGQgYmUgdmFsaWQgY29tcG9uZW50IHByb3BzLCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gbWVyZ2VQcm9wcyBpbXBsZW1lbnRhdGlvbi5cclxuICogQXMgc3VjaCwgaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBleHRlbmQgb3duUHJvcHMgaW50ZXJmYWNlIGZyb20gc3RhdGUgb3JcclxuICogZGlzcGF0Y2ggcHJvcHMgb3IgYm90aCB3aGVuIGFwcGxpY2FibGVcclxuICpcclxuICogQHBhcmFtIG1hcFN0YXRlVG9Qcm9wcyBBIGZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgdmFsdWVzIGZyb20gc3RhdGVcclxuICogQHBhcmFtIG1hcERpc3BhdGNoVG9Qcm9wcyBTZXR1cCBmb3IgZGlzcGF0Y2hpbmcgYWN0aW9uc1xyXG4gKiBAcGFyYW0gbWVyZ2VQcm9wcyBPcHRpb25hbCBjYWxsYmFjayB0byBtZXJnZSBzdGF0ZSBhbmQgZGlzcGF0Y2ggcHJvcHMgdG9nZXRoZXJcclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIGNvbm5lY3Rpb25cclxuICpcclxuICovXG5cbmZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIHtcbiAgLy8gVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCwgc28gVFMgZG9lc24ndCBsaWtlIHVzIGRlc3RydWN0dXJpbmcgdGhpcyB0byBjaGVjayBpdHMgZXhpc3RlbmNlLlxuICAvLyBAdHMtaWdub3JlXG4gIHB1cmUsXG4gIGFyZVN0YXRlc0VxdWFsID0gc3RyaWN0RXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gIGZvcndhcmRSZWYgPSBmYWxzZSxcbiAgLy8gdGhlIGNvbnRleHQgY29uc3VtZXIgdG8gdXNlXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxufSA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHB1cmUgIT09IHVuZGVmaW5lZCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKCdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0O1xuICBjb25zdCBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpO1xuICBjb25zdCBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG5cbiAgY29uc3Qgd3JhcFdpdGhDb25uZWN0ID0gV3JhcHBlZENvbXBvbmVudCA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBjb25uZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7c3RyaW5naWZ5Q29tcG9uZW50KFdyYXBwZWRDb21wb25lbnQpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBgQ29ubmVjdCgke3dyYXBwZWRDb21wb25lbnROYW1lfSlgO1xuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGFjdHVhbCBcImRhdGFcIiBwcm9wcyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVyIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYW5kIHZhbHVlcyBuZWVkZWQgdG8gY29udHJvbCBiZWhhdmlvciAoZm9yd2FyZGVkIHJlZnMsIGFsdGVybmF0ZSBjb250ZXh0IGluc3RhbmNlcykuXG4gICAgICAgIC8vIFRvIG1haW50YWluIHRoZSB3cmFwcGVyUHJvcHMgb2JqZWN0IHJlZmVyZW5jZSwgbWVtb2l6ZSB0aGlzIGRlc3RydWN0dXJpbmcuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgIH0gPSBwcm9wcyxcbiAgICAgICAgICAgICAgd3JhcHBlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgLy8gVXNlcnMgbWF5IG9wdGlvbmFsbHkgcGFzcyBpbiBhIGN1c3RvbSBjb250ZXh0IGluc3RhbmNlIHRvIHVzZSBpbnN0ZWFkIG9mIG91ciBSZWFjdFJlZHV4Q29udGV4dC5cbiAgICAgICAgLy8gTWVtb2l6ZSB0aGUgY2hlY2sgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIGNvbnRleHQgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZS5cbiAgICAgICAgcmV0dXJuIHByb3BzQ29udGV4dCAmJiBwcm9wc0NvbnRleHQuQ29uc3VtZXIgJiYgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpc0NvbnRleHRDb25zdW1lciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHNDb250ZXh0LkNvbnN1bWVyLCBudWxsKSkgPyBwcm9wc0NvbnRleHQgOiBDb250ZXh0O1xuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pOyAvLyBSZXRyaWV2ZSB0aGUgc3RvcmUgYW5kIGFuY2VzdG9yIHN1YnNjcmlwdGlvbiB2aWEgY29udGV4dCwgaWYgYXZhaWxhYmxlXG5cbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTsgLy8gVGhlIHN0b3JlIF9tdXN0XyBleGlzdCBhcyBlaXRoZXIgYSBwcm9wIG9yIGluIGNvbnRleHQuXG4gICAgICAvLyBXZSdsbCBjaGVjayB0byBzZWUgaWYgaXQgX2xvb2tzXyBsaWtlIGEgUmVkdXggc3RvcmUgZmlyc3QuXG4gICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBwYXNzIHRocm91Z2ggYSBgc3RvcmVgIHByb3AgdGhhdCBpcyBqdXN0IGEgcGxhaW4gdmFsdWUuXG5cbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPSBCb29sZWFuKGNvbnRleHRWYWx1ZSkgJiYgQm9vbGVhbihjb250ZXh0VmFsdWUuc3RvcmUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiB0aGUgY29udGV4dCBvZiBgICsgYFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgYCArIGBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgYCArIGBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvICR7ZGlzcGxheU5hbWV9IGluIGNvbm5lY3Qgb3B0aW9ucy5gKTtcbiAgICAgIH0gLy8gQmFzZWQgb24gdGhlIHByZXZpb3VzIGNoZWNrLCBvbmUgb2YgdGhlc2UgbXVzdCBiZSB0cnVlXG5cblxuICAgICAgY29uc3Qgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBUaGUgY2hpbGQgcHJvcHMgc2VsZWN0b3IgbmVlZHMgdGhlIHN0b3JlIHJlZmVyZW5jZSBhcyBhbiBpbnB1dC5cbiAgICAgICAgLy8gUmUtY3JlYXRlIHRoaXMgc2VsZWN0b3Igd2hlbmV2ZXIgdGhlIHN0b3JlIGNoYW5nZXMuXG4gICAgICAgIHJldHVybiBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICAgIH0sIFtzdG9yZV0pO1xuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7IC8vIFRoaXMgU3Vic2NyaXB0aW9uJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG5cbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB1bmRlZmluZWQgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uKTsgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLCB3aGVyZSBgc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gVGhpcyBjYW5cbiAgICAgICAgLy8gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24ncyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZSAgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cblxuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic107XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7IC8vIERldGVybWluZSB3aGF0IHtzdG9yZSwgc3Vic2NyaXB0aW9ufSB2YWx1ZSBzaG91bGQgYmUgcHV0IGludG8gbmVzdGVkIGNvbnRleHQsIGlmIG5lY2Vzc2FyeSxcbiAgICAgIC8vIGFuZCBtZW1vaXplIHRoYXQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udGV4dCB1cGRhdGVzLlxuXG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBkaXJlY3RseSBzdWJzY3JpYmVkIHRvIGEgc3RvcmUgZnJvbSBwcm9wcy5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGRlc2NlbmRhbnRzIHJlYWRpbmcgZnJvbSB0aGlzIHN0b3JlIC0gcGFzcyBkb3duIHdoYXRldmVyXG4gICAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGNvbnRleHQgdmFsdWUgaXMgZnJvbSB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIHB1dCB0aGlzIGNvbXBvbmVudCdzIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBpbnRvIGNvbnRleHQsIHNvIHRoYXRcbiAgICAgICAgLy8gY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdvbid0IHVwZGF0ZSB1bnRpbCBhZnRlciB0aGlzIGNvbXBvbmVudCBpcyBkb25lXG5cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHRWYWx1ZSwge1xuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSk7IC8vIFNldCB1cCByZWZzIHRvIGNvb3JkaW5hdGUgdmFsdWVzIGJldHdlZW4gdGhlIHN1YnNjcmlwdGlvbiBlZmZlY3QgYW5kIHRoZSByZW5kZXIgbG9naWNcblxuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSBSZWFjdC51c2VSZWYoKTtcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzUHJvY2Vzc2luZ0Rpc3BhdGNoID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVHJpY2t5IGxvZ2ljIGhlcmU6XG4gICAgICAgICAgLy8gLSBUaGlzIHJlbmRlciBtYXkgaGF2ZSBiZWVuIHRyaWdnZXJlZCBieSBhIFJlZHV4IHN0b3JlIHVwZGF0ZSB0aGF0IHByb2R1Y2VkIG5ldyBjaGlsZCBwcm9wc1xuICAgICAgICAgIC8vIC0gSG93ZXZlciwgd2UgbWF5IGhhdmUgZ290dGVuIG5ldyB3cmFwcGVyIHByb3BzIGFmdGVyIHRoYXRcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5ldyBjaGlsZCBwcm9wcywgYW5kIHRoZSBzYW1lIHdyYXBwZXIgcHJvcHMsIHdlIGtub3cgd2Ugc2hvdWxkIHVzZSB0aGUgbmV3IGNoaWxkIHByb3BzIGFzLWlzLlxuICAgICAgICAgIC8vIEJ1dCwgaWYgd2UgaGF2ZSBuZXcgd3JhcHBlciBwcm9wcywgdGhvc2UgbWlnaHQgY2hhbmdlIHRoZSBjaGlsZCBwcm9wcywgc28gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGluZ3MuXG4gICAgICAgICAgLy8gU28sIHdlJ2xsIHVzZSB0aGUgY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGUgb25seSBpZiB0aGUgd3JhcHBlciBwcm9wcyBhcmUgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLlxuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfSAvLyBUT0RPIFdlJ3JlIHJlYWRpbmcgdGhlIHN0b3JlIGRpcmVjdGx5IGluIHJlbmRlcigpIGhlcmUuIEJhZCBpZGVhP1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgQmFkIFRoaW5ncyAoVE0pIHRvIGhhcHBlbiBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIHRoaXMgYmVjYXVzZSBvbiByZW5kZXJzIF9ub3RfIGNhdXNlZCBieSBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRoZSBsYXRlc3Qgc3RvcmUgc3RhdGVcbiAgICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlLlxuXG5cbiAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc1NlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHdyYXBwZXJQcm9wcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTsgLy8gV2UgbmVlZCB0aGlzIHRvIGV4ZWN1dGUgc3luY2hyb25vdXNseSBldmVyeSB0aW1lIHdlIHJlLXJlbmRlci4gSG93ZXZlciwgUmVhY3Qgd2FybnNcbiAgICAgIC8vIGFib3V0IHVzZUxheW91dEVmZmVjdCBpbiBTU1IsIHNvIHdlIHRyeSB0byBkZXRlY3QgZW52aXJvbm1lbnQgYW5kIGZhbGwgYmFjayB0b1xuICAgICAgLy8ganVzdCB1c2VFZmZlY3QgaW5zdGVhZCB0byBhdm9pZCB0aGUgd2FybmluZywgc2luY2UgbmVpdGhlciB3aWxsIHJ1biBhbnl3YXkuXG5cbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IHJlYWN0TGlzdGVuZXIgPT4ge1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGlzTW91bnRlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgcmVhY3RMaXN0ZW5lcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICAgIH0sIFtzdWJzY3JpcHRpb25dKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnNdKTtcbiAgICAgIGxldCBhY3R1YWxDaGlsZFByb3BzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gdXNlU3luY0V4dGVybmFsU3RvcmUoIC8vIFRPRE8gV2UncmUgcGFzc2luZyB0aHJvdWdoIGEgYmlnIHdyYXBwZXIgdGhhdCBkb2VzIGEgYnVuY2ggb2YgZXh0cmEgc2lkZSBlZmZlY3RzIGJlc2lkZXMgc3Vic2NyaWJpbmdcbiAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgLy8gVE9ETyBhbmQgd2UncmUganVzdCBwYXNzaW5nIHRoYXQgdGhyb3VnaCBzbyBpdCB0cmlnZ2VycyBhIHJlLXJlbmRlciBmb3IgdXMgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBgdVNFU2AuXG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciwgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3Rvcik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlcnIubWVzc2FnZSArPSBgXFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcXG4ke2xhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFja31cXG5cXG5gO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBhY3R1YWxDaGlsZFByb3BzO1xuICAgICAgfSk7IC8vIE5vdyB0aGF0IGFsbCB0aGF0J3MgZG9uZSwgd2UgY2FuIGZpbmFsbHkgdHJ5IHRvIGFjdHVhbGx5IHJlbmRlciB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgLy8gV2UgbWVtb2l6ZSB0aGUgZWxlbWVudHMgZm9yIHRoZSByZW5kZXJlZCBjaGlsZCBjb21wb25lbnQgYXMgYW4gb3B0aW1pemF0aW9uLlxuXG4gICAgICBjb25zdCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGFjdHVhbENoaWxkUHJvcHMsIHtcbiAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgIH0pKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTsgLy8gSWYgUmVhY3Qgc2VlcyB0aGUgZXhhY3Qgc2FtZSBlbGVtZW50IHJlZmVyZW5jZSBhcyBsYXN0IHRpbWUsIGl0IGJhaWxzIG91dCBvZiByZS1yZW5kZXJpbmdcbiAgICAgIC8vIHRoYXQgY2hpbGQsIHNhbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gUmVhY3QubWVtbygpIG9yIHJldHVybmVkIGZhbHNlIGZyb20gc2hvdWxkQ29tcG9uZW50VXBkYXRlLlxuXG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCBpcyBzdWJzY3JpYmVkIHRvIHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdG8gcGFzcyBpdHMgb3duXG4gICAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGluc3RhbmNlIGRvd24gdG8gb3VyIGRlc2NlbmRhbnRzLiBUaGF0IG1lYW5zIHJlbmRlcmluZyB0aGUgc2FtZVxuICAgICAgICAgIC8vIENvbnRleHQgaW5zdGFuY2UsIGFuZCBwdXR0aW5nIGEgZGlmZmVyZW50IHZhbHVlIGludG8gdGhlIGNvbnRleHQuXG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWVcbiAgICAgICAgICB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuXG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG5cbiAgICAvLyBBZGQgYSBoYWNreSBjYXN0IHRvIGdldCB0aGUgcmlnaHQgb3V0cHV0IHR5cGVcbiAgICBjb25zdCBDb25uZWN0ID0gX0Nvbm5lY3Q7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gZm9yd2FyZENvbm5lY3RSZWYocHJvcHMsIHJlZikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQ7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiBob2lzdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuXG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3Q7Il0sIm5hbWVzIjpbIl9leHRlbmRzIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfZXhjbHVkZWQiLCJob2lzdFN0YXRpY3MiLCJSZWFjdCIsImlzVmFsaWRFbGVtZW50VHlwZSIsImlzQ29udGV4dENvbnN1bWVyIiwiZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwibWVyZ2VQcm9wc0ZhY3RvcnkiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0Iiwic2hhbGxvd0VxdWFsIiwid2FybmluZyIsIlJlYWN0UmVkdXhDb250ZXh0Iiwibm90SW5pdGlhbGl6ZWQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsImluaXRpYWxpemVDb25uZWN0IiwiZm4iLCJFTVBUWV9BUlJBWSIsIk5PX1NVQlNDUklQVElPTl9BUlJBWSIsInN0cmluZ2lmeUNvbXBvbmVudCIsIkNvbXAiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwiU3RyaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzIiwiZWZmZWN0RnVuYyIsImVmZmVjdEFyZ3MiLCJkZXBlbmRlbmNpZXMiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwibm90aWZ5TmVzdGVkU3VicyIsImN1cnJlbnQiLCJzdWJzY3JpYmVVcGRhdGVzIiwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzIiwic3RvcmUiLCJzdWJzY3JpcHRpb24iLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJnZXRTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJlcnJvciIsImUiLCJvblN0YXRlQ2hhbmdlIiwidHJ5U3Vic2NyaWJlIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwidHJ5VW5zdWJzY3JpYmUiLCJpbml0U3RhdGVVcGRhdGVzIiwic3RyaWN0RXF1YWwiLCJhIiwiYiIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24iLCJjb25uZWN0IiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmUiLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiZm9yd2FyZFJlZiIsImNvbnRleHQiLCJwcm9jZXNzIiwidW5kZWZpbmVkIiwiQ29udGV4dCIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJCb29sZWFuIiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsIkVycm9yIiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwicHJvcHMiLCJwcm9wc0NvbnRleHQiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsIkNvbnRleHRUb1VzZSIsIkNvbnN1bWVyIiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaXNwYXRjaCIsImRpZFN0b3JlQ29tZUZyb21Db250ZXh0IiwiZ2V0U2VydmVyU3RhdGUiLCJiaW5kIiwib3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSIsInVzZVJlZiIsImlzUHJvY2Vzc2luZ0Rpc3BhdGNoIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInNlbGVjdG9yIiwic3Vic2NyaWJlRm9yUmVhY3QiLCJzdWJzY3JpYmUiLCJyZWFjdExpc3RlbmVyIiwiYWN0dWFsQ2hpbGRQcm9wcyIsIm1lc3NhZ2UiLCJzdGFjayIsInJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCIsInJlZiIsInJlbmRlcmVkQ2hpbGQiLCJQcm92aWRlciIsInZhbHVlIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/components/connect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/invalidArgFactory.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/invalidArgFactory.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createInvalidArgFactory: function() { return /* binding */ createInvalidArgFactory; }\n/* harmony export */ });\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(\"Invalid value of type \".concat(typeof arg, \" for \").concat(name, \" argument when connecting component \").concat(options.wrappedComponentName, \".\"));\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSx3QkFBd0JDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQyxPQUFPLENBQUNDLFVBQVVDO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTSx5QkFBMkNILE9BQWxCLE9BQU9ELEtBQUksU0FBa0RHLE9BQTNDRixNQUFLLHdDQUFtRSxPQUE3QkUsUUFBUUUsb0JBQW9CLEVBQUM7SUFDckk7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9pbnZhbGlkQXJnRmFjdG9yeS5qcz80NDM2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFyZ30gZm9yICR7bmFtZX0gYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAke29wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWV9LmApO1xuICB9O1xufSJdLCJuYW1lcyI6WyJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsImFyZyIsIm5hbWUiLCJkaXNwYXRjaCIsIm9wdGlvbnMiLCJFcnJvciIsIndyYXBwZWRDb21wb25lbnROYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/invalidArgFactory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/mapDispatchToProps.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/mapDispatchToProps.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapDispatchToPropsFactory: function() { return /* binding */ mapDispatchToPropsFactory; }\n/* harmony export */ });\n/* harmony import */ var _utils_bindActionCreators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/bindActionCreators */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/bindActionCreators.js\");\n/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrapMapToProps */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/wrapMapToProps.js\");\n/* harmony import */ var _invalidArgFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./invalidArgFactory */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/invalidArgFactory.js\");\n\n\n\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? (0,_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__.wrapMapToPropsConstant)((dispatch)=>(0,_utils_bindActionCreators__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? (0,_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__.wrapMapToPropsConstant)((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? (0,_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__.wrapMapToPropsFunc)(mapDispatchToProps, \"mapDispatchToProps\") : (0,_invalidArgFactory__WEBPACK_IMPORTED_MODULE_2__.createInvalidArgFactory)(mapDispatchToProps, \"mapDispatchToProps\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2lCO0FBQ2hCO0FBQ3ZELFNBQVNJLDBCQUEwQkMsa0JBQWtCO0lBQzFELE9BQU9BLHNCQUFzQixPQUFPQSx1QkFBdUIsV0FBV0osdUVBQXNCQSxDQUFDSyxDQUFBQSxXQUM3Rk4scUVBQWtCQSxDQUFDSyxvQkFBb0JDLGFBQWEsQ0FBQ0QscUJBQXFCSix1RUFBc0JBLENBQUNLLENBQUFBLFdBQWE7WUFDNUdBO1FBQ0YsTUFBTSxPQUFPRCx1QkFBdUIsYUFDcENILG1FQUFrQkEsQ0FBQ0csb0JBQW9CLHdCQUF3QkYsMkVBQXVCQSxDQUFDRSxvQkFBb0I7QUFDN0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzPzJiMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJpbmRBY3Rpb25DcmVhdG9ycyBmcm9tICcuLi91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSB9IGZyb20gJy4vaW52YWxpZEFyZ0ZhY3RvcnknO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ29iamVjdCcgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGRpc3BhdGNoID0+IC8vIEB0cy1pZ25vcmVcbiAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGRpc3BhdGNoID0+ICh7XG4gICAgZGlzcGF0Y2hcbiAgfSkpIDogdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IC8vIEB0cy1pZ25vcmVcbiAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG59Il0sIm5hbWVzIjpbImJpbmRBY3Rpb25DcmVhdG9ycyIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJkaXNwYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/mapDispatchToProps.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/mapStateToProps.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/mapStateToProps.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapStateToPropsFactory: function() { return /* binding */ mapStateToPropsFactory; }\n/* harmony export */ });\n/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapMapToProps */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/wrapMapToProps.js\");\n/* harmony import */ var _invalidArgFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invalidArgFactory */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/invalidArgFactory.js\");\n\n\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? (0,_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__.wrapMapToPropsConstant)(()=>({})) : typeof mapStateToProps === \"function\" ? (0,_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__.wrapMapToPropsFunc)(mapStateToProps, \"mapStateToProps\") : (0,_invalidArgFactory__WEBPACK_IMPORTED_MODULE_1__.createInvalidArgFactory)(mapStateToProps, \"mapStateToProps\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEU7QUFDaEI7QUFDdkQsU0FBU0csdUJBQXVCQyxlQUFlO0lBQ3BELE9BQU8sQ0FBQ0Esa0JBQWtCSix1RUFBc0JBLENBQUMsSUFBTyxFQUFDLE1BQU0sT0FBT0ksb0JBQW9CLGFBQzFGSCxtRUFBa0JBLENBQUNHLGlCQUFpQixxQkFBcUJGLDJFQUF1QkEsQ0FBQ0UsaUJBQWlCO0FBQ3BHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcz9iZWYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5JztcbmV4cG9ydCBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcFN0YXRlVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSkgOiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gLy8gQHRzLWlnbm9yZVxuICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbn0iXSwibmFtZXMiOlsid3JhcE1hcFRvUHJvcHNDb25zdGFudCIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IiwibWFwU3RhdGVUb1Byb3BzRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/mapStateToProps.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/mergeProps.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-redux/es/connect/mergeProps.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultMergeProps: function() { return /* binding */ defaultMergeProps; },\n/* harmony export */   mergePropsFactory: function() { return /* binding */ mergePropsFactory; },\n/* harmony export */   wrapMergePropsFunc: function() { return /* binding */ wrapMergePropsFunc; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/verifyPlainObject */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/verifyPlainObject.js\");\n/* harmony import */ var _invalidArgFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./invalidArgFactory */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/invalidArgFactory.js\");\n\n\n\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    // @ts-ignore\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, ownProps, stateProps, dispatchProps);\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, param) {\n        let { displayName, areMergedPropsEqual } = param;\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) (0,_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : (0,_invalidArgFactory__WEBPACK_IMPORTED_MODULE_2__.createInvalidArgFactory)(mergeProps, \"mergeProps\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21lcmdlUHJvcHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBEO0FBQ0M7QUFDRztBQUN2RCxTQUFTRyxrQkFBa0JDLFVBQVUsRUFBRUMsYUFBYSxFQUFFQyxRQUFRO0lBQ25FLGFBQWE7SUFDYixPQUFPTiw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdNLFVBQVVGLFlBQVlDO0FBQzVDO0FBQ08sU0FBU0UsbUJBQW1CQyxVQUFVO0lBQzNDLE9BQU8sU0FBU0Msb0JBQW9CQyxRQUFRLEVBQUUsS0FHN0M7WUFINkMsRUFDNUNDLFdBQVcsRUFDWEMsbUJBQW1CLEVBQ3BCLEdBSDZDO1FBSTVDLElBQUlDLGFBQWE7UUFDakIsSUFBSUM7UUFDSixPQUFPLFNBQVNDLGdCQUFnQlgsVUFBVSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7WUFDakUsTUFBTVUsa0JBQWtCUixXQUFXSixZQUFZQyxlQUFlQztZQUU5RCxJQUFJTyxZQUFZO2dCQUNkLElBQUksQ0FBQ0Qsb0JBQW9CSSxpQkFBaUJGLGNBQWNBLGNBQWNFO1lBQ3hFLE9BQU87Z0JBQ0xILGFBQWE7Z0JBQ2JDLGNBQWNFO2dCQUNkLElBQUlDLElBQXlCLEVBQWNoQixvRUFBaUJBLENBQUNhLGFBQWFILGFBQWE7WUFDekY7WUFFQSxPQUFPRztRQUNUO0lBQ0Y7QUFDRjtBQUNPLFNBQVNJLGtCQUFrQlYsVUFBVTtJQUMxQyxPQUFPLENBQUNBLGFBQWEsSUFBTUwsb0JBQW9CLE9BQU9LLGVBQWUsYUFBYUQsbUJBQW1CQyxjQUFjTiwyRUFBdUJBLENBQUNNLFlBQVk7QUFDekoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcz9hNzFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcbmltcG9ydCB7IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5IH0gZnJvbSAnLi9pbnZhbGlkQXJnRmFjdG9yeSc7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gX2V4dGVuZHMoe30sIG93blByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwge1xuICAgIGRpc3BsYXlOYW1lLFxuICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgfSkge1xuICAgIGxldCBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgbGV0IG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIGNvbnN0IG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/ICgpID0+IGRlZmF1bHRNZXJnZVByb3BzIDogdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycpO1xufSJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsInZlcmlmeVBsYWluT2JqZWN0IiwiY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwib3duUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJtZXJnZVByb3BzIiwiaW5pdE1lcmdlUHJvcHNQcm94eSIsImRpc3BhdGNoIiwiZGlzcGxheU5hbWUiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlZFByb3BzIiwibWVyZ2VQcm9wc1Byb3h5IiwibmV4dE1lcmdlZFByb3BzIiwicHJvY2VzcyIsIm1lcmdlUHJvcHNGYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/mergeProps.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/selectorFactory.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/selectorFactory.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ finalPropsSelectorFactory; },\n/* harmony export */   pureFinalPropsSelectorFactory: function() { return /* binding */ pureFinalPropsSelectorFactory; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n/* harmony import */ var _verifySubselectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./verifySubselectors */ \"(app-pages-browser)/./node_modules/react-redux/es/connect/verifySubselectors.js\");\n\nconst _excluded = [\n    \"initMapStateToProps\",\n    \"initMapDispatchToProps\",\n    \"initMergeProps\"\n];\n\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, param) {\n    let { areStatesEqual, areOwnPropsEqual, areStatePropsEqual } = param;\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\n// TODO: Add more comments\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\nfunction finalPropsSelectorFactory(dispatch, _ref) {\n    let { initMapStateToProps, initMapDispatchToProps, initMergeProps } = _ref, options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_ref, _excluded);\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        (0,_verifySubselectors__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9HO0FBQ3BHLE1BQU1DLFlBQVk7SUFBQztJQUF1QjtJQUEwQjtDQUFpQjtBQUMvQjtBQUMvQyxTQUFTRSw4QkFBOEJDLGVBQWUsRUFBRUMsa0JBQWtCLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFLEtBSXhHO1FBSndHLEVBQ3ZHQyxjQUFjLEVBQ2RDLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ25CLEdBSndHO0lBS3ZHLElBQUlDLG9CQUFvQjtJQUN4QixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBRUosU0FBU0MsZ0JBQWdCQyxVQUFVLEVBQUVDLGFBQWE7UUFDaERQLFFBQVFNO1FBQ1JMLFdBQVdNO1FBQ1hMLGFBQWFWLGdCQUFnQlEsT0FBT0M7UUFDcENFLGdCQUFnQlYsbUJBQW1CRSxVQUFVTTtRQUM3Q0csY0FBY1YsV0FBV1EsWUFBWUMsZUFBZUY7UUFDcERGLG9CQUFvQjtRQUNwQixPQUFPSztJQUNUO0lBRUEsU0FBU0k7UUFDUE4sYUFBYVYsZ0JBQWdCUSxPQUFPQztRQUNwQyxJQUFJUixtQkFBbUJnQixpQkFBaUIsRUFBRU4sZ0JBQWdCVixtQkFBbUJFLFVBQVVNO1FBQ3ZGRyxjQUFjVixXQUFXUSxZQUFZQyxlQUFlRjtRQUNwRCxPQUFPRztJQUNUO0lBRUEsU0FBU007UUFDUCxJQUFJbEIsZ0JBQWdCaUIsaUJBQWlCLEVBQUVQLGFBQWFWLGdCQUFnQlEsT0FBT0M7UUFDM0UsSUFBSVIsbUJBQW1CZ0IsaUJBQWlCLEVBQUVOLGdCQUFnQlYsbUJBQW1CRSxVQUFVTTtRQUN2RkcsY0FBY1YsV0FBV1EsWUFBWUMsZUFBZUY7UUFDcEQsT0FBT0c7SUFDVDtJQUVBLFNBQVNPO1FBQ1AsTUFBTUMsaUJBQWlCcEIsZ0JBQWdCUSxPQUFPQztRQUM5QyxNQUFNWSxvQkFBb0IsQ0FBQ2YsbUJBQW1CYyxnQkFBZ0JWO1FBQzlEQSxhQUFhVTtRQUNiLElBQUlDLG1CQUFtQlQsY0FBY1YsV0FBV1EsWUFBWUMsZUFBZUY7UUFDM0UsT0FBT0c7SUFDVDtJQUVBLFNBQVNVLHNCQUFzQkMsU0FBUyxFQUFFQyxZQUFZO1FBQ3BELE1BQU1DLGVBQWUsQ0FBQ3BCLGlCQUFpQm1CLGNBQWNmO1FBQ3JELE1BQU1pQixlQUFlLENBQUN0QixlQUFlbUIsV0FBV2YsT0FBT2dCLGNBQWNmO1FBQ3JFRCxRQUFRZTtRQUNSZCxXQUFXZTtRQUNYLElBQUlDLGdCQUFnQkMsY0FBYyxPQUFPVjtRQUN6QyxJQUFJUyxjQUFjLE9BQU9QO1FBQ3pCLElBQUlRLGNBQWMsT0FBT1A7UUFDekIsT0FBT1A7SUFDVDtJQUVBLE9BQU8sU0FBU2UsdUJBQXVCSixTQUFTLEVBQUVDLFlBQVk7UUFDNUQsT0FBT2pCLG9CQUFvQmUsc0JBQXNCQyxXQUFXQyxnQkFBZ0JYLGdCQUFnQlUsV0FBV0M7SUFDekc7QUFDRjtBQUNBLDBCQUEwQjtBQUMxQixxRUFBcUU7QUFDckUsb0VBQW9FO0FBQ3BFLDBCQUEwQjtBQUNYLFNBQVNJLDBCQUEwQnpCLFFBQVEsRUFBRTBCLElBQUk7SUFDOUQsSUFBSSxFQUNGQyxtQkFBbUIsRUFDbkJDLHNCQUFzQixFQUN0QkMsY0FBYyxFQUNmLEdBQUdILE1BQ0FJLFVBQVVyQyxtR0FBNkJBLENBQUNpQyxNQUFNaEM7SUFFbEQsTUFBTUcsa0JBQWtCOEIsb0JBQW9CM0IsVUFBVThCO0lBQ3RELE1BQU1oQyxxQkFBcUI4Qix1QkFBdUI1QixVQUFVOEI7SUFDNUQsTUFBTS9CLGFBQWE4QixlQUFlN0IsVUFBVThCO0lBRTVDLElBQUlDLElBQXlCLEVBQWM7UUFDekNwQywrREFBa0JBLENBQUNFLGlCQUFpQkMsb0JBQW9CQztJQUMxRDtJQUVBLE9BQU9ILDhCQUE4QkMsaUJBQWlCQyxvQkFBb0JDLFlBQVlDLFVBQVU4QjtBQUNsRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanM/N2M3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmNvbnN0IF9leGNsdWRlZCA9IFtcImluaXRNYXBTdGF0ZVRvUHJvcHNcIiwgXCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzXCIsIFwiaW5pdE1lcmdlUHJvcHNcIl07XG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJztcbmV4cG9ydCBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZCkgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwobmV4dFN0YXRlLCBzdGF0ZSwgbmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG4vLyBUaGUgc2VsZWN0b3IgcmV0dXJuZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHdpbGwgbWVtb2l6ZSBpdHMgcmVzdWx0cyxcbi8vIGFsbG93aW5nIGNvbm5lY3QncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwgX3JlZikge1xuICBsZXQge1xuICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICBpbml0TWVyZ2VQcm9wc1xuICB9ID0gX3JlZixcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcyk7XG4gIH1cblxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iXSwibmFtZXMiOlsiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJfZXhjbHVkZWQiLCJ2ZXJpZnlTdWJzZWxlY3RvcnMiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJkaXNwYXRjaCIsImFyZVN0YXRlc0VxdWFsIiwiYXJlT3duUHJvcHNFcXVhbCIsImFyZVN0YXRlUHJvcHNFcXVhbCIsImhhc1J1bkF0TGVhc3RPbmNlIiwic3RhdGUiLCJvd25Qcm9wcyIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIiwibWVyZ2VkUHJvcHMiLCJoYW5kbGVGaXJzdENhbGwiLCJmaXJzdFN0YXRlIiwiZmlyc3RPd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUiLCJkZXBlbmRzT25Pd25Qcm9wcyIsImhhbmRsZU5ld1Byb3BzIiwiaGFuZGxlTmV3U3RhdGUiLCJuZXh0U3RhdGVQcm9wcyIsInN0YXRlUHJvcHNDaGFuZ2VkIiwiaGFuZGxlU3Vic2VxdWVudENhbGxzIiwibmV4dFN0YXRlIiwibmV4dE93blByb3BzIiwicHJvcHNDaGFuZ2VkIiwic3RhdGVDaGFuZ2VkIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJfcmVmIiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJwcm9jZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/selectorFactory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/verifySubselectors.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/verifySubselectors.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ verifySubselectors; }\n/* harmony export */ });\n/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/warning */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/warning.js\");\n\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(\"Unexpected value for \".concat(methodName, \" in connect.\"));\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            (0,_utils_warning__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"The selector for \".concat(methodName, \" of connect did not specify a value for dependsOnOwnProps.\"));\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUV2QyxTQUFTQyxPQUFPQyxRQUFRLEVBQUVDLFVBQVU7SUFDbEMsSUFBSSxDQUFDRCxVQUFVO1FBQ2IsTUFBTSxJQUFJRSxNQUFNLHdCQUFtQyxPQUFYRCxZQUFXO0lBQ3JELE9BQU8sSUFBSUEsZUFBZSxxQkFBcUJBLGVBQWUsc0JBQXNCO1FBQ2xGLElBQUksQ0FBQ0UsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ04sVUFBVSxzQkFBc0I7WUFDeEVGLDBEQUFPQSxDQUFDLG9CQUErQixPQUFYRyxZQUFXO1FBQ3pDO0lBQ0Y7QUFDRjtBQUVlLFNBQVNNLG1CQUFtQkMsZUFBZSxFQUFFQyxrQkFBa0IsRUFBRUMsVUFBVTtJQUN4RlgsT0FBT1MsaUJBQWlCO0lBQ3hCVCxPQUFPVSxvQkFBb0I7SUFDM0JWLE9BQU9XLFlBQVk7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLmpzPzE2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5cbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYCk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ21hcFN0YXRlVG9Qcm9wcycgfHwgbWV0aG9kTmFtZSA9PT0gJ21hcERpc3BhdGNoVG9Qcm9wcycpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnKTtcbn0iXSwibmFtZXMiOlsid2FybmluZyIsInZlcmlmeSIsInNlbGVjdG9yIiwibWV0aG9kTmFtZSIsIkVycm9yIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/verifySubselectors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/connect/wrapMapToProps.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-redux/es/connect/wrapMapToProps.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDependsOnOwnProps: function() { return /* binding */ getDependsOnOwnProps; },\n/* harmony export */   wrapMapToPropsConstant: function() { return /* binding */ wrapMapToPropsConstant; },\n/* harmony export */   wrapMapToPropsFunc: function() { return /* binding */ wrapMapToPropsFunc; }\n/* harmony export */ });\n/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/verifyPlainObject */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/verifyPlainObject.js\");\n\nfunction wrapMapToPropsConstant(//  It seems that the dispatch argument\n//  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n//  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n// eslint-disable-next-line no-unused-vars\ngetConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, param) {\n        let { displayName } = param;\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, undefined);\n        }; // allow detectFactoryAndVerify to get ownProps\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) (0,_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkQ7QUFDcEQsU0FBU0MsdUJBQ2hCLHVDQUF1QztBQUN2QyxvRkFBb0Y7QUFDcEYsd0VBQXdFO0FBQ3hFLDBDQUEwQztBQUMxQ0MsV0FBVztJQUNULE9BQU8sU0FBU0MscUJBQXFCQyxRQUFRO1FBQzNDLE1BQU1DLFdBQVdILFlBQVlFO1FBRTdCLFNBQVNFO1lBQ1AsT0FBT0Q7UUFDVDtRQUVBQyxpQkFBaUJDLGlCQUFpQixHQUFHO1FBQ3JDLE9BQU9EO0lBQ1Q7QUFDRixFQUFFLGdHQUFnRztBQUNsRyxrR0FBa0c7QUFDbEcsa0VBQWtFO0FBQ2xFLEVBQUU7QUFDRiw4RkFBOEY7QUFDOUYsOEZBQThGO0FBQzlGLGtEQUFrRDtBQUNsRCx5R0FBeUc7QUFFbEcsU0FBU0UscUJBQXFCQyxVQUFVO0lBQzdDLE9BQU9BLFdBQVdGLGlCQUFpQixHQUFHRyxRQUFRRCxXQUFXRixpQkFBaUIsSUFBSUUsV0FBV0UsTUFBTSxLQUFLO0FBQ3RHLEVBQUUsOEVBQThFO0FBQ2hGLGdGQUFnRjtBQUNoRixFQUFFO0FBQ0Ysa0ZBQWtGO0FBQ2xGLGtGQUFrRjtBQUNsRixFQUFFO0FBQ0Ysb0ZBQW9GO0FBQ3BGLCtEQUErRDtBQUMvRCxFQUFFO0FBQ0Ysa0ZBQWtGO0FBQ2xGLG1GQUFtRjtBQUNuRixFQUFFO0FBRUssU0FBU0MsbUJBQW1CSCxVQUFVLEVBQUVJLFVBQVU7SUFDdkQsT0FBTyxTQUFTQyxrQkFBa0JWLFFBQVEsRUFBRSxLQUUzQztZQUYyQyxFQUMxQ1csV0FBVyxFQUNaLEdBRjJDO1FBRzFDLE1BQU1DLFFBQVEsU0FBU0MsZ0JBQWdCQyxlQUFlLEVBQUVDLFFBQVE7WUFDOUQsT0FBT0gsTUFBTVQsaUJBQWlCLEdBQUdTLE1BQU1QLFVBQVUsQ0FBQ1MsaUJBQWlCQyxZQUFZSCxNQUFNUCxVQUFVLENBQUNTLGlCQUFpQkU7UUFDbkgsR0FBRywrQ0FBK0M7UUFHbERKLE1BQU1ULGlCQUFpQixHQUFHO1FBRTFCUyxNQUFNUCxVQUFVLEdBQUcsU0FBU1ksdUJBQXVCSCxlQUFlLEVBQUVDLFFBQVE7WUFDMUVILE1BQU1QLFVBQVUsR0FBR0E7WUFDbkJPLE1BQU1ULGlCQUFpQixHQUFHQyxxQkFBcUJDO1lBQy9DLElBQUlhLFFBQVFOLE1BQU1FLGlCQUFpQkM7WUFFbkMsSUFBSSxPQUFPRyxVQUFVLFlBQVk7Z0JBQy9CTixNQUFNUCxVQUFVLEdBQUdhO2dCQUNuQk4sTUFBTVQsaUJBQWlCLEdBQUdDLHFCQUFxQmM7Z0JBQy9DQSxRQUFRTixNQUFNRSxpQkFBaUJDO1lBQ2pDO1lBRUEsSUFBSUksSUFBeUIsRUFBY3ZCLG9FQUFpQkEsQ0FBQ3NCLE9BQU9QLGFBQWFGO1lBQ2pGLE9BQU9TO1FBQ1Q7UUFFQSxPQUFPTjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanM/YmNkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoIC8vICogTm90ZTpcbi8vICBJdCBzZWVtcyB0aGF0IHRoZSBkaXNwYXRjaCBhcmd1bWVudFxuLy8gIGNvdWxkIGJlIGEgZGlzcGF0Y2ggZnVuY3Rpb24gaW4gc29tZSBjYXNlcyAoZXg6IHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcpXG4vLyAgYW5kIGEgc3RhdGUgb2JqZWN0IGluIHNvbWUgb3RoZXJzIChleDogd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZylcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cblxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn0gLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vL1xuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cbi8vIFRPRE8gQ2FuIHRoaXMgZ2V0IHB1bGxlZCBvdXQgc28gdGhhdCB3ZSBjYW4gc3Vic2NyaWJlIGRpcmVjdGx5IHRvIHRoZSBzdG9yZSBpZiB3ZSBkb24ndCBuZWVkIG93blByb3BzP1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn0gLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy9cbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCBoYW5kbGVzIG1hcFRvUHJvcHMgaWYgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLCBhbmQgdHJlYXRzIHRoYXRcbi8vICAgIG5ldyBmdW5jdGlvbiBhcyB0aGUgdHJ1ZSBtYXBUb1Byb3BzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuLy9cbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vL1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7XG4gICAgZGlzcGxheU5hbWVcbiAgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdW5kZWZpbmVkKTtcbiAgICB9OyAvLyBhbGxvdyBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IHRvIGdldCBvd25Qcm9wc1xuXG5cbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufSJdLCJuYW1lcyI6WyJ2ZXJpZnlQbGFpbk9iamVjdCIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiZGlzcGF0Y2giLCJjb25zdGFudCIsImNvbnN0YW50U2VsZWN0b3IiLCJkZXBlbmRzT25Pd25Qcm9wcyIsImdldERlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsIkJvb2xlYW4iLCJsZW5ndGgiLCJ3cmFwTWFwVG9Qcm9wc0Z1bmMiLCJtZXRob2ROYW1lIiwiaW5pdFByb3h5U2VsZWN0b3IiLCJkaXNwbGF5TmFtZSIsInByb3h5IiwibWFwVG9Qcm9wc1Byb3h5Iiwic3RhdGVPckRpc3BhdGNoIiwib3duUHJvcHMiLCJ1bmRlZmluZWQiLCJkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IiwicHJvcHMiLCJwcm9jZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/connect/wrapMapToProps.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/exports.js":
/*!************************************************!*\
  !*** ./node_modules/react-redux/es/exports.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* reexport safe */ _components_Provider__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   ReactReduxContext: function() { return /* reexport safe */ _components_Context__WEBPACK_IMPORTED_MODULE_2__.ReactReduxContext; },\n/* harmony export */   connect: function() { return /* reexport safe */ _components_connect__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   createDispatchHook: function() { return /* reexport safe */ _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_3__.createDispatchHook; },\n/* harmony export */   createSelectorHook: function() { return /* reexport safe */ _hooks_useSelector__WEBPACK_IMPORTED_MODULE_4__.createSelectorHook; },\n/* harmony export */   createStoreHook: function() { return /* reexport safe */ _hooks_useStore__WEBPACK_IMPORTED_MODULE_5__.createStoreHook; },\n/* harmony export */   shallowEqual: function() { return /* reexport safe */ _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   useDispatch: function() { return /* reexport safe */ _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_3__.useDispatch; },\n/* harmony export */   useSelector: function() { return /* reexport safe */ _hooks_useSelector__WEBPACK_IMPORTED_MODULE_4__.useSelector; },\n/* harmony export */   useStore: function() { return /* reexport safe */ _hooks_useStore__WEBPACK_IMPORTED_MODULE_5__.useStore; }\n/* harmony export */ });\n/* harmony import */ var _components_Provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Provider */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Provider.js\");\n/* harmony import */ var _components_connect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/connect */ \"(app-pages-browser)/./node_modules/react-redux/es/components/connect.js\");\n/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hooks/useDispatch */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useDispatch.js\");\n/* harmony import */ var _hooks_useSelector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useSelector */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useSelector.js\");\n/* harmony import */ var _hooks_useStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks/useStore */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useStore.js\");\n/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/shallowEqual */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/shallowEqual.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/react-redux/es/types.js\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9leHBvcnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNGO0FBQ2M7QUFDYTtBQUNBO0FBQ1Q7QUFDYjtBQUN4QjtBQUNtSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvZXhwb3J0cy5qcz8xYmJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm92aWRlciBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3QgZnJvbSAnLi9jb21wb25lbnRzL2Nvbm5lY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rIH0gZnJvbSAnLi9ob29rcy91c2VEaXNwYXRjaCc7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3Rvcic7XG5pbXBvcnQgeyB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTdG9yZSc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgUHJvdmlkZXIsIFJlYWN0UmVkdXhDb250ZXh0LCBjb25uZWN0LCB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rLCB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rLCB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rLCBzaGFsbG93RXF1YWwgfTsiXSwibmFtZXMiOlsiUHJvdmlkZXIiLCJjb25uZWN0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJ1c2VEaXNwYXRjaCIsImNyZWF0ZURpc3BhdGNoSG9vayIsInVzZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3JIb29rIiwidXNlU3RvcmUiLCJjcmVhdGVTdG9yZUhvb2siLCJzaGFsbG93RXF1YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/exports.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/hooks/useDispatch.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-redux/es/hooks/useDispatch.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDispatchHook: function() { return /* binding */ createDispatchHook; },\n/* harmony export */   useDispatch: function() { return /* binding */ useDispatch; }\n/* harmony export */ });\n/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _useStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useStore */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useStore.js\");\n\n\n/**\r\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useDispatch` hook bound to the specified context.\r\n */ function createDispatchHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _components_Context__WEBPACK_IMPORTED_MODULE_0__.ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useStore = context === _components_Context__WEBPACK_IMPORTED_MODULE_0__.ReactReduxContext ? _useStore__WEBPACK_IMPORTED_MODULE_1__.useStore : (0,_useStore__WEBPACK_IMPORTED_MODULE_1__.createStoreHook)(context);\n    return _s(function useDispatch() {\n        _s();\n        const store = useStore(); // @ts-ignore\n        return store.dispatch;\n    }, \"lacCqcEtsbxX3PAG/fPlTuRiPg0=\", false, function() {\n        return [\n            useStore\n        ];\n    });\n}\n/**\r\n * A hook to access the redux `dispatch` function.\r\n *\r\n * @returns {any|function} redux store's `dispatch` function\r\n *\r\n * @example\r\n *\r\n * import React, { useCallback } from 'react'\r\n * import { useDispatch } from 'react-redux'\r\n *\r\n * export const CounterComponent = ({ value }) => {\r\n *   const dispatch = useDispatch()\r\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\r\n *   return (\r\n *     <div>\r\n *       <span>{value}</span>\r\n *       <button onClick={increaseCounter}>Increase counter</button>\r\n *     </div>\r\n *   )\r\n * }\r\n */ const useDispatch = /*#__PURE__*/ createDispatchHook();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VEaXNwYXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQ2dCO0FBQzFFOzs7OztDQUtDLEdBRU0sU0FBU0k7UUFBbUJDLFVBQUFBLGlFQUFVTCxrRUFBaUJBOztJQUM1RCxNQUFNQyxXQUNOSSxZQUFZTCxrRUFBaUJBLEdBQUdFLCtDQUFlQSxHQUFHQywwREFBZUEsQ0FBQ0U7SUFDbEUsVUFBTyxTQUFTQzs7UUFDZCxNQUFNQyxRQUFRTixZQUFZLGFBQWE7UUFFdkMsT0FBT00sTUFBTUMsUUFBUTtJQUN2Qjs7WUFIZ0JQOzs7QUFJbEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FFTSxNQUFNSyxjQUFjLFdBQVcsR0FBRUYscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VEaXNwYXRjaC5qcz82NDI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVN0b3JlIGFzIHVzZURlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi91c2VTdG9yZSc7XG4vKipcclxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlRGlzcGF0Y2hgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUgPSAvLyBAdHMtaWdub3JlXG4gIGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlRGVmYXVsdFN0b3JlIDogY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlRGlzcGF0Y2goKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpOyAvLyBAdHMtaWdub3JlXG5cbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2g7XG4gIH07XG59XG4vKipcclxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggYGRpc3BhdGNoYCBmdW5jdGlvbi5cclxuICpcclxuICogQHJldHVybnMge2FueXxmdW5jdGlvbn0gcmVkdXggc3RvcmUncyBgZGlzcGF0Y2hgIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xyXG4gKiBpbXBvcnQgeyB1c2VEaXNwYXRjaCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICh7IHZhbHVlIH0pID0+IHtcclxuICogICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKClcclxuICogICBjb25zdCBpbmNyZWFzZUNvdW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdpbmNyZWFzZS1jb3VudGVyJyB9KSwgW10pXHJcbiAqICAgcmV0dXJuIChcclxuICogICAgIDxkaXY+XHJcbiAqICAgICAgIDxzcGFuPnt2YWx1ZX08L3NwYW4+XHJcbiAqICAgICAgIDxidXR0b24gb25DbGljaz17aW5jcmVhc2VDb3VudGVyfT5JbmNyZWFzZSBjb3VudGVyPC9idXR0b24+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICApXHJcbiAqIH1cclxuICovXG5cbmV4cG9ydCBjb25zdCB1c2VEaXNwYXRjaCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEaXNwYXRjaEhvb2soKTsiXSwibmFtZXMiOlsiUmVhY3RSZWR1eENvbnRleHQiLCJ1c2VTdG9yZSIsInVzZURlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlSG9vayIsImNyZWF0ZURpc3BhdGNoSG9vayIsImNvbnRleHQiLCJ1c2VEaXNwYXRjaCIsInN0b3JlIiwiZGlzcGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/hooks/useDispatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/hooks/useReduxContext.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-redux/es/hooks/useReduxContext.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createReduxContextHook: function() { return /* binding */ createReduxContextHook; },\n/* harmony export */   useReduxContext: function() { return /* binding */ useReduxContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n\n\n/**\r\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\r\n */ function createReduxContextHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _components_Context__WEBPACK_IMPORTED_MODULE_1__.ReactReduxContext;\n    var _s = $RefreshSig$();\n    return _s(function useReduxContext() {\n        _s();\n        const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    }, \"LIxFXvZbUdXE/TWxKLLXMjM3Mig=\");\n}\n/**\r\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @returns {any} the value of the `ReactReduxContext`\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useReduxContext } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const { store } = useReduxContext()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */ const useReduxContext = /*#__PURE__*/ createReduxContextHook();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VSZWR1eENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFDdUI7QUFFMUQ7Ozs7OztDQU1DLEdBQ00sU0FBU0U7UUFBdUJDLFVBQUFBLGlFQUFVRixrRUFBaUJBOztJQUNoRSxVQUFPLFNBQVNHOztRQUNkLE1BQU1DLGVBQWVMLGlEQUFVQSxDQUFDRztRQUVoQyxJQUFJRyxLQUF5QixJQUFnQixDQUFDRCxjQUFjO1lBQzFELE1BQU0sSUFBSUUsTUFBTTtRQUNsQjtRQUVBLE9BQU9GO0lBQ1Q7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUVNLE1BQU1ELGtCQUFrQixXQUFXLEdBQUVGLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlUmVkdXhDb250ZXh0LmpzPzkwNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcblxuLyoqXHJcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VSZWR1eENvbnRleHRgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LiBUaGlzIGlzIGEgbG93LWxldmVsXHJcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlUmVkdXhDb250ZXh0YCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVJlZHV4Q29udGV4dCgpIHtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICB9O1xufVxuLyoqXHJcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgLiBUaGlzIGlzIGEgbG93LWxldmVsXHJcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cclxuICpcclxuICogQHJldHVybnMge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuICogaW1wb3J0IHsgdXNlUmVkdXhDb250ZXh0IH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dCgpXHJcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XHJcbiAqIH1cclxuICovXG5cbmV4cG9ydCBjb25zdCB1c2VSZWR1eENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlUmVkdXhDb250ZXh0SG9vaygpOyJdLCJuYW1lcyI6WyJ1c2VDb250ZXh0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJjcmVhdGVSZWR1eENvbnRleHRIb29rIiwiY29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsImNvbnRleHRWYWx1ZSIsInByb2Nlc3MiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/hooks/useReduxContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/hooks/useSelector.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-redux/es/hooks/useSelector.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelectorHook: function() { return /* binding */ createSelectorHook; },\n/* harmony export */   initializeUseSelector: function() { return /* binding */ initializeUseSelector; },\n/* harmony export */   useSelector: function() { return /* binding */ useSelector; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useReduxContext */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useReduxContext.js\");\n/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _utils_useSyncExternalStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/useSyncExternalStore */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/useSyncExternalStore.js\");\n\n\n\n\nlet useSyncExternalStoreWithSelector = _utils_useSyncExternalStore__WEBPACK_IMPORTED_MODULE_3__.notInitialized;\nconst initializeUseSelector = (fn)=>{\n    useSyncExternalStoreWithSelector = fn;\n};\nconst refEquality = (a, b)=>a === b;\n/**\r\n * Hook factory, which creates a `useSelector` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useSelector` hook bound to the specified context.\r\n */ function createSelectorHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _components_Context__WEBPACK_IMPORTED_MODULE_2__.ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_2__.ReactReduxContext ? _useReduxContext__WEBPACK_IMPORTED_MODULE_1__.useReduxContext : (0,_useReduxContext__WEBPACK_IMPORTED_MODULE_1__.createReduxContextHook)(context);\n    return _s(function useSelector(selector) {\n        let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        _s();\n        const { equalityFn = refEquality, stabilityCheck = undefined, noopCheck = undefined } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(\"You must pass a selector to useSelector\");\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(\"You must pass a function as a selector to useSelector\");\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(\"You must pass a function as an equality function to useSelector\");\n            }\n        }\n        const { store, subscription, getServerState, stabilityCheck: globalStabilityCheck, noopCheck: globalNoopCheck } = useReduxContext();\n        const firstRun = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n        const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const finalStabilityCheck = typeof stabilityCheck === \"undefined\" ? globalStabilityCheck : stabilityCheck;\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = undefined;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\" + \"\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    const finalNoopCheck = typeof noopCheck === \"undefined\" ? globalNoopCheck : noopCheck;\n                    if (finalNoopCheck === \"always\" || finalNoopCheck === \"once\" && firstRun.current) {\n                        // @ts-ignore\n                        if (selected === state) {\n                            let stack = undefined;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\" + \"\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector,\n            globalStabilityCheck,\n            stabilityCheck\n        ]);\n        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n        return selectedState;\n    }, \"MU0BmHfhqjviNfmYfQ7AwmaymmY=\", false, function() {\n        return [\n            useReduxContext,\n            useSyncExternalStoreWithSelector\n        ];\n    });\n}\n/**\r\n * A hook to access the redux store's state. This hook takes a selector function\r\n * as an argument. The selector is called with the store state.\r\n *\r\n * This hook takes an optional equality comparison function as the second parameter\r\n * that allows you to customize the way the selected state is compared to determine\r\n * whether the component needs to be re-rendered.\r\n *\r\n * @param {Function} selector the selector function\r\n * @param {Function=} equalityFn the function that will be used to determine equality\r\n *\r\n * @returns {any} the selected state\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useSelector } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const counter = useSelector(state => state.counter)\r\n *   return <div>{counter}</div>\r\n * }\r\n */ const useSelector = /*#__PURE__*/ createSelectorHook();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEyRDtBQUMyQztBQUM1QztBQUNLO0FBQy9ELElBQUlRLG1DQUFtQ0QsdUVBQWNBO0FBQzlDLE1BQU1FLHdCQUF3QkMsQ0FBQUE7SUFDbkNGLG1DQUFtQ0U7QUFDckMsRUFBRTtBQUVGLE1BQU1DLGNBQWMsQ0FBQ0MsR0FBR0MsSUFBTUQsTUFBTUM7QUFDcEM7Ozs7O0NBS0MsR0FHTSxTQUFTQztRQUFtQkMsVUFBQUEsaUVBQVVULGtFQUFpQkE7O0lBQzVELE1BQU1GLGtCQUFrQlcsWUFBWVQsa0VBQWlCQSxHQUFHRCw2REFBc0JBLEdBQUdGLHdFQUFzQkEsQ0FBQ1k7SUFDeEcsVUFBTyxTQUFTQyxZQUFZQyxRQUFRO1lBQUVDLHNCQUFBQSxpRUFBc0IsQ0FBQzs7UUFDM0QsTUFBTSxFQUNKQyxhQUFhUixXQUFXLEVBQ3hCUyxpQkFBaUJDLFNBQVMsRUFDMUJDLFlBQVlELFNBQVMsRUFDdEIsR0FBRyxPQUFPSCx3QkFBd0IsYUFBYTtZQUM5Q0MsWUFBWUQ7UUFDZCxJQUFJQTtRQUVKLElBQUlLLElBQXlCLEVBQWM7WUFDekMsSUFBSSxDQUFDTixVQUFVO2dCQUNiLE1BQU0sSUFBSU8sTUFBTztZQUNuQjtZQUVBLElBQUksT0FBT1AsYUFBYSxZQUFZO2dCQUNsQyxNQUFNLElBQUlPLE1BQU87WUFDbkI7WUFFQSxJQUFJLE9BQU9MLGVBQWUsWUFBWTtnQkFDcEMsTUFBTSxJQUFJSyxNQUFPO1lBQ25CO1FBQ0Y7UUFFQSxNQUFNLEVBQ0pDLEtBQUssRUFDTEMsWUFBWSxFQUNaQyxjQUFjLEVBQ2RQLGdCQUFnQlEsb0JBQW9CLEVBQ3BDTixXQUFXTyxlQUFlLEVBQzNCLEdBQUd6QjtRQUNKLE1BQU0wQixXQUFXNUIsNkNBQU1BLENBQUM7UUFDeEIsTUFBTTZCLGtCQUFrQi9CLGtEQUFXQSxDQUFDO1lBQ2xDLENBQUNpQixTQUFTZSxJQUFJLENBQUMsRUFBQ0MsS0FBSztnQkFDbkIsTUFBTUMsV0FBV2pCLFNBQVNnQjtnQkFFMUIsSUFBSVYsSUFBeUIsRUFBYztvQkFDekMsTUFBTVksc0JBQXNCLE9BQU9mLG1CQUFtQixjQUFjUSx1QkFBdUJSO29CQUUzRixJQUFJZSx3QkFBd0IsWUFBWUEsd0JBQXdCLFVBQVVMLFNBQVNNLE9BQU8sRUFBRTt3QkFDMUYsTUFBTUMsWUFBWXBCLFNBQVNnQjt3QkFFM0IsSUFBSSxDQUFDZCxXQUFXZSxVQUFVRyxZQUFZOzRCQUNwQyxJQUFJQyxRQUFRakI7NEJBRVosSUFBSTtnQ0FDRixNQUFNLElBQUlHOzRCQUNaLEVBQUUsT0FBT2UsR0FBRzs7Z0NBRVQsR0FDQ0QsS0FBSyxFQUNOLEdBQUdDLENBQUFBOzRCQUNOOzRCQUVBQyxRQUFRQyxJQUFJLENBQUMsY0FBZXhCLENBQUFBLFNBQVNlLElBQUksSUFBSSxTQUFRLElBQUssK0dBQStHLHdMQUF3TDtnQ0FDL1ZDO2dDQUNBQztnQ0FDQVEsV0FBV0w7Z0NBQ1hDOzRCQUNGO3dCQUNGO29CQUNGO29CQUVBLE1BQU1LLGlCQUFpQixPQUFPckIsY0FBYyxjQUFjTyxrQkFBa0JQO29CQUU1RSxJQUFJcUIsbUJBQW1CLFlBQVlBLG1CQUFtQixVQUFVYixTQUFTTSxPQUFPLEVBQUU7d0JBQ2hGLGFBQWE7d0JBQ2IsSUFBSUYsYUFBYUQsT0FBTzs0QkFDdEIsSUFBSUssUUFBUWpCOzRCQUVaLElBQUk7Z0NBQ0YsTUFBTSxJQUFJRzs0QkFDWixFQUFFLE9BQU9lLEdBQUc7O2dDQUVULEdBQ0NELEtBQUssRUFDTixHQUFHQyxDQUFBQTs0QkFDTjs0QkFFQUMsUUFBUUMsSUFBSSxDQUFDLGNBQWV4QixDQUFBQSxTQUFTZSxJQUFJLElBQUksU0FBUSxJQUFLLGtGQUFrRixnSkFBZ0o7Z0NBQzFSTTs0QkFDRjt3QkFDRjtvQkFDRjtvQkFFQSxJQUFJUixTQUFTTSxPQUFPLEVBQUVOLFNBQVNNLE9BQU8sR0FBRztnQkFDM0M7Z0JBRUEsT0FBT0Y7WUFDVDtRQUVGLENBQUMsQ0FBQ2pCLFNBQVNlLElBQUksQ0FBQyxFQUFFO1lBQUNmO1lBQVVXO1lBQXNCUjtTQUFlO1FBQ2xFLE1BQU13QixnQkFBZ0JwQyxpQ0FBaUNrQixhQUFhbUIsWUFBWSxFQUFFcEIsTUFBTXFCLFFBQVEsRUFBRW5CLGtCQUFrQkYsTUFBTXFCLFFBQVEsRUFBRWYsaUJBQWlCWjtRQUNySmxCLG9EQUFhQSxDQUFDMkM7UUFDZCxPQUFPQTtJQUNUOztZQWpFTXhDO1lBOERrQkk7OztBQUkxQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBRU0sTUFBTVEsY0FBYyxXQUFXLEdBQUVGLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaG9va3MvdXNlU2VsZWN0b3IuanM/NjM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUmVkdXhDb250ZXh0SG9vaywgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQgfSBmcm9tICcuL3VzZVJlZHV4Q29udGV4dCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyBub3RJbml0aWFsaXplZCB9IGZyb20gJy4uL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbmxldCB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IG5vdEluaXRpYWxpemVkO1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVVc2VTZWxlY3RvciA9IGZuID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG5cbmNvbnN0IHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcclxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlU2VsZWN0b3JgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxyXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRSZWR1eENvbnRleHQgOiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlU2VsZWN0b3Ioc2VsZWN0b3IsIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrID0gdW5kZWZpbmVkLFxuICAgICAgbm9vcENoZWNrID0gdW5kZWZpbmVkXG4gICAgfSA9IHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9uc1xuICAgIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZXF1YWxpdHlGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGUsXG4gICAgICBzdGFiaWxpdHlDaGVjazogZ2xvYmFsU3RhYmlsaXR5Q2hlY2ssXG4gICAgICBub29wQ2hlY2s6IGdsb2JhbE5vb3BDaGVja1xuICAgIH0gPSB1c2VSZWR1eENvbnRleHQoKTtcbiAgICBjb25zdCBmaXJzdFJ1biA9IHVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSB1c2VDYWxsYmFjayh7XG4gICAgICBbc2VsZWN0b3IubmFtZV0oc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0YWJpbGl0eUNoZWNrID0gdHlwZW9mIHN0YWJpbGl0eUNoZWNrID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbFN0YWJpbGl0eUNoZWNrIDogc3RhYmlsaXR5Q2hlY2s7XG5cbiAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gJ2Fsd2F5cycgfHwgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gJ29uY2UnICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcblxuICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgIGxldCBzdGFjayA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICh7XG4gICAgICAgICAgICAgICAgICBzdGFja1xuICAgICAgICAgICAgICAgIH0gPSBlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignU2VsZWN0b3IgJyArIChzZWxlY3Rvci5uYW1lIHx8ICd1bmtub3duJykgKyAnIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLicgKyAnXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIGEgbmV3IHJlZmVyZW5jZSAoc3VjaCBhcyBhbiBvYmplY3Qgb3IgYW4gYXJyYXkpIHNob3VsZCBiZSBtZW1vaXplZDogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdXNhZ2UvZGVyaXZpbmctZGF0YS1zZWxlY3RvcnMjb3B0aW1pemluZy1zZWxlY3RvcnMtd2l0aC1tZW1vaXphdGlvbicsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICBzdGFja1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmaW5hbE5vb3BDaGVjayA9IHR5cGVvZiBub29wQ2hlY2sgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsTm9vcENoZWNrIDogbm9vcENoZWNrO1xuXG4gICAgICAgICAgaWYgKGZpbmFsTm9vcENoZWNrID09PSAnYWx3YXlzJyB8fCBmaW5hbE5vb3BDaGVjayA9PT0gJ29uY2UnICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgKHtcbiAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgfSA9IGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZWxlY3RvciAnICsgKHNlbGVjdG9yLm5hbWUgfHwgJ3Vua25vd24nKSArICcgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLicgKyAnXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUgYXJlIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlLCBhcyB0aGV5IHdpbGwgY2F1c2UgYSByZXJlbmRlciB3aGVuZXZlciAqYW55dGhpbmcqIGluIHN0YXRlIGNoYW5nZXMuJywge1xuICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KSBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICB9W3NlbGVjdG9yLm5hbWVdLCBbc2VsZWN0b3IsIGdsb2JhbFN0YWJpbGl0eUNoZWNrLCBzdGFiaWxpdHlDaGVja10pO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLCBzdG9yZS5nZXRTdGF0ZSwgZ2V0U2VydmVyU3RhdGUgfHwgc3RvcmUuZ2V0U3RhdGUsIHdyYXBwZWRTZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gICAgdXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZSdzIHN0YXRlLiBUaGlzIGhvb2sgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvblxyXG4gKiBhcyBhbiBhcmd1bWVudC4gVGhlIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBzdG9yZSBzdGF0ZS5cclxuICpcclxuICogVGhpcyBob29rIHRha2VzIGFuIG9wdGlvbmFsIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcclxuICogdGhhdCBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgd2F5IHRoZSBzZWxlY3RlZCBzdGF0ZSBpcyBjb21wYXJlZCB0byBkZXRlcm1pbmVcclxuICogd2hldGhlciB0aGUgY29tcG9uZW50IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWxlY3RvciB0aGUgc2VsZWN0b3IgZnVuY3Rpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbj19IGVxdWFsaXR5Rm4gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBlcXVhbGl0eVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgc2VsZWN0ZWQgc3RhdGVcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xyXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcclxuICogICBjb25zdCBjb3VudGVyID0gdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc3RhdGUuY291bnRlcilcclxuICogICByZXR1cm4gPGRpdj57Y291bnRlcn08L2Rpdj5cclxuICogfVxyXG4gKi9cblxuZXhwb3J0IGNvbnN0IHVzZVNlbGVjdG9yID0gLyojX19QVVJFX18qL2NyZWF0ZVNlbGVjdG9ySG9vaygpOyJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZURlYnVnVmFsdWUiLCJ1c2VSZWYiLCJjcmVhdGVSZWR1eENvbnRleHRIb29rIiwidXNlUmVkdXhDb250ZXh0IiwidXNlRGVmYXVsdFJlZHV4Q29udGV4dCIsIlJlYWN0UmVkdXhDb250ZXh0Iiwibm90SW5pdGlhbGl6ZWQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsImluaXRpYWxpemVVc2VTZWxlY3RvciIsImZuIiwicmVmRXF1YWxpdHkiLCJhIiwiYiIsImNyZWF0ZVNlbGVjdG9ySG9vayIsImNvbnRleHQiLCJ1c2VTZWxlY3RvciIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsImVxdWFsaXR5Rm4iLCJzdGFiaWxpdHlDaGVjayIsInVuZGVmaW5lZCIsIm5vb3BDaGVjayIsInByb2Nlc3MiLCJFcnJvciIsInN0b3JlIiwic3Vic2NyaXB0aW9uIiwiZ2V0U2VydmVyU3RhdGUiLCJnbG9iYWxTdGFiaWxpdHlDaGVjayIsImdsb2JhbE5vb3BDaGVjayIsImZpcnN0UnVuIiwid3JhcHBlZFNlbGVjdG9yIiwibmFtZSIsInN0YXRlIiwic2VsZWN0ZWQiLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwiY3VycmVudCIsInRvQ29tcGFyZSIsInN0YWNrIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwiZmluYWxOb29wQ2hlY2siLCJzZWxlY3RlZFN0YXRlIiwiYWRkTmVzdGVkU3ViIiwiZ2V0U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/hooks/useSelector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/hooks/useStore.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/es/hooks/useStore.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStoreHook: function() { return /* binding */ createStoreHook; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Context */ \"(app-pages-browser)/./node_modules/react-redux/es/components/Context.js\");\n/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useReduxContext */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useReduxContext.js\");\n\n\n/**\r\n * Hook factory, which creates a `useStore` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useStore` hook bound to the specified context.\r\n */ function createStoreHook() {\n    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _components_Context__WEBPACK_IMPORTED_MODULE_0__.ReactReduxContext;\n    var _s = $RefreshSig$();\n    const useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_0__.ReactReduxContext ? _useReduxContext__WEBPACK_IMPORTED_MODULE_1__.useReduxContext : (0,_useReduxContext__WEBPACK_IMPORTED_MODULE_1__.createReduxContextHook)(context);\n    return _s(function useStore() {\n        _s();\n        const { store } = useReduxContext(); // @ts-ignore\n        return store;\n    }, \"qjqE1P4cxIR34tJenP4fiRmGXu0=\", false, function() {\n        return [\n            useReduxContext\n        ];\n    });\n}\n/**\r\n * A hook to access the redux store.\r\n *\r\n * @returns {any} the redux store\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useStore } from 'react-redux'\r\n *\r\n * export const ExampleComponent = () => {\r\n *   const store = useStore()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */ const useStore = /*#__PURE__*/ createStoreHook();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBEO0FBQzRDO0FBQ3RHOzs7OztDQUtDLEdBRU0sU0FBU0k7UUFBZ0JDLFVBQUFBLGlFQUFVTCxrRUFBaUJBOztJQUN6RCxNQUFNQyxrQkFDTkksWUFBWUwsa0VBQWlCQSxHQUFHRSw2REFBc0JBLEdBQ3REQyx3RUFBc0JBLENBQUNFO0lBQ3ZCLFVBQU8sU0FBU0M7O1FBQ2QsTUFBTSxFQUNKQyxLQUFLLEVBQ04sR0FBR04sbUJBQW1CLGFBQWE7UUFFcEMsT0FBT007SUFDVDs7WUFITU47OztBQUlSO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FFTSxNQUFNSyxXQUFXLFdBQVcsR0FBRUYsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTdG9yZS5qcz8zYmQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0JztcbmltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0LCBjcmVhdGVSZWR1eENvbnRleHRIb29rIH0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnO1xuLyoqXHJcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVN0b3JlYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9IC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IDogLy8gQHRzLWlnbm9yZVxuICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmVcbiAgICB9ID0gdXNlUmVkdXhDb250ZXh0KCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZS5cclxuICpcclxuICogQHJldHVybnMge2FueX0gdGhlIHJlZHV4IHN0b3JlXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuICogaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdyZWFjdC1yZWR1eCdcclxuICpcclxuICogZXhwb3J0IGNvbnN0IEV4YW1wbGVDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAqICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpXHJcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XHJcbiAqIH1cclxuICovXG5cbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVTdG9yZUhvb2soKTsiXSwibmFtZXMiOlsiUmVhY3RSZWR1eENvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQiLCJ1c2VEZWZhdWx0UmVkdXhDb250ZXh0IiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsImNyZWF0ZVN0b3JlSG9vayIsImNvbnRleHQiLCJ1c2VTdG9yZSIsInN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/hooks/useStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/react-redux/es/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.Provider; },\n/* harmony export */   ReactReduxContext: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.ReactReduxContext; },\n/* harmony export */   batch: function() { return /* reexport safe */ _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_2__.unstable_batchedUpdates; },\n/* harmony export */   connect: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.connect; },\n/* harmony export */   createDispatchHook: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.createDispatchHook; },\n/* harmony export */   createSelectorHook: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.createSelectorHook; },\n/* harmony export */   createStoreHook: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.createStoreHook; },\n/* harmony export */   shallowEqual: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.shallowEqual; },\n/* harmony export */   useDispatch: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.useDispatch; },\n/* harmony export */   useSelector: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.useSelector; },\n/* harmony export */   useStore: function() { return /* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_6__.useStore; }\n/* harmony export */ });\n/* harmony import */ var use_sync_external_store_shim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/reactBatchedUpdates */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/reactBatchedUpdates.js\");\n/* harmony import */ var _utils_batch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/batch */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/batch.js\");\n/* harmony import */ var _hooks_useSelector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useSelector */ \"(app-pages-browser)/./node_modules/react-redux/es/hooks/useSelector.js\");\n/* harmony import */ var _components_connect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/connect */ \"(app-pages-browser)/./node_modules/react-redux/es/components/connect.js\");\n/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./exports */ \"(app-pages-browser)/./node_modules/react-redux/es/exports.js\");\n// The primary entry point assumes we're working with standard ReactDOM/RN, but\n// older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).\n// Because of that, the useSyncExternalStore compat shim is needed.\n\n\n\n\n\n\n(0,_hooks_useSelector__WEBPACK_IMPORTED_MODULE_4__.initializeUseSelector)(use_sync_external_store_shim_with_selector__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\n(0,_components_connect__WEBPACK_IMPORTED_MODULE_5__.initializeConnect)(use_sync_external_store_shim__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore); // Enable batched updates in our subscriptions for use\n// with standard React renderers (ReactDOM, React Native)\n(0,_utils_batch__WEBPACK_IMPORTED_MODULE_3__.setBatch)(_utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_2__.unstable_batchedUpdates);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrRUFBK0U7QUFDL0UsaUZBQWlGO0FBQ2pGLG1FQUFtRTtBQUNDO0FBQzBCO0FBQ2Y7QUFDdEM7QUFDbUI7QUFDSDtBQUN6REsseUVBQXFCQSxDQUFDSix3R0FBZ0NBO0FBQ3RESyxzRUFBaUJBLENBQUNOLDhFQUFvQkEsR0FBRyxzREFBc0Q7QUFDL0YseURBQXlEO0FBRXpESSxzREFBUUEsQ0FBQ0QsK0VBQUtBO0FBQ0c7QUFDUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaW5kZXguanM/NTMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcHJpbWFyeSBlbnRyeSBwb2ludCBhc3N1bWVzIHdlJ3JlIHdvcmtpbmcgd2l0aCBzdGFuZGFyZCBSZWFjdERPTS9STiwgYnV0XG4vLyBvbGRlciB2ZXJzaW9ucyB0aGF0IGRvIG5vdCBpbmNsdWRlIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgKFJlYWN0IDE2LjkgLSAxNy54KS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIGNvbXBhdCBzaGltIGlzIG5lZWRlZC5cbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbSc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvcic7XG5pbXBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBhcyBiYXRjaCB9IGZyb20gJy4vdXRpbHMvcmVhY3RCYXRjaGVkVXBkYXRlcyc7XG5pbXBvcnQgeyBzZXRCYXRjaCB9IGZyb20gJy4vdXRpbHMvYmF0Y2gnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVVzZVNlbGVjdG9yIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3Rvcic7XG5pbXBvcnQgeyBpbml0aWFsaXplQ29ubmVjdCB9IGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0JztcbmluaXRpYWxpemVVc2VTZWxlY3Rvcih1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcik7XG5pbml0aWFsaXplQ29ubmVjdCh1c2VTeW5jRXh0ZXJuYWxTdG9yZSk7IC8vIEVuYWJsZSBiYXRjaGVkIHVwZGF0ZXMgaW4gb3VyIHN1YnNjcmlwdGlvbnMgZm9yIHVzZVxuLy8gd2l0aCBzdGFuZGFyZCBSZWFjdCByZW5kZXJlcnMgKFJlYWN0RE9NLCBSZWFjdCBOYXRpdmUpXG5cbnNldEJhdGNoKGJhdGNoKTtcbmV4cG9ydCB7IGJhdGNoIH07XG5leHBvcnQgKiBmcm9tICcuL2V4cG9ydHMnOyJdLCJuYW1lcyI6WyJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaCIsInNldEJhdGNoIiwiaW5pdGlhbGl6ZVVzZVNlbGVjdG9yIiwiaW5pdGlhbGl6ZUNvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/types.js":
/*!**********************************************!*\
  !*** ./node_modules/react-redux/es/types.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3R5cGVzLmpzPzg2MWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/Subscription.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-redux/es/utils/Subscription.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSubscription: function() { return /* binding */ createSubscription; }\n/* harmony export */ });\n/* harmony import */ var _batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batch */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/batch.js\");\n // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\nfunction createListenerCollection() {\n    const batch = (0,_batch__WEBPACK_IMPORTED_MODULE_0__.getBatch)();\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            batch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            let listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            let listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nconst nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners; // Reasons to keep the subscription active\n    let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener); // cleanup nested sub\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = undefined;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUMsQ0FBQyx3RkFBd0Y7QUFDNUgsb0ZBQW9GO0FBQ3BGLG1EQUFtRDtBQUVuRCxTQUFTQztJQUNQLE1BQU1DLFFBQVFGLGdEQUFRQTtJQUN0QixJQUFJRyxRQUFRO0lBQ1osSUFBSUMsT0FBTztJQUNYLE9BQU87UUFDTEM7WUFDRUYsUUFBUTtZQUNSQyxPQUFPO1FBQ1Q7UUFFQUU7WUFDRUosTUFBTTtnQkFDSixJQUFJSyxXQUFXSjtnQkFFZixNQUFPSSxTQUFVO29CQUNmQSxTQUFTQyxRQUFRO29CQUNqQkQsV0FBV0EsU0FBU0UsSUFBSTtnQkFDMUI7WUFDRjtRQUNGO1FBRUFDO1lBQ0UsSUFBSUMsWUFBWSxFQUFFO1lBQ2xCLElBQUlKLFdBQVdKO1lBRWYsTUFBT0ksU0FBVTtnQkFDZkksVUFBVUMsSUFBSSxDQUFDTDtnQkFDZkEsV0FBV0EsU0FBU0UsSUFBSTtZQUMxQjtZQUVBLE9BQU9FO1FBQ1Q7UUFFQUUsV0FBVUwsUUFBUTtZQUNoQixJQUFJTSxlQUFlO1lBQ25CLElBQUlQLFdBQVdILE9BQU87Z0JBQ3BCSTtnQkFDQUMsTUFBTTtnQkFDTk0sTUFBTVg7WUFDUjtZQUVBLElBQUlHLFNBQVNRLElBQUksRUFBRTtnQkFDakJSLFNBQVNRLElBQUksQ0FBQ04sSUFBSSxHQUFHRjtZQUN2QixPQUFPO2dCQUNMSixRQUFRSTtZQUNWO1lBRUEsT0FBTyxTQUFTUztnQkFDZCxJQUFJLENBQUNGLGdCQUFnQlgsVUFBVSxNQUFNO2dCQUNyQ1csZUFBZTtnQkFFZixJQUFJUCxTQUFTRSxJQUFJLEVBQUU7b0JBQ2pCRixTQUFTRSxJQUFJLENBQUNNLElBQUksR0FBR1IsU0FBU1EsSUFBSTtnQkFDcEMsT0FBTztvQkFDTFgsT0FBT0csU0FBU1EsSUFBSTtnQkFDdEI7Z0JBRUEsSUFBSVIsU0FBU1EsSUFBSSxFQUFFO29CQUNqQlIsU0FBU1EsSUFBSSxDQUFDTixJQUFJLEdBQUdGLFNBQVNFLElBQUk7Z0JBQ3BDLE9BQU87b0JBQ0xOLFFBQVFJLFNBQVNFLElBQUk7Z0JBQ3ZCO1lBQ0Y7UUFDRjtJQUVGO0FBQ0Y7QUFFQSxNQUFNUSxnQkFBZ0I7SUFDcEJYLFdBQVU7SUFFVkksS0FBSyxJQUFNLEVBQUU7QUFDZjtBQUNPLFNBQVNRLG1CQUFtQkMsS0FBSyxFQUFFQyxTQUFTO0lBQ2pELElBQUlKO0lBQ0osSUFBSUwsWUFBWU0sZUFBZSwwQ0FBMEM7SUFFekUsSUFBSUksc0JBQXNCLEdBQUcsa0VBQWtFO0lBRS9GLElBQUlDLGlCQUFpQjtJQUVyQixTQUFTQyxhQUFhaEIsUUFBUTtRQUM1QmlCO1FBQ0EsTUFBTUMsa0JBQWtCZCxVQUFVRSxTQUFTLENBQUNOLFdBQVcscUJBQXFCO1FBRTVFLElBQUltQixVQUFVO1FBQ2QsT0FBTztZQUNMLElBQUksQ0FBQ0EsU0FBUztnQkFDWkEsVUFBVTtnQkFDVkQ7Z0JBQ0FFO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsU0FBU0M7UUFDUGpCLFVBQVVMLE1BQU07SUFDbEI7SUFFQSxTQUFTdUI7UUFDUCxJQUFJQyxhQUFhQyxhQUFhLEVBQUU7WUFDOUJELGFBQWFDLGFBQWE7UUFDNUI7SUFDRjtJQUVBLFNBQVNqQjtRQUNQLE9BQU9RO0lBQ1Q7SUFFQSxTQUFTRTtRQUNQSDtRQUVBLElBQUksQ0FBQ0wsYUFBYTtZQUNoQkEsY0FBY0ksWUFBWUEsVUFBVUcsWUFBWSxDQUFDTSx1QkFBdUJWLE1BQU1OLFNBQVMsQ0FBQ2dCO1lBQ3hGbEIsWUFBWVY7UUFDZDtJQUNGO0lBRUEsU0FBUzBCO1FBQ1BOO1FBRUEsSUFBSUwsZUFBZUssd0JBQXdCLEdBQUc7WUFDNUNMO1lBQ0FBLGNBQWNnQjtZQUNkckIsVUFBVU4sS0FBSztZQUNmTSxZQUFZTTtRQUNkO0lBQ0Y7SUFFQSxTQUFTZ0I7UUFDUCxJQUFJLENBQUNYLGdCQUFnQjtZQUNuQkEsaUJBQWlCO1lBQ2pCRTtRQUNGO0lBQ0Y7SUFFQSxTQUFTVTtRQUNQLElBQUlaLGdCQUFnQjtZQUNsQkEsaUJBQWlCO1lBQ2pCSztRQUNGO0lBQ0Y7SUFFQSxNQUFNRyxlQUFlO1FBQ25CUDtRQUNBSztRQUNBQztRQUNBZjtRQUNBVSxjQUFjUztRQUNkTixnQkFBZ0JPO1FBQ2hCQyxjQUFjLElBQU14QjtJQUN0QjtJQUNBLE9BQU9tQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanM/ZGI1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRCYXRjaCB9IGZyb20gJy4vYmF0Y2gnOyAvLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGNvbnN0IGJhdGNoID0gZ2V0QmF0Y2goKTtcbiAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgbGV0IGxhc3QgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcblxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXQoKSB7XG4gICAgICBsZXQgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcblxuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG5cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgbGV0IGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufVxuXG5jb25zdCBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7fSxcblxuICBnZXQ6ICgpID0+IFtdXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7IC8vIFJlYXNvbnMgdG8ga2VlcCB0aGUgc3Vic2NyaXB0aW9uIGFjdGl2ZVxuXG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDsgLy8gSXMgdGhpcyBzcGVjaWZpYyBzdWJzY3JpcHRpb24gc3Vic2NyaWJlZCAob3Igb25seSBuZXN0ZWQgb25lcz8pXG5cbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7IC8vIGNsZWFudXAgbmVzdGVkIHN1YlxuXG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQrKztcblxuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcblxuICAgIGlmICh1bnN1YnNjcmliZSAmJiBzdWJzY3JpcHRpb25zQW1vdW50ID09PSAwKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgdW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlOiB0cnlTdWJzY3JpYmVTZWxmLFxuICAgIHRyeVVuc3Vic2NyaWJlOiB0cnlVbnN1YnNjcmliZVNlbGYsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn0iXSwibmFtZXMiOlsiZ2V0QmF0Y2giLCJjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24iLCJiYXRjaCIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJjYWxsYmFjayIsIm5leHQiLCJnZXQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInN0b3JlIiwicGFyZW50U3ViIiwic3Vic2NyaXB0aW9uc0Ftb3VudCIsInNlbGZTdWJzY3JpYmVkIiwiYWRkTmVzdGVkU3ViIiwidHJ5U3Vic2NyaWJlIiwiY2xlYW51cExpc3RlbmVyIiwicmVtb3ZlZCIsInRyeVVuc3Vic2NyaWJlIiwibm90aWZ5TmVzdGVkU3VicyIsImhhbmRsZUNoYW5nZVdyYXBwZXIiLCJzdWJzY3JpcHRpb24iLCJvblN0YXRlQ2hhbmdlIiwidW5kZWZpbmVkIiwidHJ5U3Vic2NyaWJlU2VsZiIsInRyeVVuc3Vic2NyaWJlU2VsZiIsImdldExpc3RlbmVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/Subscription.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/batch.js":
/*!****************************************************!*\
  !*** ./node_modules/react-redux/es/utils/batch.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBatch: function() { return /* binding */ getBatch; },\n/* harmony export */   setBatch: function() { return /* binding */ setBatch; }\n/* harmony export */ });\n// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n    callback();\n}\nlet batch = defaultNoopBatch; // Allow injecting another batching function later\nconst setBatch = (newBatch)=>batch = newBatch; // Supply a getter just to skip dealing with ESM bindings\nconst getBatch = ()=>batch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9iYXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHdFQUF3RTtBQUN4RSxTQUFTQSxpQkFBaUJDLFFBQVE7SUFDaENBO0FBQ0Y7QUFFQSxJQUFJQyxRQUFRRixrQkFBa0Isa0RBQWtEO0FBRXpFLE1BQU1HLFdBQVdDLENBQUFBLFdBQVlGLFFBQVFFLFNBQVMsQ0FBQyx5REFBeUQ7QUFFeEcsTUFBTUMsV0FBVyxJQUFNSCxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9iYXRjaC5qcz8xNGQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmF1bHQgdG8gYSBkdW1teSBcImJhdGNoXCIgaW1wbGVtZW50YXRpb24gdGhhdCBqdXN0IHJ1bnMgdGhlIGNhbGxiYWNrXG5mdW5jdGlvbiBkZWZhdWx0Tm9vcEJhdGNoKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbmxldCBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7IC8vIEFsbG93IGluamVjdGluZyBhbm90aGVyIGJhdGNoaW5nIGZ1bmN0aW9uIGxhdGVyXG5cbmV4cG9ydCBjb25zdCBzZXRCYXRjaCA9IG5ld0JhdGNoID0+IGJhdGNoID0gbmV3QmF0Y2g7IC8vIFN1cHBseSBhIGdldHRlciBqdXN0IHRvIHNraXAgZGVhbGluZyB3aXRoIEVTTSBiaW5kaW5nc1xuXG5leHBvcnQgY29uc3QgZ2V0QmF0Y2ggPSAoKSA9PiBiYXRjaDsiXSwibmFtZXMiOlsiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiYmF0Y2giLCJzZXRCYXRjaCIsIm5ld0JhdGNoIiwiZ2V0QmF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/batch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/bindActionCreators.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/bindActionCreators.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ bindActionCreators; }\n/* harmony export */ });\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return dispatch(actionCreator(...args));\n            };\n        }\n    }\n    return boundActionCreators;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLG1CQUFtQkMsY0FBYyxFQUFFQyxRQUFRO0lBQ2pFLE1BQU1DLHNCQUFzQixDQUFDO0lBRTdCLElBQUssTUFBTUMsT0FBT0gsZUFBZ0I7UUFDaEMsTUFBTUksZ0JBQWdCSixjQUFjLENBQUNHLElBQUk7UUFFekMsSUFBSSxPQUFPQyxrQkFBa0IsWUFBWTtZQUN2Q0YsbUJBQW1CLENBQUNDLElBQUksR0FBRztpREFBSUU7b0JBQUFBOzt1QkFBU0osU0FBU0csaUJBQWlCQzs7UUFDcEU7SUFDRjtJQUVBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy5qcz80ZWU1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn0iXSwibmFtZXMiOlsiYmluZEFjdGlvbkNyZWF0b3JzIiwiYWN0aW9uQ3JlYXRvcnMiLCJkaXNwYXRjaCIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJrZXkiLCJhY3Rpb25DcmVhdG9yIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/bindActionCreators.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/isPlainObject.js":
/*!************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/isPlainObject.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isPlainObject; }\n/* harmony export */ });\n/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    let proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9pc1BsYWluT2JqZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0NBR0MsR0FDYyxTQUFTQSxjQUFjQyxHQUFHO0lBQ3ZDLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLE1BQU0sT0FBTztJQUNwRCxJQUFJQyxRQUFRQyxPQUFPQyxjQUFjLENBQUNIO0lBQ2xDLElBQUlDLFVBQVUsTUFBTSxPQUFPO0lBQzNCLElBQUlHLFlBQVlIO0lBRWhCLE1BQU9DLE9BQU9DLGNBQWMsQ0FBQ0MsZUFBZSxLQUFNO1FBQ2hEQSxZQUFZRixPQUFPQyxjQUFjLENBQUNDO0lBQ3BDO0lBRUEsT0FBT0gsVUFBVUc7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL2lzUGxhaW5PYmplY3QuanM/NTRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xufSJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImJhc2VQcm90byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/isPlainObject.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/reactBatchedUpdates.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/reactBatchedUpdates.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unstable_batchedUpdates: function() { return /* reexport safe */ react_dom__WEBPACK_IMPORTED_MODULE_0__.unstable_batchedUpdates; }\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzLmpzP2IzNDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tICdyZWFjdC1kb20nOyJdLCJuYW1lcyI6WyJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/reactBatchedUpdates.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/shallowEqual.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-redux/es/utils/shallowEqual.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ shallowEqual; }\n/* harmony export */ });\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFNBQVNBLEdBQUdDLENBQUMsRUFBRUMsQ0FBQztJQUNkLElBQUlELE1BQU1DLEdBQUc7UUFDWCxPQUFPRCxNQUFNLEtBQUtDLE1BQU0sS0FBSyxJQUFJRCxNQUFNLElBQUlDO0lBQzdDLE9BQU87UUFDTCxPQUFPRCxNQUFNQSxLQUFLQyxNQUFNQTtJQUMxQjtBQUNGO0FBRWUsU0FBU0MsYUFBYUMsSUFBSSxFQUFFQyxJQUFJO0lBQzdDLElBQUlMLEdBQUdJLE1BQU1DLE9BQU8sT0FBTztJQUUzQixJQUFJLE9BQU9ELFNBQVMsWUFBWUEsU0FBUyxRQUFRLE9BQU9DLFNBQVMsWUFBWUEsU0FBUyxNQUFNO1FBQzFGLE9BQU87SUFDVDtJQUVBLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUMxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNSSxNQUFNLEVBQUVDLElBQUs7UUFDckMsSUFBSSxDQUFDSixPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDVCxNQUFNQyxLQUFLLENBQUNLLEVBQUUsS0FBSyxDQUFDWCxHQUFHSSxJQUFJLENBQUNFLEtBQUssQ0FBQ0ssRUFBRSxDQUFDLEVBQUVOLElBQUksQ0FBQ0MsS0FBSyxDQUFDSyxFQUFFLENBQUMsR0FBRztZQUNoRyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvc2hhbGxvd0VxdWFsLmpzPzc2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59Il0sIm5hbWVzIjpbImlzIiwieCIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwiT2JqZWN0Iiwia2V5cyIsImtleXNCIiwibGVuZ3RoIiwiaSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/shallowEqual.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canUseDOM: function() { return /* binding */ canUseDOM; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* binding */ useIsomorphicLayoutEffect; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n// Matches logic in React's `shared/ExecutionEnvironment` file\nconst canUseDOM = !!( true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nconst useIsomorphicLayoutEffect = canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0IsQ0FBQyw2RUFBNkU7QUFDN0csNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDZFQUE2RTtBQUM3RSwwRUFBMEU7QUFDMUUsb0VBQW9FO0FBQ3BFLDhEQUE4RDtBQUV2RCxNQUFNQyxZQUFZLENBQUMsQ0FBRSxNQUFrQixJQUFlLE9BQU9DLE9BQU9DLFFBQVEsS0FBSyxlQUFlLE9BQU9ELE9BQU9DLFFBQVEsQ0FBQ0MsYUFBYSxLQUFLLFdBQVUsRUFBRztBQUN0SixNQUFNQyw0QkFBNEJKLFlBQVlELGtEQUFxQixHQUFHQSw0Q0FBZSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzP2IyZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnOyAvLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci4gV2UgbmVlZCB1c2VMYXlvdXRFZmZlY3QgdG8gZW5zdXJlIHRoZSBzdG9yZVxuLy8gc3Vic2NyaXB0aW9uIGNhbGxiYWNrIGFsd2F5cyBoYXMgdGhlIHNlbGVjdG9yIGZyb20gdGhlIGxhdGVzdCByZW5kZXIgY29tbWl0XG4vLyBhdmFpbGFibGUsIG90aGVyd2lzZSBhIHN0b3JlIHVwZGF0ZSBtYXkgaGFwcGVuIGJldHdlZW4gcmVuZGVyIGFuZCB0aGUgZWZmZWN0LFxuLy8gd2hpY2ggbWF5IGNhdXNlIG1pc3NlZCB1cGRhdGVzOyB3ZSBhbHNvIG11c3QgZW5zdXJlIHRoZSBzdG9yZSBzdWJzY3JpcHRpb25cbi8vIGlzIGNyZWF0ZWQgc3luY2hyb25vdXNseSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBvY2N1ciBiZWZvcmUgdGhlXG4vLyBzdWJzY3JpcHRpb24gaXMgY3JlYXRlZCBhbmQgYW4gaW5jb25zaXN0ZW50IHN0YXRlIG1heSBiZSBvYnNlcnZlZFxuLy8gTWF0Y2hlcyBsb2dpYyBpbiBSZWFjdCdzIGBzaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnRgIGZpbGVcblxuZXhwb3J0IGNvbnN0IGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuZXhwb3J0IGNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7Il0sIm5hbWVzIjpbIlJlYWN0IiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/useSyncExternalStore.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/useSyncExternalStore.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notInitialized: function() { return /* binding */ notInitialized; }\n/* harmony export */ });\nconst notInitialized = ()=>{\n    throw new Error(\"uSES not initialized!\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsaUJBQWlCO0lBQzVCLE1BQU0sSUFBSUMsTUFBTTtBQUNsQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZS5qcz85NjQ4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBub3RJbml0aWFsaXplZCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCd1U0VTIG5vdCBpbml0aWFsaXplZCEnKTtcbn07Il0sIm5hbWVzIjpbIm5vdEluaXRpYWxpemVkIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/useSyncExternalStore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/verifyPlainObject.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-redux/es/utils/verifyPlainObject.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ verifyPlainObject; }\n/* harmony export */ });\n/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isPlainObject */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/isPlainObject.js\");\n/* harmony import */ var _warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./warning */ \"(app-pages-browser)/./node_modules/react-redux/es/utils/warning.js\");\n\n\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!(0,_isPlainObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value)) {\n        (0,_warning__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"\".concat(methodName, \"() in \").concat(displayName, \" must return a plain object. Instead received \").concat(value, \".\"));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDWjtBQUNqQixTQUFTRSxrQkFBa0JDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxVQUFVO0lBQ3RFLElBQUksQ0FBQ0wsMERBQWFBLENBQUNHLFFBQVE7UUFDekJGLG9EQUFPQSxDQUFDLEdBQXNCRyxPQUFuQkMsWUFBVyxVQUFvRUYsT0FBNURDLGFBQVksa0RBQXNELE9BQU5ELE9BQU07SUFDbEc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanM/MGQyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmApO1xuICB9XG59Il0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJ3YXJuaW5nIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsImRpc3BsYXlOYW1lIiwibWV0aG9kTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/verifyPlainObject.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/es/utils/warning.js":
/*!******************************************************!*\
  !*** ./node_modules/react-redux/es/utils/warning.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ warning; }\n/* harmony export */ });\n/**\r\n * Prints a warning in the console if it exists.\r\n *\r\n * @param {String} message The warning message.\r\n * @returns {void}\r\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    /* eslint-disable no-empty */ } catch (e) {}\n/* eslint-enable no-empty */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNjLFNBQVNBLFFBQVFDLE9BQU87SUFDckMsNkJBQTZCLEdBQzdCLElBQUksT0FBT0MsWUFBWSxlQUFlLE9BQU9BLFFBQVFDLEtBQUssS0FBSyxZQUFZO1FBQ3pFRCxRQUFRQyxLQUFLLENBQUNGO0lBQ2hCO0lBQ0EsNEJBQTRCLEdBRzVCLElBQUk7UUFDRiwrREFBK0Q7UUFDL0QsNkNBQTZDO1FBQzdDLDZDQUE2QztRQUM3QyxNQUFNLElBQUlHLE1BQU1IO0lBQ2hCLDJCQUEyQixHQUM3QixFQUFFLE9BQU9JLEdBQUcsQ0FBQztBQUNiLDBCQUEwQixHQUU1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcz80NTk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cblxuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxufSJdLCJuYW1lcyI6WyJ3YXJuaW5nIiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/es/utils/warning.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n        var REACT_MODULE_REFERENCE;\n        {\n            REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function typeOf(object) {\n            if (typeof object === \"object\" && object !== null) {\n                var $$typeof = object.$$typeof;\n                switch($$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var type = object.type;\n                        switch(type){\n                            case REACT_FRAGMENT_TYPE:\n                            case REACT_PROFILER_TYPE:\n                            case REACT_STRICT_MODE_TYPE:\n                            case REACT_SUSPENSE_TYPE:\n                            case REACT_SUSPENSE_LIST_TYPE:\n                                return type;\n                            default:\n                                var $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                        }\n                    case REACT_PORTAL_TYPE:\n                        return $$typeof;\n                }\n            }\n            return undefined;\n        }\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false;\n        var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n        function isAsyncMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 18+.\");\n                }\n            }\n            return false;\n        }\n        function isConcurrentMode(object) {\n            {\n                if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n                    hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n                    console[\"warn\"](\"The ReactIs.isConcurrentMode() alias has been deprecated, \" + \"and will be removed in React 18+.\");\n                }\n            }\n            return false;\n        }\n        function isContextConsumer(object) {\n            return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n        function isContextProvider(object) {\n            return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n        function isElement(object) {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        function isForwardRef(object) {\n            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n        function isFragment(object) {\n            return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n        function isLazy(object) {\n            return typeOf(object) === REACT_LAZY_TYPE;\n        }\n        function isMemo(object) {\n            return typeOf(object) === REACT_MEMO_TYPE;\n        }\n        function isPortal(object) {\n            return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n        function isProfiler(object) {\n            return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n        function isStrictMode(object) {\n            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n        function isSuspense(object) {\n            return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n        function isSuspenseList(object) {\n            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n        }\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.SuspenseList = SuspenseList;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n        exports.isSuspenseList = isSuspenseList;\n        exports.isValidElementType = isValidElementType;\n        exports.typeOf = typeOf;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osd0NBQXdDO1FBQ3hDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsSUFBSUMscUJBQXFCQyxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSUMsb0JBQW9CRixPQUFPQyxHQUFHLENBQUM7UUFDbkMsSUFBSUUsc0JBQXNCSCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUcseUJBQXlCSixPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSUksc0JBQXNCTCxPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSUssc0JBQXNCTixPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSU0scUJBQXFCUCxPQUFPQyxHQUFHLENBQUM7UUFDcEMsSUFBSU8sNEJBQTRCUixPQUFPQyxHQUFHLENBQUM7UUFDM0MsSUFBSVEseUJBQXlCVCxPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSVMsc0JBQXNCVixPQUFPQyxHQUFHLENBQUM7UUFDckMsSUFBSVUsMkJBQTJCWCxPQUFPQyxHQUFHLENBQUM7UUFDMUMsSUFBSVcsa0JBQWtCWixPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSVksa0JBQWtCYixPQUFPQyxHQUFHLENBQUM7UUFDakMsSUFBSWEsdUJBQXVCZCxPQUFPQyxHQUFHLENBQUM7UUFFdEMsZ0ZBQWdGO1FBRWhGLElBQUljLGlCQUFpQixPQUFPLHdDQUF3QztRQUNwRSxJQUFJQyxxQkFBcUI7UUFDekIsSUFBSUMsMEJBQTBCLE9BQU8sK0NBQStDO1FBRXBGLElBQUlDLHFCQUFxQixPQUFPLHNEQUFzRDtRQUN0RiwrRUFBK0U7UUFDL0Usd0JBQXdCO1FBRXhCLElBQUlD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QUM1QlcsaUJBQWlCLEdBQUdWO1FBQ3BCVSxvQkFBb0IsR0FBR1Q7UUFDdkJTLGtCQUFrQixHQUFHUjtRQUNyQlEsY0FBYyxHQUFHUDtRQUNqQk8sY0FBYyxHQUFHTjtRQUNqQk0sZ0JBQWdCLEdBQUdMO1FBQ25CSyxrQkFBa0IsR0FBR0o7UUFDckJJLG9CQUFvQixHQUFHSDtRQUN2Qkcsa0JBQWtCLEdBQUdGO1FBQ3JCRSxzQkFBc0IsR0FBR0Q7UUFDekJDLDBCQUEwQixHQUFHckM7UUFDN0JxQyxjQUFjLEdBQUdoQztJQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/YWVlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zZXJ2ZXJfY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBTdXNwZW5zZUxpc3QgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0NvbmN1cnJlbnRNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUxpc3Qob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xufVxuXG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuU3VzcGVuc2VMaXN0ID0gU3VzcGVuc2VMaXN0O1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzU3VzcGVuc2VMaXN0ID0gaXNTdXNwZW5zZUxpc3Q7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ1bmRlZmluZWQiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJFbGVtZW50IiwiRm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiTGF6eSIsIk1lbW8iLCJQb3J0YWwiLCJQcm9maWxlciIsIlN0cmljdE1vZGUiLCJTdXNwZW5zZSIsIlN1c3BlbnNlTGlzdCIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSIsImlzQXN5bmNNb2RlIiwiY29uc29sZSIsImlzQ29uY3VycmVudE1vZGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzQ29udGV4dFByb3ZpZGVyIiwiaXNFbGVtZW50IiwiaXNGb3J3YXJkUmVmIiwiaXNGcmFnbWVudCIsImlzTGF6eSIsImlzTWVtbyIsImlzUG9ydGFsIiwiaXNQcm9maWxlciIsImlzU3RyaWN0TW9kZSIsImlzU3VzcGVuc2UiLCJpc1N1c3BlbnNlTGlzdCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-redux/node_modules/react-is/index.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsNktBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/OTU5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-redux/node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux-thunk/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/redux-thunk/es/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */ function createThunkMiddleware(extraArgument) {\n    // Standard Redux middleware definition pattern:\n    // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n    var middleware = function middleware(_ref) {\n        var dispatch = _ref.dispatch, getState = _ref.getState;\n        return function(next) {\n            return function(action) {\n                // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n                // If this \"action\" is really a function, call it and return the result.\n                if (typeof action === \"function\") {\n                    // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n                    return action(dispatch, getState, extraArgument);\n                } // Otherwise, pass the action down the middleware chain as usual\n                return next(action);\n            };\n        };\n    };\n    return middleware;\n}\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\nthunk.withExtraArgument = createThunkMiddleware;\n/* harmony default export */ __webpack_exports__[\"default\"] = (thunk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0NBRUMsR0FDRCxTQUFTQSxzQkFBc0JDLGFBQWE7SUFDMUMsZ0RBQWdEO0lBQ2hELDBGQUEwRjtJQUMxRixJQUFJQyxhQUFhLFNBQVNBLFdBQVdDLElBQUk7UUFDdkMsSUFBSUMsV0FBV0QsS0FBS0MsUUFBUSxFQUN4QkMsV0FBV0YsS0FBS0UsUUFBUTtRQUM1QixPQUFPLFNBQVVDLElBQUk7WUFDbkIsT0FBTyxTQUFVQyxNQUFNO2dCQUNyQixxRkFBcUY7Z0JBQ3JGLHdFQUF3RTtnQkFDeEUsSUFBSSxPQUFPQSxXQUFXLFlBQVk7b0JBQ2hDLG1GQUFtRjtvQkFDbkYsT0FBT0EsT0FBT0gsVUFBVUMsVUFBVUo7Z0JBQ3BDLEVBQUUsZ0VBQWdFO2dCQUdsRSxPQUFPSyxLQUFLQztZQUNkO1FBQ0Y7SUFDRjtJQUVBLE9BQU9MO0FBQ1Q7QUFFQSxJQUFJTSxRQUFRUix5QkFBeUIsdUVBQXVFO0FBQzVHLGtFQUFrRTtBQUVsRVEsTUFBTUMsaUJBQWlCLEdBQUdUO0FBQzFCLCtEQUFlUSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC10aHVuay9lcy9pbmRleC5qcz81MTFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHBvdGVudGlhbCBcImV4dHJhIGFyZ3VtZW50XCIgdmFsdWUgdG8gYmUgaW5qZWN0ZWQgbGF0ZXIsXHJcbiAqIGFuZCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSB0aHVuayBtaWRkbGV3YXJlIHRoYXQgdXNlcyB0aGF0IHZhbHVlXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgLy8gU3RhbmRhcmQgUmVkdXggbWlkZGxld2FyZSBkZWZpbml0aW9uIHBhdHRlcm46XG4gIC8vIFNlZTogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjd3JpdGluZy1jdXN0b20tbWlkZGxld2FyZVxuICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIG1pZGRsZXdhcmUoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIFRoZSB0aHVuayBtaWRkbGV3YXJlIGxvb2tzIGZvciBhbnkgZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgdG8gYHN0b3JlLmRpc3BhdGNoYC5cbiAgICAgICAgLy8gSWYgdGhpcyBcImFjdGlvblwiIGlzIHJlYWxseSBhIGZ1bmN0aW9uLCBjYWxsIGl0IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJbmplY3QgdGhlIHN0b3JlJ3MgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBtZXRob2RzLCBhcyB3ZWxsIGFzIGFueSBcImV4dHJhIGFyZ1wiXG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgcGFzcyB0aGUgYWN0aW9uIGRvd24gdGhlIG1pZGRsZXdhcmUgY2hhaW4gYXMgdXN1YWxcblxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpOyAvLyBBdHRhY2ggdGhlIGZhY3RvcnkgZnVuY3Rpb24gc28gdXNlcnMgY2FuIGNyZWF0ZSBhIGN1c3RvbWl6ZWQgdmVyc2lvblxuLy8gd2l0aCB3aGF0ZXZlciBcImV4dHJhIGFyZ1wiIHRoZXkgd2FudCB0byBpbmplY3QgaW50byB0aGVpciB0aHVua3NcblxudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5leHBvcnQgZGVmYXVsdCB0aHVuazsiXSwibmFtZXMiOlsiY3JlYXRlVGh1bmtNaWRkbGV3YXJlIiwiZXh0cmFBcmd1bWVudCIsIm1pZGRsZXdhcmUiLCJfcmVmIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIm5leHQiLCJhY3Rpb24iLCJ0aHVuayIsIndpdGhFeHRyYUFyZ3VtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux-thunk/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/redux/es/redux.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/redux.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: function() { return /* binding */ ActionTypes; },\n/* harmony export */   applyMiddleware: function() { return /* binding */ applyMiddleware; },\n/* harmony export */   bindActionCreators: function() { return /* binding */ bindActionCreators; },\n/* harmony export */   combineReducers: function() { return /* binding */ combineReducers; },\n/* harmony export */   compose: function() { return /* binding */ compose; },\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   legacy_createStore: function() { return /* binding */ legacy_createStore; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n}\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = function() {\n    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\" + randomString(),\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n    }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    var type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    var constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    } // other\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    var typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n    var _ref2;\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to \" + \"createStore(). This is not supported. Instead, compose them \" + \"together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n    }\n    var currentReducer = reducer;\n    var currentState = preloadedState;\n    var currentListeners = [];\n    var nextListeners = currentListeners;\n    var isDispatching = false;\n    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. \" + \"The reducer has already received the state as an argument. \" + \"Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. \" + \"If you would like to be notified after the store has been updated, subscribe from a \" + \"component and invoke store.getState() in the callback to access the latest state. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        var isSubscribed = true;\n        ensureCanMutateNextListeners();\n        nextListeners.push(listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            var index = nextListeners.indexOf(listener);\n            nextListeners.splice(index, 1);\n            currentListeners = null;\n        };\n    }\n    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        var listeners = currentListeners = nextListeners;\n        for(var i = 0; i < listeners.length; i++){\n            var listener = listeners[i];\n            listener();\n        }\n        return action;\n    }\n    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n        }\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n        // Any reducers that existed in both the new and old rootReducer\n        // will receive the previous state. This effectively populates\n        // the new state tree with any relevant data from the old one.\n        dispatch({\n            type: ActionTypes.REPLACE\n        });\n    }\n    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n        var _ref;\n        var outerSubscribe = subscribe;\n        return _ref = {\n            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n                }\n                function observeState() {\n                    if (observer.next) {\n                        observer.next(getState());\n                    }\n                }\n                observeState();\n                var unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe: unsubscribe\n                };\n            }\n        }, _ref[$$observable] = function() {\n            return this;\n        }, _ref;\n    } // When a store is created, an \"INIT\" action is dispatched so that every\n    // reducer returns their initial state. This effectively populates\n    // the initial state tree.\n    dispatch({\n        type: ActionTypes.INIT\n    });\n    return _ref2 = {\n        dispatch: dispatch,\n        subscribe: subscribe,\n        getState: getState,\n        replaceReducer: replaceReducer\n    }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */ var legacy_createStore = createStore;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    } catch (e) {} // eslint-disable-line no-empty\n}\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n    var reducerKeys = Object.keys(reducers);\n    var argumentName = action && action.type === ActionTypes.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n    if (reducerKeys.length === 0) {\n        return \"Store does not have a valid reducer. Make sure the argument passed \" + \"to combineReducers is an object whose values are reducers.\";\n    }\n    if (!isPlainObject(inputState)) {\n        return \"The \" + argumentName + ' has unexpected type of \"' + kindOf(inputState) + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n    }\n    var unexpectedKeys = Object.keys(inputState).filter(function(key) {\n        return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n    });\n    unexpectedKeys.forEach(function(key) {\n        unexpectedKeyCache[key] = true;\n    });\n    if (action && action.type === ActionTypes.REPLACE) return;\n    if (unexpectedKeys.length > 0) {\n        return \"Unexpected \" + (unexpectedKeys.length > 1 ? \"keys\" : \"key\") + \" \" + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n    }\n}\nfunction assertReducerShape(reducers) {\n    Object.keys(reducers).forEach(function(key) {\n        var reducer = reducers[key];\n        var initialState = reducer(undefined, {\n            type: ActionTypes.INIT\n        });\n        if (typeof initialState === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined during initialization. ' + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n        }\n        if (typeof reducer(undefined, {\n            type: ActionTypes.PROBE_UNKNOWN_ACTION()\n        }) === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined when probed with a random type. ' + (\"Don't try to handle '\" + ActionTypes.INIT + '\\' or other actions in \"redux/*\" ') + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n        }\n    });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */ function combineReducers(reducers) {\n    var reducerKeys = Object.keys(reducers);\n    var finalReducers = {};\n    for(var i = 0; i < reducerKeys.length; i++){\n        var key = reducerKeys[i];\n        if (true) {\n            if (typeof reducers[key] === \"undefined\") {\n                warning('No reducer provided for key \"' + key + '\"');\n            }\n        }\n        if (typeof reducers[key] === \"function\") {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n    // keys multiple times.\n    var unexpectedKeyCache;\n    if (true) {\n        unexpectedKeyCache = {};\n    }\n    var shapeAssertionError;\n    try {\n        assertReducerShape(finalReducers);\n    } catch (e) {\n        shapeAssertionError = e;\n    }\n    return function combination(state, action) {\n        if (state === void 0) {\n            state = {};\n        }\n        if (shapeAssertionError) {\n            throw shapeAssertionError;\n        }\n        if (true) {\n            var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n        }\n        var hasChanged = false;\n        var nextState = {};\n        for(var _i = 0; _i < finalReducerKeys.length; _i++){\n            var _key = finalReducerKeys[_i];\n            var reducer = finalReducers[_key];\n            var previousStateForKey = state[_key];\n            var nextStateForKey = reducer(previousStateForKey, action);\n            if (typeof nextStateForKey === \"undefined\") {\n                var actionType = action && action.type;\n                throw new Error( false ? 0 : \"When called with an action of type \" + (actionType ? '\"' + String(actionType) + '\"' : \"(unknown type)\") + ', the slice reducer for key \"' + _key + '\" returned undefined. ' + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n            }\n            nextState[_key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n        return hasChanged ? nextState : state;\n    };\n}\nfunction bindActionCreator(actionCreator, dispatch) {\n    return function() {\n        return dispatch(actionCreator.apply(this, arguments));\n    };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */ function bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n        return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n        throw new Error( false ? 0 : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n    }\n    var boundActionCreators = {};\n    for(var key in actionCreators){\n        var actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n        }\n    }\n    return boundActionCreators;\n}\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */ function compose() {\n    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){\n        funcs[_key] = arguments[_key];\n    }\n    if (funcs.length === 0) {\n        return function(arg) {\n            return arg;\n        };\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce(function(a, b) {\n        return function() {\n            return a(b.apply(void 0, arguments));\n        };\n    });\n}\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */ function applyMiddleware() {\n    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n        middlewares[_key] = arguments[_key];\n    }\n    return function(createStore) {\n        return function() {\n            var store = createStore.apply(void 0, arguments);\n            var _dispatch = function dispatch() {\n                throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\");\n            };\n            var middlewareAPI = {\n                getState: store.getState,\n                dispatch: function dispatch() {\n                    return _dispatch.apply(void 0, arguments);\n                }\n            };\n            var chain = middlewares.map(function(middleware) {\n                return middleware(middlewareAPI);\n            });\n            _dispatch = compose.apply(void 0, chain)(store.dispatch);\n            return (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, store), {}, {\n                dispatch: _dispatch\n            });\n        };\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxRTtBQUVyRTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyx1QkFBdUJDLElBQUk7SUFDbEMsT0FBTywyQkFBMkJBLE9BQU8sOENBQThDQSxPQUFPLDhCQUE4QjtBQUM5SDtBQUVBLHNEQUFzRDtBQUN0RCxJQUFJQyxlQUFlO0lBQ2pCLE9BQU8sT0FBT0MsV0FBVyxjQUFjQSxPQUFPQyxVQUFVLElBQUk7QUFDOUQ7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlDLGVBQWUsU0FBU0E7SUFDMUIsT0FBT0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxJQUFJQyxJQUFJLENBQUM7QUFDaEU7QUFFQSxJQUFJQyxjQUFjO0lBQ2hCQyxNQUFNLGlCQUFpQlI7SUFDdkJTLFNBQVMsb0JBQW9CVDtJQUM3QlUsc0JBQXNCLFNBQVNBO1FBQzdCLE9BQU8saUNBQWlDVjtJQUMxQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU1csY0FBY0MsR0FBRztJQUN4QixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNLE9BQU87SUFDcEQsSUFBSUMsUUFBUUQ7SUFFWixNQUFPRSxPQUFPQyxjQUFjLENBQUNGLFdBQVcsS0FBTTtRQUM1Q0EsUUFBUUMsT0FBT0MsY0FBYyxDQUFDRjtJQUNoQztJQUVBLE9BQU9DLE9BQU9DLGNBQWMsQ0FBQ0gsU0FBU0M7QUFDeEM7QUFFQSx3RkFBd0Y7QUFDeEYsU0FBU0csV0FBV0MsR0FBRztJQUNyQixJQUFJQSxRQUFRLEtBQUssR0FBRyxPQUFPO0lBQzNCLElBQUlBLFFBQVEsTUFBTSxPQUFPO0lBQ3pCLElBQUlDLE9BQU8sT0FBT0Q7SUFFbEIsT0FBUUM7UUFDTixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNI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LElBQUloQyxNQUFNUyxNQUFxQyxHQUFHNUMsQ0FBMEIsR0FBRyxvRUFBb0U7WUFDM0o7WUFFQSxJQUFJa0ksZ0JBQWdCO2dCQUNsQnhFLFVBQVVzRSxNQUFNdEUsUUFBUTtnQkFDeEJTLFVBQVUsU0FBU0E7b0JBQ2pCLE9BQU84RCxVQUFVZCxLQUFLLENBQUMsS0FBSyxHQUFHakU7Z0JBQ2pDO1lBQ0Y7WUFDQSxJQUFJaUYsUUFBUUosWUFBWUssR0FBRyxDQUFDLFNBQVVDLFVBQVU7Z0JBQzlDLE9BQU9BLFdBQVdIO1lBQ3BCO1lBQ0FELFlBQVlWLFFBQVFKLEtBQUssQ0FBQyxLQUFLLEdBQUdnQixPQUFPSCxNQUFNN0QsUUFBUTtZQUN2RCxPQUFPcEUsb0ZBQWFBLENBQUNBLG9GQUFhQSxDQUFDLENBQUMsR0FBR2lJLFFBQVEsQ0FBQyxHQUFHO2dCQUNqRDdELFVBQVU4RDtZQUNaO1FBQ0Y7SUFDRjtBQUNGO0FBRW9KIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcz9lYmYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDInO1xuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXG4gKlxuICogRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgdGhyb3cgZXJyb3IgY2FsbHMuIFRoZXNlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuICogZHVyaW5nIGJ1aWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBcIk1pbmlmaWVkIFJlZHV4IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9XCIgKyBjb2RlICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gJztcbn1cblxuLy8gSW5saW5lZCB2ZXJzaW9uIG9mIHRoZSBgc3ltYm9sLW9ic2VydmFibGVgIHBvbHlmaWxsXG52YXIgJCRvYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7XG59KSgpO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuXG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9IC8vIG90aGVyXG5cblxuICByZXR1cm4gdHlwZS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufVxuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlT2ZWYWw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyB0aGUgYGNvbmZpZ3VyZVN0b3JlYCBtZXRob2RcbiAqIG9mIHRoZSBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgLlxuICpcbiAqIFJlZHV4IFRvb2xraXQgaXMgb3VyIHJlY29tbWVuZGVkIGFwcHJvYWNoIGZvciB3cml0aW5nIFJlZHV4IGxvZ2ljIHRvZGF5LFxuICogaW5jbHVkaW5nIHN0b3JlIHNldHVwLCByZWR1Y2VycywgZGF0YSBmZXRjaGluZywgYW5kIG1vcmUuXG4gKlxuICogKipGb3IgbW9yZSBkZXRhaWxzLCBwbGVhc2UgcmVhZCB0aGlzIFJlZHV4IGRvY3MgcGFnZToqKlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIFJlZHV4IFRvb2xraXQgaXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBgY3JlYXRlU3RvcmVgIHRoYXRcbiAqIHNpbXBsaWZpZXMgc2V0dXAgYW5kIGhlbHBzIGF2b2lkIGNvbW1vbiBidWdzLlxuICpcbiAqIFlvdSBzaG91bGQgbm90IGJlIHVzaW5nIHRoZSBgcmVkdXhgIGNvcmUgcGFja2FnZSBieSBpdHNlbGYgdG9kYXksIGV4Y2VwdCBmb3IgbGVhcm5pbmcgcHVycG9zZXMuXG4gKiBUaGUgYGNyZWF0ZVN0b3JlYCBtZXRob2QgZnJvbSB0aGUgY29yZSBgcmVkdXhgIHBhY2thZ2Ugd2lsbCBub3QgYmUgcmVtb3ZlZCwgYnV0IHdlIGVuY291cmFnZVxuICogYWxsIHVzZXJzIHRvIG1pZ3JhdGUgdG8gdXNpbmcgUmVkdXggVG9vbGtpdCBmb3IgYWxsIFJlZHV4IGNvZGUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGBjcmVhdGVTdG9yZWAgd2l0aG91dCB0aGlzIHZpc3VhbCBkZXByZWNhdGlvbiB3YXJuaW5nLCB1c2VcbiAqIHRoZSBgbGVnYWN5X2NyZWF0ZVN0b3JlYCBpbXBvcnQgaW5zdGVhZDpcbiAqXG4gKiBgaW1wb3J0IHsgbGVnYWN5X2NyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCdgXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6ICdJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byAnICsgJ2NyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtICcgKyAndG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcIkV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGVuaGFuY2VyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YocmVkdWNlcikgKyBcIidcIik7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRoaXMgbWFrZXMgYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudExpc3RlbmVycyBzbyB3ZSBjYW4gdXNlXG4gICAqIG5leHRMaXN0ZW5lcnMgYXMgYSB0ZW1wb3JhcnkgbGlzdCB3aGlsZSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogVGhpcyBwcmV2ZW50cyBhbnkgYnVncyBhcm91bmQgY29uc3VtZXJzIGNhbGxpbmdcbiAgICogc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC5cbiAgICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcIkV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKGxpc3RlbmVyKSArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiAnWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgJyArICdjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6ICdZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGkvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICdcIiArIGtpbmRPZihhY3Rpb24pICsgXCInLiBZb3UgbWF5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUgdG8geW91ciBzdG9yZSBzZXR1cCB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgb3RoZXIgdmFsdWVzLCBzdWNoIGFzICdyZWR1eC10aHVuaycgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIGZ1bmN0aW9ucy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI21pZGRsZXdhcmUgYW5kIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC02LWFzeW5jLWxvZ2ljI3VzaW5nLXRoZS1yZWR1eC10aHVuay1taWRkbGV3YXJlIGZvciBleGFtcGxlcy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6ICdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogXCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihuZXh0UmVkdWNlcikpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7IC8vIFRoaXMgYWN0aW9uIGhhcyBhIHNpbWlsaWFyIGVmZmVjdCB0byBBY3Rpb25UeXBlcy5JTklULlxuICAgIC8vIEFueSByZWR1Y2VycyB0aGF0IGV4aXN0ZWQgaW4gYm90aCB0aGUgbmV3IGFuZCBvbGQgcm9vdFJlZHVjZXJcbiAgICAvLyB3aWxsIHJlY2VpdmUgdGhlIHByZXZpb3VzIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAgIC8vIHRoZSBuZXcgc3RhdGUgdHJlZSB3aXRoIGFueSByZWxldmFudCBkYXRhIGZyb20gdGhlIG9sZCBvbmUuXG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcIkV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2Yob2JzZXJ2ZXIpICsgXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH0gLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG5cblxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICB9KTtcbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIHRoZVxuICogYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYDpcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuXG52YXIgbGVnYWN5X2NyZWF0ZVN0b3JlID0gY3JlYXRlU3RvcmU7XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gXCJUaGUgXCIgKyBhcmd1bWVudE5hbWUgKyBcIiBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFxcXCJcIiArIGtpbmRPZihpbnB1dFN0YXRlKSArIFwiXFxcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBcIiArIChcImtleXM6IFxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiXCIpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBcIiArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgXCIgXCIgKyAoXCJcXFwiXCIgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIiBmb3VuZCBpbiBcIiArIGFyZ3VtZW50TmFtZSArIFwiLiBcIikgKyBcIkV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIgKyAoXCJcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gXCIgKyBcIklmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBcIiArIFwiZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBcIiArIFwibm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgXCIgKyBcInlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IFwiVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gXCIgKyAoXCJEb24ndCB0cnkgdG8gaGFuZGxlICdcIiArIEFjdGlvblR5cGVzLklOSVQgKyBcIicgb3Igb3RoZXIgYWN0aW9ucyBpbiBcXFwicmVkdXgvKlxcXCIgXCIpICsgXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBcIiArIFwiY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgXCIgKyBcImluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBcIiArIFwiYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKFwiTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTsgLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB3YXJuIGFib3V0IHRoZSBzYW1lXG4gIC8vIGtleXMgbXVsdGlwbGUgdGltZXMuXG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcblxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogXCJXaGVuIGNhbGxlZCB3aXRoIGFuIGFjdGlvbiBvZiB0eXBlIFwiICsgKGFjdGlvblR5cGUgPyBcIlxcXCJcIiArIFN0cmluZyhhY3Rpb25UeXBlKSArIFwiXFxcIlwiIDogJyh1bmtub3duIHR5cGUpJykgKyBcIiwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcXFwiXCIgKyBfa2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZC4gXCIgKyBcIlRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gXCIgKyBcIklmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cblxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwiYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBidXQgaW5zdGVhZCByZWNlaXZlZDogJ1wiICsga2luZE9mKGFjdGlvbkNyZWF0b3JzKSArIFwiJy4gXCIgKyBcIkRpZCB5b3Ugd3JpdGUgXFxcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIiBpbnN0ZWFkIG9mIFxcXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIj9cIik7XG4gIH1cblxuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAnRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodm9pZCAwLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgeyBBY3Rpb25UeXBlcyBhcyBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzLCBhcHBseU1pZGRsZXdhcmUsIGJpbmRBY3Rpb25DcmVhdG9ycywgY29tYmluZVJlZHVjZXJzLCBjb21wb3NlLCBjcmVhdGVTdG9yZSwgbGVnYWN5X2NyZWF0ZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJjb2RlIiwiJCRvYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsInJhbmRvbVN0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInNwbGl0Iiwiam9pbiIsIkFjdGlvblR5cGVzIiwiSU5JVCIsIlJFUExBQ0UiLCJQUk9CRV9VTktOT1dOX0FDVElPTiIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkVycm9yIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsIkRhdGUiLCJ0b0RhdGVTdHJpbmciLCJnZXREYXRlIiwic2V0RGF0ZSIsImtpbmRPZiIsInR5cGVPZlZhbCIsInByb2Nlc3MiLCJjcmVhdGVTdG9yZSIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiX3JlZjIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJjdXJyZW50UmVkdWNlciIsImN1cnJlbnRTdGF0ZSIsImN1cnJlbnRMaXN0ZW5lcnMiLCJuZXh0TGlzdGVuZXJzIiwiaXNEaXNwYXRjaGluZyIsImVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwiaXNTdWJzY3JpYmVkIiwicHVzaCIsInVuc3Vic2NyaWJlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZGlzcGF0Y2giLCJhY3Rpb24iLCJsaXN0ZW5lcnMiLCJpIiwibGVuZ3RoIiwicmVwbGFjZVJlZHVjZXIiLCJuZXh0UmVkdWNlciIsIl9yZWYiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwibmV4dCIsImxlZ2FjeV9jcmVhdGVTdG9yZSIsIndhcm5pbmciLCJjb25zb2xlIiwiZXJyb3IiLCJlIiwiZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZSIsImlucHV0U3RhdGUiLCJyZWR1Y2VycyIsInVuZXhwZWN0ZWRLZXlDYWNoZSIsInJlZHVjZXJLZXlzIiwia2V5cyIsImFyZ3VtZW50TmFtZSIsInVuZXhwZWN0ZWRLZXlzIiwiZmlsdGVyIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJmb3JFYWNoIiwiYXNzZXJ0UmVkdWNlclNoYXBlIiwiaW5pdGlhbFN0YXRlIiwiY29tYmluZVJlZHVjZXJzIiwiZmluYWxSZWR1Y2VycyIsImZpbmFsUmVkdWNlcktleXMiLCJzaGFwZUFzc2VydGlvbkVycm9yIiwiY29tYmluYXRpb24iLCJzdGF0ZSIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsIm5leHRTdGF0ZSIsIl9pIiwiX2tleSIsInByZXZpb3VzU3RhdGVGb3JLZXkiLCJuZXh0U3RhdGVGb3JLZXkiLCJhY3Rpb25UeXBlIiwiU3RyaW5nIiwiYmluZEFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9yIiwiYXBwbHkiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwiX2xlbiIsImZ1bmNzIiwiYXJnIiwicmVkdWNlIiwiYSIsImIiLCJhcHBseU1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsInN0b3JlIiwiX2Rpc3BhdGNoIiwibWlkZGxld2FyZUFQSSIsImNoYWluIiwibWFwIiwibWlkZGxld2FyZSIsIl9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/redux/es/redux.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js":
/*!****************************************************!*\
  !*** ./node_modules/reselect/es/defaultMemoize.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCacheKeyComparator: function() { return /* binding */ createCacheKeyComparator; },\n/* harmony export */   defaultEqualityCheck: function() { return /* binding */ defaultEqualityCheck; },\n/* harmony export */   defaultMemoize: function() { return /* binding */ defaultMemoize; }\n/* harmony export */ });\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction createSingletonCache(equals) {\n    var entry;\n    return {\n        get: function get(key) {\n            if (entry && equals(entry.key, key)) {\n                return entry.value;\n            }\n            return NOT_FOUND;\n        },\n        put: function put(key, value) {\n            entry = {\n                key: key,\n                value: value\n            };\n        },\n        getEntries: function getEntries() {\n            return entry ? [\n                entry\n            ] : [];\n        },\n        clear: function clear() {\n            entry = undefined;\n        }\n    };\n}\nfunction createLruCache(maxSize, equals) {\n    var entries = [];\n    function get(key) {\n        var cacheIndex = entries.findIndex(function(entry) {\n            return equals(key, entry.key);\n        }); // We found a cached entry\n        if (cacheIndex > -1) {\n            var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n            if (cacheIndex > 0) {\n                entries.splice(cacheIndex, 1);\n                entries.unshift(entry);\n            }\n            return entry.value;\n        } // No entry found in cache, return sentinel\n        return NOT_FOUND;\n    }\n    function put(key, value) {\n        if (get(key) === NOT_FOUND) {\n            // TODO Is unshift slow?\n            entries.unshift({\n                key: key,\n                value: value\n            });\n            if (entries.length > maxSize) {\n                entries.pop();\n            }\n        }\n    }\n    function getEntries() {\n        return entries;\n    }\n    function clear() {\n        entries = [];\n    }\n    return {\n        get: get,\n        put: put,\n        getEntries: getEntries,\n        clear: clear\n    };\n}\nvar defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n    return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n        if (prev === null || next === null || prev.length !== next.length) {\n            return false;\n        } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n        var length = prev.length;\n        for(var i = 0; i < length; i++){\n            if (!equalityCheck(prev[i], next[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nfunction defaultMemoize(func, equalityCheckOrOptions) {\n    var providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n        equalityCheck: equalityCheckOrOptions\n    };\n    var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;\n    var comparator = createCacheKeyComparator(equalityCheck);\n    var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n    function memoized() {\n        var value = cache.get(arguments);\n        if (value === NOT_FOUND) {\n            // @ts-ignore\n            value = func.apply(null, arguments);\n            if (resultEqualityCheck) {\n                var entries = cache.getEntries();\n                var matchingEntry = entries.find(function(entry) {\n                    return resultEqualityCheck(entry.value, value);\n                });\n                if (matchingEntry) {\n                    value = matchingEntry.value;\n                }\n            }\n            cache.put(arguments, value);\n        }\n        return value;\n    }\n    memoized.clearCache = function() {\n        return cache.clear();\n    };\n    return memoized;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9lcy9kZWZhdWx0TWVtb2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBZ0U7QUFDaEUseUNBQXlDO0FBQ3pDLElBQUlBLFlBQVk7QUFFaEIsU0FBU0MscUJBQXFCQyxNQUFNO0lBQ2xDLElBQUlDO0lBQ0osT0FBTztRQUNMQyxLQUFLLFNBQVNBLElBQUlDLEdBQUc7WUFDbkIsSUFBSUYsU0FBU0QsT0FBT0MsTUFBTUUsR0FBRyxFQUFFQSxNQUFNO2dCQUNuQyxPQUFPRixNQUFNRyxLQUFLO1lBQ3BCO1lBRUEsT0FBT047UUFDVDtRQUNBTyxLQUFLLFNBQVNBLElBQUlGLEdBQUcsRUFBRUMsS0FBSztZQUMxQkgsUUFBUTtnQkFDTkUsS0FBS0E7Z0JBQ0xDLE9BQU9BO1lBQ1Q7UUFDRjtRQUNBRSxZQUFZLFNBQVNBO1lBQ25CLE9BQU9MLFFBQVE7Z0JBQUNBO2FBQU0sR0FBRyxFQUFFO1FBQzdCO1FBQ0FNLE9BQU8sU0FBU0E7WUFDZE4sUUFBUU87UUFDVjtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxlQUFlQyxPQUFPLEVBQUVWLE1BQU07SUFDckMsSUFBSVcsVUFBVSxFQUFFO0lBRWhCLFNBQVNULElBQUlDLEdBQUc7UUFDZCxJQUFJUyxhQUFhRCxRQUFRRSxTQUFTLENBQUMsU0FBVVosS0FBSztZQUNoRCxPQUFPRCxPQUFPRyxLQUFLRixNQUFNRSxHQUFHO1FBQzlCLElBQUksMEJBQTBCO1FBRTlCLElBQUlTLGFBQWEsQ0FBQyxHQUFHO1lBQ25CLElBQUlYLFFBQVFVLE9BQU8sQ0FBQ0MsV0FBVyxFQUFFLHVEQUF1RDtZQUV4RixJQUFJQSxhQUFhLEdBQUc7Z0JBQ2xCRCxRQUFRRyxNQUFNLENBQUNGLFlBQVk7Z0JBQzNCRCxRQUFRSSxPQUFPLENBQUNkO1lBQ2xCO1lBRUEsT0FBT0EsTUFBTUcsS0FBSztRQUNwQixFQUFFLDJDQUEyQztRQUc3QyxPQUFPTjtJQUNUO0lBRUEsU0FBU08sSUFBSUYsR0FBRyxFQUFFQyxLQUFLO1FBQ3JCLElBQUlGLElBQUlDLFNBQVNMLFdBQVc7WUFDMUIsd0JBQXdCO1lBQ3hCYSxRQUFRSSxPQUFPLENBQUM7Z0JBQ2RaLEtBQUtBO2dCQUNMQyxPQUFPQTtZQUNUO1lBRUEsSUFBSU8sUUFBUUssTUFBTSxHQUFHTixTQUFTO2dCQUM1QkMsUUFBUU0sR0FBRztZQUNiO1FBQ0Y7SUFDRjtJQUVBLFNBQVNYO1FBQ1AsT0FBT0s7SUFDVDtJQUVBLFNBQVNKO1FBQ1BJLFVBQVUsRUFBRTtJQUNkO0lBRUEsT0FBTztRQUNMVCxLQUFLQTtRQUNMRyxLQUFLQTtRQUNMQyxZQUFZQTtRQUNaQyxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxJQUFJVyx1QkFBdUIsU0FBU0EscUJBQXFCQyxDQUFDLEVBQUVDLENBQUM7SUFDbEUsT0FBT0QsTUFBTUM7QUFDZixFQUFFO0FBQ0ssU0FBU0MseUJBQXlCQyxhQUFhO0lBQ3BELE9BQU8sU0FBU0MsMkJBQTJCQyxJQUFJLEVBQUVDLElBQUk7UUFDbkQsSUFBSUQsU0FBUyxRQUFRQyxTQUFTLFFBQVFELEtBQUtSLE1BQU0sS0FBS1MsS0FBS1QsTUFBTSxFQUFFO1lBQ2pFLE9BQU87UUFDVCxFQUFFLDhHQUE4RztRQUdoSCxJQUFJQSxTQUFTUSxLQUFLUixNQUFNO1FBRXhCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJVixRQUFRVSxJQUFLO1lBQy9CLElBQUksQ0FBQ0osY0FBY0UsSUFBSSxDQUFDRSxFQUFFLEVBQUVELElBQUksQ0FBQ0MsRUFBRSxHQUFHO2dCQUNwQyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUNGO0FBQ0EsMkVBQTJFO0FBQzNFLG1FQUFtRTtBQUM1RCxTQUFTQyxlQUFlQyxJQUFJLEVBQUVDLHNCQUFzQjtJQUN6RCxJQUFJQyxrQkFBa0IsT0FBT0QsMkJBQTJCLFdBQVdBLHlCQUF5QjtRQUMxRlAsZUFBZU87SUFDakI7SUFDQSxJQUFJRSx3QkFBd0JELGdCQUFnQlIsYUFBYSxFQUNyREEsZ0JBQWdCUywwQkFBMEIsS0FBSyxJQUFJYix1QkFBdUJhLHVCQUMxRUMsd0JBQXdCRixnQkFBZ0JwQixPQUFPLEVBQy9DQSxVQUFVc0IsMEJBQTBCLEtBQUssSUFBSSxJQUFJQSx1QkFDakRDLHNCQUFzQkgsZ0JBQWdCRyxtQkFBbUI7SUFDN0QsSUFBSUMsYUFBYWIseUJBQXlCQztJQUMxQyxJQUFJYSxRQUFRekIsWUFBWSxJQUFJWCxxQkFBcUJtQyxjQUFjekIsZUFBZUMsU0FBU3dCLGFBQWEsMkVBQTJFO0lBRS9LLFNBQVNFO1FBQ1AsSUFBSWhDLFFBQVErQixNQUFNakMsR0FBRyxDQUFDbUM7UUFFdEIsSUFBSWpDLFVBQVVOLFdBQVc7WUFDdkIsYUFBYTtZQUNiTSxRQUFRd0IsS0FBS1UsS0FBSyxDQUFDLE1BQU1EO1lBRXpCLElBQUlKLHFCQUFxQjtnQkFDdkIsSUFBSXRCLFVBQVV3QixNQUFNN0IsVUFBVTtnQkFDOUIsSUFBSWlDLGdCQUFnQjVCLFFBQVE2QixJQUFJLENBQUMsU0FBVXZDLEtBQUs7b0JBQzlDLE9BQU9nQyxvQkFBb0JoQyxNQUFNRyxLQUFLLEVBQUVBO2dCQUMxQztnQkFFQSxJQUFJbUMsZUFBZTtvQkFDakJuQyxRQUFRbUMsY0FBY25DLEtBQUs7Z0JBQzdCO1lBQ0Y7WUFFQStCLE1BQU05QixHQUFHLENBQUNnQyxXQUFXakM7UUFDdkI7UUFFQSxPQUFPQTtJQUNUO0lBRUFnQyxTQUFTSyxVQUFVLEdBQUc7UUFDcEIsT0FBT04sTUFBTTVCLEtBQUs7SUFDcEI7SUFFQSxPQUFPNkI7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvZGVmYXVsdE1lbW9pemUuanM/ZWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWNoZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBFcmlrIFJhc211c3NlbidzIGBscnUtbWVtb2l6ZWA6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXJpa3Jhcy9scnUtbWVtb2l6ZVxudmFyIE5PVF9GT1VORCA9ICdOT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcbiAgdmFyIGVudHJ5O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZW50cnkgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJ5ID8gW2VudHJ5XSA6IFtdO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpO1xuICAgIH0pOyAvLyBXZSBmb3VuZCBhIGNhY2hlZCBlbnRyeVxuXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XTsgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxuXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9IC8vIE5vIGVudHJ5IGZvdW5kIGluIGNhY2hlLCByZXR1cm4gc2VudGluZWxcblxuXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGdldChrZXkpID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xuICAgICAgZW50cmllcy51bnNoaWZ0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50cmllcyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBwdXQ6IHB1dCxcbiAgICBnZXRFbnRyaWVzOiBnZXRFbnRyaWVzLFxuICAgIGNsZWFyOiBjbGVhclxuICB9O1xufVxuXG5leHBvcnQgdmFyIGRlZmF1bHRFcXVhbGl0eUNoZWNrID0gZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbi8vIGRlZmF1bHRNZW1vaXplIG5vdyBzdXBwb3J0cyBhIGNvbmZpZ3VyYWJsZSBjYWNoZSBzaXplIHdpdGggTFJVIGJlaGF2aW9yLFxuLy8gYW5kIG9wdGlvbmFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCB2YWx1ZSB3aXRoIGV4aXN0aW5nIHZhbHVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMsIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMpIHtcbiAgdmFyIHByb3ZpZGVkT3B0aW9ucyA9IHR5cGVvZiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7XG4gICAgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9uc1xuICB9O1xuICB2YXIgX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID0gcHJvdmlkZWRPcHRpb25zLmVxdWFsaXR5Q2hlY2ssXG4gICAgICBlcXVhbGl0eUNoZWNrID0gX3Byb3ZpZGVkT3B0aW9ucyRlcXVhID09PSB2b2lkIDAgPyBkZWZhdWx0RXF1YWxpdHlDaGVjayA6IF9wcm92aWRlZE9wdGlvbnMkZXF1YSxcbiAgICAgIF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9IHByb3ZpZGVkT3B0aW9ucy5tYXhTaXplLFxuICAgICAgbWF4U2l6ZSA9IF9wcm92aWRlZE9wdGlvbnMkbWF4UyA9PT0gdm9pZCAwID8gMSA6IF9wcm92aWRlZE9wdGlvbnMkbWF4UyxcbiAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sgPSBwcm92aWRlZE9wdGlvbnMucmVzdWx0RXF1YWxpdHlDaGVjaztcbiAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XG4gIHZhciBjYWNoZSA9IG1heFNpemUgPT09IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpOyAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHJlc3VsdEVxdWFsaXR5Q2hlY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBjYWNoZS5nZXRFbnRyaWVzKCk7XG4gICAgICAgIHZhciBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuXG4gIHJldHVybiBtZW1vaXplZDtcbn0iXSwibmFtZXMiOlsiTk9UX0ZPVU5EIiwiY3JlYXRlU2luZ2xldG9uQ2FjaGUiLCJlcXVhbHMiLCJlbnRyeSIsImdldCIsImtleSIsInZhbHVlIiwicHV0IiwiZ2V0RW50cmllcyIsImNsZWFyIiwidW5kZWZpbmVkIiwiY3JlYXRlTHJ1Q2FjaGUiLCJtYXhTaXplIiwiZW50cmllcyIsImNhY2hlSW5kZXgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwicG9wIiwiZGVmYXVsdEVxdWFsaXR5Q2hlY2siLCJhIiwiYiIsImNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvciIsImVxdWFsaXR5Q2hlY2siLCJhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbCIsInByZXYiLCJuZXh0IiwiaSIsImRlZmF1bHRNZW1vaXplIiwiZnVuYyIsImVxdWFsaXR5Q2hlY2tPck9wdGlvbnMiLCJwcm92aWRlZE9wdGlvbnMiLCJfcHJvdmlkZWRPcHRpb25zJGVxdWEiLCJfcHJvdmlkZWRPcHRpb25zJG1heFMiLCJyZXN1bHRFcXVhbGl0eUNoZWNrIiwiY29tcGFyYXRvciIsImNhY2hlIiwibWVtb2l6ZWQiLCJhcmd1bWVudHMiLCJhcHBseSIsIm1hdGNoaW5nRW50cnkiLCJmaW5kIiwiY2xlYXJDYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/reselect/es/index.js":
/*!*******************************************!*\
  !*** ./node_modules/reselect/es/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: function() { return /* binding */ createSelector; },\n/* harmony export */   createSelectorCreator: function() { return /* binding */ createSelectorCreator; },\n/* harmony export */   createStructuredSelector: function() { return /* binding */ createStructuredSelector; },\n/* harmony export */   defaultEqualityCheck: function() { return /* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultEqualityCheck; },\n/* harmony export */   defaultMemoize: function() { return /* reexport safe */ _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize; }\n/* harmony export */ });\n/* harmony import */ var _defaultMemoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultMemoize */ \"(app-pages-browser)/./node_modules/reselect/es/defaultMemoize.js\");\n\n\nfunction getDependencies(funcs) {\n    var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n    if (!dependencies.every(function(dep) {\n        return typeof dep === \"function\";\n    })) {\n        var dependencyTypes = dependencies.map(function(dep) {\n            return typeof dep === \"function\" ? \"function \" + (dep.name || \"unnamed\") + \"()\" : typeof dep;\n        }).join(\", \");\n        throw new Error(\"createSelector expects all input-selectors to be functions, but received the following types: [\" + dependencyTypes + \"]\");\n    }\n    return dependencies;\n}\nfunction createSelectorCreator(memoize) {\n    for(var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        memoizeOptionsFromArgs[_key - 1] = arguments[_key];\n    }\n    var createSelector = function createSelector() {\n        for(var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            funcs[_key2] = arguments[_key2];\n        }\n        var _recomputations = 0;\n        var _lastResult; // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.\n        // So, start by declaring the default value here.\n        // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\n        var directlyPassedOptions = {\n            memoizeOptions: undefined\n        }; // Normally, the result func or \"output selector\" is the last arg\n        var resultFunc = funcs.pop(); // If the result func is actually an _object_, assume it's our options object\n        if (typeof resultFunc === \"object\") {\n            directlyPassedOptions = resultFunc; // and pop the real result func off\n            resultFunc = funcs.pop();\n        }\n        if (typeof resultFunc !== \"function\") {\n            throw new Error(\"createSelector expects an output function after the inputs, but received: [\" + typeof resultFunc + \"]\");\n        } // Determine which set of options we're using. Prefer options passed directly,\n        // but fall back to options given to createSelectorCreator.\n        var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2; // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\n        // is an array. In most libs I've looked at, it's an equality function or options object.\n        // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\n        // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\n        // we wrap it in an array so we can apply it.\n        var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [\n            memoizeOptions\n        ];\n        var dependencies = getDependencies(funcs);\n        var memoizedResultFunc = memoize.apply(void 0, [\n            function recomputationWrapper() {\n                _recomputations++; // apply arguments instead of spreading for performance.\n                return resultFunc.apply(null, arguments);\n            }\n        ].concat(finalMemoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n        var selector = memoize(function dependenciesChecker() {\n            var params = [];\n            var length = dependencies.length;\n            for(var i = 0; i < length; i++){\n                // apply arguments instead of spreading and mutate a local list of params for performance.\n                // @ts-ignore\n                params.push(dependencies[i].apply(null, arguments));\n            } // apply arguments instead of spreading for performance.\n            _lastResult = memoizedResultFunc.apply(null, params);\n            return _lastResult;\n        });\n        Object.assign(selector, {\n            resultFunc: resultFunc,\n            memoizedResultFunc: memoizedResultFunc,\n            dependencies: dependencies,\n            lastResult: function lastResult() {\n                return _lastResult;\n            },\n            recomputations: function recomputations() {\n                return _recomputations;\n            },\n            resetRecomputations: function resetRecomputations() {\n                return _recomputations = 0;\n            }\n        });\n        return selector;\n    }; // @ts-ignore\n    return createSelector;\n}\nvar createSelector = /* #__PURE__ */ createSelectorCreator(_defaultMemoize__WEBPACK_IMPORTED_MODULE_0__.defaultMemoize);\n// Manual definition of state and output arguments\nvar createStructuredSelector = function createStructuredSelector(selectors, selectorCreator) {\n    if (selectorCreator === void 0) {\n        selectorCreator = createSelector;\n    }\n    if (typeof selectors !== \"object\") {\n        throw new Error(\"createStructuredSelector expects first argument to be an object \" + (\"where each property is a selector, instead received a \" + typeof selectors));\n    }\n    var objectKeys = Object.keys(selectors);\n    var resultSelector = selectorCreator(objectKeys.map(function(key) {\n        return selectors[key];\n    }), function() {\n        for(var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            values[_key3] = arguments[_key3];\n        }\n        return values.reduce(function(composition, value, index) {\n            composition[objectKeys[index]] = value;\n            return composition;\n        }, {});\n    });\n    return resultSelector;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0U7QUFDeEI7QUFFaEQsU0FBU0UsZ0JBQWdCQyxLQUFLO0lBQzVCLElBQUlDLGVBQWVDLE1BQU1DLE9BQU8sQ0FBQ0gsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsR0FBR0E7SUFFeEQsSUFBSSxDQUFDQyxhQUFhRyxLQUFLLENBQUMsU0FBVUMsR0FBRztRQUNuQyxPQUFPLE9BQU9BLFFBQVE7SUFDeEIsSUFBSTtRQUNGLElBQUlDLGtCQUFrQkwsYUFBYU0sR0FBRyxDQUFDLFNBQVVGLEdBQUc7WUFDbEQsT0FBTyxPQUFPQSxRQUFRLGFBQWEsY0FBZUEsQ0FBQUEsSUFBSUcsSUFBSSxJQUFJLFNBQVEsSUFBSyxPQUFPLE9BQU9IO1FBQzNGLEdBQUdJLElBQUksQ0FBQztRQUNSLE1BQU0sSUFBSUMsTUFBTSxvR0FBb0dKLGtCQUFrQjtJQUN4STtJQUVBLE9BQU9MO0FBQ1Q7QUFFTyxTQUFTVSxzQkFBc0JDLE9BQU87SUFDM0MsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLHlCQUF5QixJQUFJZCxNQUFNVyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSSxPQUFPLEdBQUdBLE9BQU9KLE1BQU1JLE9BQVE7UUFDNUhELHNCQUFzQixDQUFDQyxPQUFPLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxLQUFLO0lBQ3BEO0lBRUEsSUFBSUMsaUJBQWlCLFNBQVNBO1FBQzVCLElBQUssSUFBSUMsUUFBUUwsVUFBVUMsTUFBTSxFQUFFZixRQUFRLElBQUlFLE1BQU1pQixRQUFRQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7WUFDOUZwQixLQUFLLENBQUNvQixNQUFNLEdBQUdOLFNBQVMsQ0FBQ00sTUFBTTtRQUNqQztRQUVBLElBQUlDLGtCQUFrQjtRQUV0QixJQUFJQyxhQUFhLHVGQUF1RjtR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QVVDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxLQUFLO1lBQ3RERixXQUFXLENBQUNSLFVBQVUsQ0FBQ1UsTUFBTSxDQUFDLEdBQUdEO1lBQ2pDLE9BQU9EO1FBQ1QsR0FBRyxDQUFDO0lBQ047SUFDQSxPQUFPTjtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2VzL2luZGV4LmpzPzVkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdE1lbW9pemUsIGRlZmF1bHRFcXVhbGl0eUNoZWNrIH0gZnJvbSAnLi9kZWZhdWx0TWVtb2l6ZSc7XG5leHBvcnQgeyBkZWZhdWx0TWVtb2l6ZSwgZGVmYXVsdEVxdWFsaXR5Q2hlY2sgfTtcblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGZ1bmNzKSB7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGZ1bmNzWzBdKSA/IGZ1bmNzWzBdIDogZnVuY3M7XG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24gKGRlcCkge1xuICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nO1xuICB9KSkge1xuICAgIHZhciBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nID8gXCJmdW5jdGlvbiBcIiArIChkZXAubmFtZSB8fCAndW5uYW1lZCcpICsgXCIoKVwiIDogdHlwZW9mIGRlcDtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsIGJ1dCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbXCIgKyBkZXBlbmRlbmN5VHlwZXMgKyBcIl1cIik7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lbW9pemVPcHRpb25zRnJvbUFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNyZWF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX3JlY29tcHV0YXRpb25zID0gMDtcblxuICAgIHZhciBfbGFzdFJlc3VsdDsgLy8gRHVlIHRvIHRoZSBpbnRyaWNhY2llcyBvZiByZXN0IHBhcmFtcywgd2UgY2FuJ3QgZG8gYW4gb3B0aW9uYWwgYXJnIGFmdGVyIGAuLi5mdW5jc2AuXG4gICAgLy8gU28sIHN0YXJ0IGJ5IGRlY2xhcmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxuICAgIC8vIChBbmQgeWVzLCB0aGUgd29yZHMgJ21lbW9pemUnIGFuZCAnb3B0aW9ucycgYXBwZWFyIHRvbyBtYW55IHRpbWVzIGluIHRoaXMgbmV4dCBzZXF1ZW5jZS4pXG5cblxuICAgIHZhciBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7XG4gICAgICBtZW1vaXplT3B0aW9uczogdW5kZWZpbmVkXG4gICAgfTsgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcIm91dHB1dCBzZWxlY3RvclwiIGlzIHRoZSBsYXN0IGFyZ1xuXG4gICAgdmFyIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTsgLy8gSWYgdGhlIHJlc3VsdCBmdW5jIGlzIGFjdHVhbGx5IGFuIF9vYmplY3RfLCBhc3N1bWUgaXQncyBvdXIgb3B0aW9ucyBvYmplY3RcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0RnVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7IC8vIGFuZCBwb3AgdGhlIHJlYWwgcmVzdWx0IGZ1bmMgb2ZmXG5cbiAgICAgIHJlc3VsdEZ1bmMgPSBmdW5jcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZVNlbGVjdG9yIGV4cGVjdHMgYW4gb3V0cHV0IGZ1bmN0aW9uIGFmdGVyIHRoZSBpbnB1dHMsIGJ1dCByZWNlaXZlZDogW1wiICsgdHlwZW9mIHJlc3VsdEZ1bmMgKyBcIl1cIik7XG4gICAgfSAvLyBEZXRlcm1pbmUgd2hpY2ggc2V0IG9mIG9wdGlvbnMgd2UncmUgdXNpbmcuIFByZWZlciBvcHRpb25zIHBhc3NlZCBkaXJlY3RseSxcbiAgICAvLyBidXQgZmFsbCBiYWNrIHRvIG9wdGlvbnMgZ2l2ZW4gdG8gY3JlYXRlU2VsZWN0b3JDcmVhdG9yLlxuXG5cbiAgICB2YXIgX2RpcmVjdGx5UGFzc2VkT3B0aW9uID0gZGlyZWN0bHlQYXNzZWRPcHRpb25zLFxuICAgICAgICBfZGlyZWN0bHlQYXNzZWRPcHRpb24yID0gX2RpcmVjdGx5UGFzc2VkT3B0aW9uLm1lbW9pemVPcHRpb25zLFxuICAgICAgICBtZW1vaXplT3B0aW9ucyA9IF9kaXJlY3RseVBhc3NlZE9wdGlvbjIgPT09IHZvaWQgMCA/IG1lbW9pemVPcHRpb25zRnJvbUFyZ3MgOiBfZGlyZWN0bHlQYXNzZWRPcHRpb24yOyAvLyBTaW1wbGlmeWluZyBhc3N1bXB0aW9uOiBpdCdzIHVubGlrZWx5IHRoYXQgdGhlIGZpcnN0IG9wdGlvbnMgYXJnIG9mIHRoZSBwcm92aWRlZCBtZW1vaXplclxuICAgIC8vIGlzIGFuIGFycmF5LiBJbiBtb3N0IGxpYnMgSSd2ZSBsb29rZWQgYXQsIGl0J3MgYW4gZXF1YWxpdHkgZnVuY3Rpb24gb3Igb3B0aW9ucyBvYmplY3QuXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGFycmF5IG9mIG9wdGlvbnMuIE90aGVyd2lzZSwgaXQgbXVzdCBiZSBqdXN0IHRoZSBfZmlyc3RfIGFyZywgYW5kIHNvXG4gICAgLy8gd2Ugd3JhcCBpdCBpbiBhbiBhcnJheSBzbyB3ZSBjYW4gYXBwbHkgaXQuXG5cbiAgICB2YXIgZmluYWxNZW1vaXplT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpID8gbWVtb2l6ZU9wdGlvbnMgOiBbbWVtb2l6ZU9wdGlvbnNdO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuICAgIHZhciBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplLmFwcGx5KHZvaWQgMCwgW2Z1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xuICAgICAgX3JlY29tcHV0YXRpb25zKys7IC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG5cbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfV0uY29uY2F0KGZpbmFsTWVtb2l6ZU9wdGlvbnMpKTsgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuXG4gICAgdmFyIHNlbGVjdG9yID0gbWVtb2l6ZShmdW5jdGlvbiBkZXBlbmRlbmNpZXNDaGVja2VyKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGFuZCBtdXRhdGUgYSBsb2NhbCBsaXN0IG9mIHBhcmFtcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGFyYW1zLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfSAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuXG5cbiAgICAgIF9sYXN0UmVzdWx0ID0gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihzZWxlY3Rvciwge1xuICAgICAgcmVzdWx0RnVuYzogcmVzdWx0RnVuYyxcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYzogbWVtb2l6ZWRSZXN1bHRGdW5jLFxuICAgICAgZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gICAgICBsYXN0UmVzdWx0OiBmdW5jdGlvbiBsYXN0UmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gX2xhc3RSZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlY29tcHV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gX3JlY29tcHV0YXRpb25zO1xuICAgICAgfSxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6IGZ1bmN0aW9uIHJlc2V0UmVjb21wdXRhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yO1xufVxuZXhwb3J0IHZhciBjcmVhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcihkZWZhdWx0TWVtb2l6ZSk7XG4vLyBNYW51YWwgZGVmaW5pdGlvbiBvZiBzdGF0ZSBhbmQgb3V0cHV0IGFyZ3VtZW50c1xuZXhwb3J0IHZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3Ioc2VsZWN0b3JzLCBzZWxlY3RvckNyZWF0b3IpIHtcbiAgaWYgKHNlbGVjdG9yQ3JlYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3I7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKFwid2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgXCIgKyB0eXBlb2Ygc2VsZWN0b3JzKSk7XG4gIH1cblxuICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ycyk7XG4gIHZhciByZXN1bHRTZWxlY3RvciA9IHNlbGVjdG9yQ3JlYXRvciggLy8gQHRzLWlnbm9yZVxuICBvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICB2YWx1ZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkge1xuICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfSwge30pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yO1xufTsiXSwibmFtZXMiOlsiZGVmYXVsdE1lbW9pemUiLCJkZWZhdWx0RXF1YWxpdHlDaGVjayIsImdldERlcGVuZGVuY2llcyIsImZ1bmNzIiwiZGVwZW5kZW5jaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJkZXAiLCJkZXBlbmRlbmN5VHlwZXMiLCJtYXAiLCJuYW1lIiwiam9pbiIsIkVycm9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwibWVtb2l6ZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtZW1vaXplT3B0aW9uc0Zyb21BcmdzIiwiX2tleSIsImNyZWF0ZVNlbGVjdG9yIiwiX2xlbjIiLCJfa2V5MiIsIl9yZWNvbXB1dGF0aW9ucyIsIl9sYXN0UmVzdWx0IiwiZGlyZWN0bHlQYXNzZWRPcHRpb25zIiwibWVtb2l6ZU9wdGlvbnMiLCJ1bmRlZmluZWQiLCJyZXN1bHRGdW5jIiwicG9wIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uIiwiX2RpcmVjdGx5UGFzc2VkT3B0aW9uMiIsImZpbmFsTWVtb2l6ZU9wdGlvbnMiLCJtZW1vaXplZFJlc3VsdEZ1bmMiLCJhcHBseSIsInJlY29tcHV0YXRpb25XcmFwcGVyIiwiY29uY2F0Iiwic2VsZWN0b3IiLCJkZXBlbmRlbmNpZXNDaGVja2VyIiwicGFyYW1zIiwiaSIsInB1c2giLCJPYmplY3QiLCJhc3NpZ24iLCJsYXN0UmVzdWx0IiwicmVjb21wdXRhdGlvbnMiLCJyZXNldFJlY29tcHV0YXRpb25zIiwiY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIiwic2VsZWN0b3JzIiwic2VsZWN0b3JDcmVhdG9yIiwib2JqZWN0S2V5cyIsImtleXMiLCJyZXN1bHRTZWxlY3RvciIsImtleSIsIl9sZW4zIiwidmFsdWVzIiwiX2tleTMiLCJyZWR1Y2UiLCJjb21wb3NpdGlvbiIsInZhbHVlIiwiaW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/reselect/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$();\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        // dispatch for CommonJS interop named imports.\n        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;\n        var didWarnOld18Alpha = false;\n        var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n        // because of a very particular set of implementation details and assumptions\n        // -- change any one of them and it will break. The most important assumption\n        // is that updates are always synchronous, because concurrent rendering is\n        // only available in versions of React that also have a built-in\n        // useSyncExternalStore API. And we only use this shim when the built-in API\n        // does not exist.\n        //\n        // Do not assume that the clever hacks used by this hook also work in general.\n        // The point of this shim is to replace the need for hacks by other libraries.\n        function useSyncExternalStore(subscribe, getSnapshot, // React do not expose a way to check if we're hydrating. So users of the shim\n        // will need to track that themselves and return the correct value\n        // from `getSnapshot`.\n        getServerSnapshot) {\n            _s();\n            {\n                if (!didWarnOld18Alpha) {\n                    if (React.startTransition !== undefined) {\n                        didWarnOld18Alpha = true;\n                        error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n                    }\n                }\n            }\n            // breaks the rules of React, and only works here because of specific\n            // implementation details, most importantly that updates are\n            // always synchronous.\n            var value = getSnapshot();\n            {\n                if (!didWarnUncachedGetSnapshot) {\n                    var cachedValue = getSnapshot();\n                    if (!objectIs(value, cachedValue)) {\n                        error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                        didWarnUncachedGetSnapshot = true;\n                    }\n                }\n            }\n            // re-render whenever the subscribed state changes by updating an some\n            // arbitrary useState hook. Then, during render, we call getSnapshot to read\n            // the current value.\n            //\n            // Because we don't actually use the state returned by the useState hook, we\n            // can save a bit of memory by storing other stuff in that slot.\n            //\n            // To implement the early bailout, we need to track some things on a mutable\n            // object. Usually, we would put that in a useRef hook, but we can stash it in\n            // our useState hook instead.\n            //\n            // To force a re-render, we call forceUpdate({inst}). That works because the\n            // new object always fails an equality check.\n            var _useState = useState({\n                inst: {\n                    value: value,\n                    getSnapshot: getSnapshot\n                }\n            }), inst = _useState[0].inst, forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n            // in the layout phase so we can access it during the tearing check that\n            // happens on subscribe.\n            useLayoutEffect(function() {\n                inst.value = value;\n                inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({\n                        inst: inst\n                    });\n                }\n            }, [\n                subscribe,\n                value,\n                getSnapshot\n            ]);\n            useEffect(function() {\n                // Check for changes right before subscribing. Subsequent changes will be\n                // detected in the subscription handler.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({\n                        inst: inst\n                    });\n                }\n                var handleStoreChange = function() {\n                    // TODO: Because there is no cross-renderer API for batching updates, it's\n                    // up to the consumer of this library to wrap their subscription event\n                    // with unstable_batchedUpdates. Should we try to detect when this isn't\n                    // the case and print a warning in development?\n                    // The store changed. Check if the snapshot changed since the last time we\n                    // read from the store.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                }; // Subscribe to the store and return a clean-up function.\n                return subscribe(handleStoreChange);\n            }, [\n                subscribe\n            ]);\n            useDebugValue(value);\n            return value;\n        }\n        _s(useSyncExternalStore, \"HNxGYQ39TeXJ0jUaPc6qLOsv73k=\");\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n            // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n            // React do not expose a way to check if we're hydrating. So users of the shim\n            // will need to track that themselves and return the correct value\n            // from `getSnapshot`.\n            return getSnapshot();\n        }\n        var canUseDOM = !!( true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var isServerEnvironment = !canUseDOM;\n        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n        var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n        exports.useSyncExternalStore = useSyncExternalStore$2;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4Qzs7UUFFTztRQUVWLHlDQUF5QyxHQUN6QyxJQUNFLE9BQU9DLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0JDLDJCQUEyQixLQUMvRCxZQUNGO1lBQ0FELCtCQUErQkMsMkJBQTJCLENBQUMsSUFBSUM7UUFDakU7UUFDVSxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztRQUU5QixJQUFJQyx1QkFBdUJGLE1BQU1HLGtEQUFrRDtRQUVuRixTQUFTQyxNQUFNQyxNQUFNO1lBQ25CO2dCQUNFO29CQUNFLElBQUssSUFBSUMsUUFBUUMsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1KLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlLLFFBQVEsR0FBR0EsUUFBUUwsT0FBT0ssUUFBUzt3QkFDakhGLElBQUksQ0FBQ0UsUUFBUSxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksTUFBTTtvQkFDcEM7b0JBRUFDLGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFDLEtBQUssRUFBRVIsTUFBTSxFQUFFSSxJQUFJO1lBQ3ZDLG1EQUFtRDtZQUNuRCw2Q0FBNkM7WUFDN0M7Z0JBQ0UsSUFBSUsseUJBQXlCWixxQkFBcUJZLHNCQUFzQjtnQkFDeEUsSUFBSUMsUUFBUUQsdUJBQXVCRSxnQkFBZ0I7Z0JBRW5ELElBQUlELFVBQVUsSUFBSTtvQkFDaEJWLFVBQVU7b0JBQ1ZJLE9BQU9BLEtBQUtRLE1BQU0sQ0FBQzt3QkFBQ0Y7cUJBQU07Z0JBQzVCLEVBQUUsK0RBQStEO2dCQUdqRSxJQUFJRyxpQkFBaUJULEtBQUtVLEdBQUcsQ0FBQyxTQUFV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LEtBQzlELFlBQ0Y7WUFDQW5FLCtCQUErQm1FLDBCQUEwQixDQUFDLElBQUlqRTtRQUNoRTtJQUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzNlOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsIlJlYWN0IiwicmVxdWlyZSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJlcnJvciIsImZvcm1hdCIsIl9sZW4yIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleTIiLCJwcmludFdhcm5pbmciLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiaXMiLCJ4IiwieSIsIm9iamVjdElzIiwiT2JqZWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwiZGlkV2Fybk9sZDE4QWxwaGEiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInN0YXJ0VHJhbnNpdGlvbiIsInVuZGVmaW5lZCIsInZhbHVlIiwiY2FjaGVkVmFsdWUiLCJfdXNlU3RhdGUiLCJpbnN0IiwiZm9yY2VVcGRhdGUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDEiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlckVudmlyb25tZW50Iiwic2hpbSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDIiLCJleHBvcnRzIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        var _s = $RefreshSig$();\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        var shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var useSyncExternalStore = shim.useSyncExternalStore;\n        // for CommonJS interop.\n        var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n            _s();\n            // Use this to track the rendered snapshot.\n            var instRef = useRef(null);\n            var inst;\n            if (instRef.current === null) {\n                inst = {\n                    hasValue: false,\n                    value: null\n                };\n                instRef.current = inst;\n            } else {\n                inst = instRef.current;\n            }\n            var _useMemo = useMemo(function() {\n                // Track the memoized state using closure variables that are local to this\n                // memoized instance of a getSnapshot function. Intentionally not using a\n                // useRef hook, because that state would be shared across all concurrent\n                // copies of the hook/component.\n                var hasMemo = false;\n                var memoizedSnapshot;\n                var memoizedSelection;\n                var memoizedSelector = function(nextSnapshot) {\n                    if (!hasMemo) {\n                        // The first time the hook is called, there is no memoized result.\n                        hasMemo = true;\n                        memoizedSnapshot = nextSnapshot;\n                        var _nextSelection = selector(nextSnapshot);\n                        if (isEqual !== undefined) {\n                            // Even if the selector has changed, the currently rendered selection\n                            // may be equal to the new selection. We should attempt to reuse the\n                            // current value if possible, to preserve downstream memoizations.\n                            if (inst.hasValue) {\n                                var currentSelection = inst.value;\n                                if (isEqual(currentSelection, _nextSelection)) {\n                                    memoizedSelection = currentSelection;\n                                    return currentSelection;\n                                }\n                            }\n                        }\n                        memoizedSelection = _nextSelection;\n                        return _nextSelection;\n                    } // We may be able to reuse the previous invocation's result.\n                    // We may be able to reuse the previous invocation's result.\n                    var prevSnapshot = memoizedSnapshot;\n                    var prevSelection = memoizedSelection;\n                    if (objectIs(prevSnapshot, nextSnapshot)) {\n                        // The snapshot is the same as last time. Reuse the previous selection.\n                        return prevSelection;\n                    } // The snapshot has changed, so we need to compute a new selection.\n                    // The snapshot has changed, so we need to compute a new selection.\n                    var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    // If a custom isEqual function is provided, use that to check if the data\n                    // has changed. If it hasn't, return the previous selection. That signals\n                    // to React that the selections are conceptually equal, and we can bail\n                    // out of rendering.\n                    if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                        return prevSelection;\n                    }\n                    memoizedSnapshot = nextSnapshot;\n                    memoizedSelection = nextSelection;\n                    return nextSelection;\n                }; // Assigning this to a constant so that Flow knows it can't change.\n                // Assigning this to a constant so that Flow knows it can't change.\n                var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n                var getSnapshotWithSelector = function() {\n                    return memoizedSelector(getSnapshot());\n                };\n                var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {\n                    return memoizedSelector(maybeGetServerSnapshot());\n                };\n                return [\n                    getSnapshotWithSelector,\n                    getServerSnapshotWithSelector\n                ];\n            }, [\n                getSnapshot,\n                getServerSnapshot,\n                selector,\n                isEqual\n            ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n            var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n            useEffect(function() {\n                inst.hasValue = true;\n                inst.value = value;\n            }, [\n                value\n            ]);\n            useDebugValue(value);\n            return value;\n        }\n        _s(useSyncExternalStoreWithSelector, \"mZhzs7ShZXU5RBraOlzBOQ4BK68=\", false, function() {\n            return [\n                useSyncExternalStore\n            ];\n        });\n        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDOztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO1FBQzlCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO1FBRW5COzs7Q0FHQyxHQUNELFNBQVNFLEdBQUdDLENBQUMsRUFBRUMsQ0FBQztZQUNkLE9BQU9ELE1BQU1DLEtBQU1ELENBQUFBLE1BQU0sS0FBSyxJQUFJQSxNQUFNLElBQUlDLENBQUFBLEtBQU1ELE1BQU1BLEtBQUtDLE1BQU1BLEVBQUUsc0NBQXNDOztRQUU3RztRQUVBLElBQUlDLFdBQVcsT0FBT0MsT0FBT0osRUFBRSxLQUFLLGFBQWFJLE9BQU9KLEVBQUUsR0FBR0E7UUFFN0QsSUFBSUssdUJBQXVCTixLQUFLTSxvQkFBb0I7UUFFcEQsd0JBQXdCO1FBRXhCLElBQUlDLFNBQVNULE1BQU1TLE1BQU0sRUFDckJDLFlBQVlWLE1BQU1VLFNBQVMsRUFDM0JDLFVBQVVYLE1BQU1XLE9BQU8sRUFDdkJDLGdCQUFnQlosTUFBTVksYUFBYSxFQUFFLDZFQUE2RTtRQUV0SCxTQUFTQyxpQ0FBaUNDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRUMsUUFBUSxFQUFFQyxPQUFPOztZQUNwRywyQ0FBMkM7WUFDM0MsSUFBSUMsVUFBVVYsT0FBTztZQUNyQixJQUFJVztZQUVKLElBQUlELFFBQVFFLE9BQU8sS0FBSyxNQUFNO2dCQUM1QkQsT0FBTztvQkFDTEUsVUFBVTtvQkFDVkMsT0FBTztnQkFDVDtnQkFDQUosUUFBUUUsT0FBTyxHQUFHRDtZQUNwQixPQUFPO2dCQUNMQSxPQUFPRCxRQUFRRSxPQUFPO1lBQ3hCO1lBRUEsSUFBSUcsV0FBV2IsUUFBUTtnQkFDckIsMEVBQTBFO2dCQUMxRSx5RUFBeUU7Z0JBQ3pFLHdFQUF3RTtnQkFDeEUsZ0NBQWdDO2dCQUNoQyxJQUFJYyxVQUFVO2dCQUNkLElBQUlDO2dCQUNKLElBQUlDO2dCQUVKLElBQUlDLG1CQUFtQixTQUFVQyxZQUFZO29CQUMzQyxJQUFJLENBQUNKLFNBQVM7d0JBQ1osa0VBQWtFO3dCQUNsRUEsVUFBVTt3QkFDVkMsbUJBQW1CRzt3QkFFbkIsSUFBSUMsaUJBQWlCYixTQUFTWTt3QkFFOUIsSUFBSVgsWUFBWWEsV0FBVzs0QkFDekIscUVBQXFFOzRCQUNyRSxvRUFBb0U7NEJBQ3BFLGtFQUFrRTs0QkFDbEUsSUFBSVgsS0FBS0UsUUFBUSxFQUFFO2dDQUNqQixJQUFJVSxtQkFBbUJaLEtBQUtHLEtBQUs7Z0NBRWpDLElBQUlMLFFBQVFjLGtCQUFrQkYsaUJBQWlCO29DQUM3Q0gsb0JBQW9CSztvQ0FDcEIsT0FBT0E7Z0NBQ1Q7NEJBQ0Y7d0JBQ0Y7d0JBRUFMLG9CQUFvQkc7d0JBQ3BCLE9BQU9BO29CQUNULEVBQUUsNERBQTREO29CQUc5RCw0REFBNEQ7b0JBQzVELElBQUlHLGVBQWVQO29CQUNuQixJQUFJUSxnQkFBZ0JQO29CQUVwQixJQUFJckIsU0FBUzJCLGNBQWNKLGVBQWU7d0JBQ3hDLHVFQUF1RTt3QkFDdkUsT0FBT0s7b0JBQ1QsRUFBRSxtRUFBbUU7b0JBR3JFLG1FQUFtRTtvQkFDbkUsSUFBSUMsZ0JBQWdCbEIsU0FBU1ksZUFBZSwwRUFBMEU7b0JBQ3RILHlFQUF5RTtvQkFDekUsdUVBQXVFO29CQUN2RSxvQkFBb0I7b0JBRXBCLDBFQUEwRTtvQkFDMUUseUVBQXlFO29CQUN6RSx1RUFBdUU7b0JBQ3ZFLG9CQUFvQjtvQkFDcEIsSUFBSVgsWUFBWWEsYUFBYWIsUUFBUWdCLGVBQWVDLGdCQUFnQjt3QkFDbEUsT0FBT0Q7b0JBQ1Q7b0JBRUFSLG1CQUFtQkc7b0JBQ25CRixvQkFBb0JRO29CQUNwQixPQUFPQTtnQkFDVCxHQUFHLG1FQUFtRTtnQkFHdEUsbUVBQW1FO2dCQUNuRSxJQUFJQyx5QkFBeUJwQixzQkFBc0JlLFlBQVksT0FBT2Y7Z0JBRXRFLElBQUlxQiwwQkFBMEI7b0JBQzVCLE9BQU9ULGlCQUFpQmI7Z0JBQzFCO2dCQUVBLElBQUl1QixnQ0FBZ0NGLDJCQUEyQixPQUFPTCxZQUFZO29CQUNoRixPQUFPSCxpQkFBaUJRO2dCQUMxQjtnQkFDQSxPQUFPO29CQUFDQztvQkFBeUJDO2lCQUE4QjtZQUNqRSxHQUFHO2dCQUFDdkI7Z0JBQWFDO2dCQUFtQkM7Z0JBQVVDO2FBQVEsR0FDbERxQixlQUFlZixRQUFRLENBQUMsRUFBRSxFQUMxQmdCLHFCQUFxQmhCLFFBQVEsQ0FBQyxFQUFFO1lBRXBDLElBQUlELFFBQVFmLHFCQUFxQk0sV0FBV3lCLGNBQWNDO1lBQzFEOUIsVUFBVTtnQkFDUlUsS0FBS0UsUUFBUSxHQUFHO2dCQUNoQkYsS0FBS0csS0FBSyxHQUFHQTtZQUNmLEdBQUc7Z0JBQUNBO2FBQU07WUFDVlgsY0FBY1c7WUFDZCxPQUFPQTtRQUNUO1dBdkdTVjs7Z0JBZ0dLTDs7O1FBU2RpQyx3Q0FBd0MsR0FBRzVCO1FBQ2pDLHlDQUF5QyxHQUNuRCxJQUNFLE9BQU9oQixtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCNkMsMEJBQTBCLEtBQzlELFlBQ0Y7WUFDQTdDLCtCQUErQjZDLDBCQUEwQixDQUFDLElBQUkzQztRQUNoRTtJQUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanM/NzVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltJyk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHNoaW0udXNlU3luY0V4dGVybmFsU3RvcmU7XG5cbi8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG52YXIgdXNlUmVmID0gUmVhY3QudXNlUmVmLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VNZW1vID0gUmVhY3QudXNlTWVtbyxcbiAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZTsgLy8gU2FtZSBhcyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSwgYnV0IHN1cHBvcnRzIHNlbGVjdG9yIGFuZCBpc0VxdWFsIGFyZ3VtZW50cy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHRoZSByZW5kZXJlZCBzbmFwc2hvdC5cbiAgdmFyIGluc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBpbnN0O1xuXG4gIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpbnN0ID0ge1xuICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xuICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgaW5zdCA9IGluc3RSZWYuY3VycmVudDtcbiAgfVxuXG4gIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIC8vIFRyYWNrIHRoZSBtZW1vaXplZCBzdGF0ZSB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcyB0aGF0IGFyZSBsb2NhbCB0byB0aGlzXG4gICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuICAgIC8vIHVzZVJlZiBob29rLCBiZWNhdXNlIHRoYXQgc3RhdGUgd291bGQgYmUgc2hhcmVkIGFjcm9zcyBhbGwgY29uY3VycmVudFxuICAgIC8vIGNvcGllcyBvZiB0aGUgaG9vay9jb21wb25lbnQuXG4gICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcbiAgICB2YXIgbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcbiAgICAgIGlmICghaGFzTWVtbykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB0aGUgaG9vayBpcyBjYWxsZWQsIHRoZXJlIGlzIG5vIG1lbW9pemVkIHJlc3VsdC5cbiAgICAgICAgaGFzTWVtbyA9IHRydWU7XG4gICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG5cbiAgICAgICAgdmFyIF9uZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcblxuICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB0aGUgc2VsZWN0b3IgaGFzIGNoYW5nZWQsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgc2VsZWN0aW9uXG4gICAgICAgICAgLy8gbWF5IGJlIGVxdWFsIHRvIHRoZSBuZXcgc2VsZWN0aW9uLiBXZSBzaG91bGQgYXR0ZW1wdCB0byByZXVzZSB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cbiAgICAgICAgICBpZiAoaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuICAgICAgICByZXR1cm4gX25leHRTZWxlY3Rpb247XG4gICAgICB9IC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXG5cbiAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuICAgICAgdmFyIHByZXZTbmFwc2hvdCA9IG1lbW9pemVkU25hcHNob3Q7XG4gICAgICB2YXIgcHJldlNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuXG4gICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG4gICAgICAgIC8vIFRoZSBzbmFwc2hvdCBpcyB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuIFJldXNlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuICAgICAgLy8gVGhlIHNuYXBzaG90IGhhcyBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIGNvbXB1dGUgYSBuZXcgc2VsZWN0aW9uLlxuICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpOyAvLyBJZiBhIGN1c3RvbSBpc0VxdWFsIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgdGhhdCB0byBjaGVjayBpZiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcbiAgICAgIC8vIG91dCBvZiByZW5kZXJpbmcuXG5cbiAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cbiAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQgJiYgaXNFcXVhbChwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjtcbiAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuICAgIH07IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblxuXG4gICAgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuICAgIHZhciBnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IgPSBtYXliZUdldFNlcnZlclNuYXBzaG90ID09PSBudWxsID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBbZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IsIGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yXTtcbiAgfSwgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdKSxcbiAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuICAgICAgZ2V0U2VydmVyU2VsZWN0aW9uID0gX3VzZU1lbW9bMV07XG5cbiAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTZWxlY3Rpb24sIGdldFNlcnZlclNlbGVjdGlvbik7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC5oYXNWYWx1ZSA9IHRydWU7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3QiLCJyZXF1aXJlIiwic2hpbSIsImlzIiwieCIsInkiLCJvYmplY3RJcyIsIk9iamVjdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZURlYnVnVmFsdWUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJzZWxlY3RvciIsImlzRXF1YWwiLCJpbnN0UmVmIiwiaW5zdCIsImN1cnJlbnQiLCJoYXNWYWx1ZSIsInZhbHVlIiwiX3VzZU1lbW8iLCJoYXNNZW1vIiwibWVtb2l6ZWRTbmFwc2hvdCIsIm1lbW9pemVkU2VsZWN0aW9uIiwibWVtb2l6ZWRTZWxlY3RvciIsIm5leHRTbmFwc2hvdCIsIl9uZXh0U2VsZWN0aW9uIiwidW5kZWZpbmVkIiwiY3VycmVudFNlbGVjdGlvbiIsInByZXZTbmFwc2hvdCIsInByZXZTZWxlY3Rpb24iLCJuZXh0U2VsZWN0aW9uIiwibWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCIsImdldFNuYXBzaG90V2l0aFNlbGVjdG9yIiwiZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3IiLCJnZXRTZWxlY3Rpb24iLCJnZXRTZXJ2ZXJTZWxlY3Rpb24iLCJleHBvcnRzIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDRNQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcz8yZTg3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsd09BQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanM/ZTMzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/scss/globals.scss":
/*!*****************************************!*\
  !*** ./public/assets/scss/globals.scss ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"a5501fcb1f1f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvc2Nzcy9nbG9iYWxzLnNjc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy9hc3NldHMvc2Nzcy9nbG9iYWxzLnNjc3M/OGQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImE1NTAxZmNiMWYxZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/scss/globals.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/scss/style.scss":
/*!***************************************!*\
  !*** ./public/assets/scss/style.scss ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"302bfceece06\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvc2Nzcy9zdHlsZS5zY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wdWJsaWMvYXNzZXRzL3Njc3Mvc3R5bGUuc2Nzcz8wMDhmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMzAyYmZjZWVjZTA2XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/scss/style.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/provider.tsx":
/*!****************************************!*\
  !*** ./src/redux-toolkit/provider.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Providers: function() { return /* binding */ Providers; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ \"(app-pages-browser)/./src/redux-toolkit/store.tsx\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(app-pages-browser)/./node_modules/react-redux/es/index.js\");\n/* __next_internal_client_entry_do_not_use__ Providers auto */ \n\n\nfunction Providers(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, {\n        store: _store__WEBPACK_IMPORTED_MODULE_1__.store,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/michelangelogelardi/Documents/Work/Dev/time-voyage/src/redux-toolkit/provider.tsx\",\n        lineNumber: 7,\n        columnNumber: 10\n    }, this);\n}\n_c = Providers;\nvar _c;\n$RefreshReg$(_c, \"Providers\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3Byb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVnQztBQUNPO0FBRWhDLFNBQVNFLFVBQVUsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQztJQUN4QixxQkFBTyw4REFBQ0YsaURBQVFBO1FBQUNELE9BQU9BLHlDQUFLQTtrQkFBR0c7Ozs7OztBQUNsQztLQUZnQkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3JlZHV4LXRvb2xraXQvcHJvdmlkZXIudHN4P2Y0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHN0b3JlIH0gZnJvbSBcIi4vc3RvcmVcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlcnMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICByZXR1cm4gPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+e2NoaWxkcmVufTwvUHJvdmlkZXI+O1xufVxuIl0sIm5hbWVzIjpbInN0b3JlIiwiUHJvdmlkZXIiLCJQcm92aWRlcnMiLCJjaGlsZHJlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/reducers/FavouritePageSlice.tsx":
/*!***********************************************************!*\
  !*** ./src/redux-toolkit/reducers/FavouritePageSlice.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   favouritePageSlice: function() { return /* binding */ favouritePageSlice; },\n/* harmony export */   setQueryValue: function() { return /* binding */ setQueryValue; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n\nconst initialState = {\n    queryValue: \"\"\n};\nconst favouritePageSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"favouritePageSlice\",\n    initialState,\n    reducers: {\n        setQueryValue: (state, action)=>{\n            state.queryValue = action.payload;\n        }\n    }\n});\nconst { setQueryValue } = favouritePageSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (favouritePageSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL0Zhdm91cml0ZVBhZ2VTbGljZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStDO0FBRy9DLE1BQU1DLGVBQW1DO0lBQ3ZDQyxZQUFZO0FBQ2Q7QUFFUSxNQUFNQyxxQkFBcUJILDZEQUFXQSxDQUFDO0lBQzdDSSxNQUFNO0lBQ05IO0lBQ0FJLFVBQVU7UUFDUkMsZUFBZSxDQUFDQyxPQUFPQztZQUNyQkQsTUFBTUwsVUFBVSxHQUFHTSxPQUFPQyxPQUFPO1FBQ25DO0lBQ0Y7QUFDRixHQUFHO0FBRUksTUFBTSxFQUFFSCxhQUFhLEVBQUUsR0FBR0gsbUJBQW1CTyxPQUFPLENBQUM7QUFFNUQsK0RBQWVQLG1CQUFtQlEsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL0Zhdm91cml0ZVBhZ2VTbGljZS50c3g/ZjNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBGYXZvdXJpdGVQYWdlU2xpY2UgfSBmcm9tIFwiLi4vUmVkdWNlcnNUeXBlc1wiO1xuXG5jb25zdCBpbml0aWFsU3RhdGU6IEZhdm91cml0ZVBhZ2VTbGljZSA9IHtcbiAgcXVlcnlWYWx1ZTogXCJcIixcbn07XG5cbiBleHBvcnQgY29uc3QgZmF2b3VyaXRlUGFnZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiBcImZhdm91cml0ZVBhZ2VTbGljZVwiLFxuICBpbml0aWFsU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgc2V0UXVlcnlWYWx1ZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnF1ZXJ5VmFsdWUgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuICB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCB7IHNldFF1ZXJ5VmFsdWUgfSA9IGZhdm91cml0ZVBhZ2VTbGljZS5hY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBmYXZvdXJpdGVQYWdlU2xpY2UucmVkdWNlcjtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTbGljZSIsImluaXRpYWxTdGF0ZSIsInF1ZXJ5VmFsdWUiLCJmYXZvdXJpdGVQYWdlU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJzZXRRdWVyeVZhbHVlIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwiYWN0aW9ucyIsInJlZHVjZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/reducers/FavouritePageSlice.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/reducers/LayoutSlice.tsx":
/*!****************************************************!*\
  !*** ./src/redux-toolkit/reducers/LayoutSlice.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayoutSlice: function() { return /* binding */ LayoutSlice; },\n/* harmony export */   setBackgroundImage: function() { return /* binding */ setBackgroundImage; },\n/* harmony export */   setImageLink: function() { return /* binding */ setImageLink; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n\nconst initialState = {\n    imageLink: \"user-sm/15.jpg\",\n    backgroundImage: \"cover/1.jpg\"\n};\nconst LayoutSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"LayoutSlice\",\n    initialState,\n    reducers: {\n        setImageLink: (state, action)=>{\n            state.imageLink = action.payload;\n        },\n        setBackgroundImage: (state, action)=>{\n            state.backgroundImage = action.payload;\n        }\n    }\n});\nconst { setImageLink, setBackgroundImage } = LayoutSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (LayoutSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL0xheW91dFNsaWNlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStDO0FBRy9DLE1BQU1DLGVBQXFDO0lBQ3pDQyxXQUFXO0lBQ1hDLGlCQUFpQjtBQUNuQjtBQUVPLE1BQU1DLGNBQWNKLDZEQUFXQSxDQUFDO0lBQ3JDSyxNQUFNO0lBQ05KO0lBQ0FLLFVBQVU7UUFDUkMsY0FBYyxDQUFDQyxPQUFPQztZQUNwQkQsTUFBTU4sU0FBUyxHQUFHTyxPQUFPQyxPQUFPO1FBQ2xDO1FBQ0FDLG9CQUFvQixDQUFDSCxPQUFPQztZQUMxQkQsTUFBTUwsZUFBZSxHQUFHTSxPQUFPQyxPQUFPO1FBQ3hDO0lBQ0Y7QUFDRixHQUFHO0FBRUksTUFBTSxFQUFFSCxZQUFZLEVBQUNJLGtCQUFrQixFQUFFLEdBQUdQLFlBQVlRLE9BQU8sQ0FBQztBQUV2RSwrREFBZVIsWUFBWVMsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL0xheW91dFNsaWNlLnRzeD81MWE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNsaWNlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IExheW91dFNsaWNlSW50ZXJGYWNlIH0gZnJvbSBcIi4uL1JlZHVjZXJzVHlwZXNcIjtcblxuY29uc3QgaW5pdGlhbFN0YXRlOiBMYXlvdXRTbGljZUludGVyRmFjZSA9IHtcbiAgaW1hZ2VMaW5rOiBcInVzZXItc20vMTUuanBnXCIsXG4gIGJhY2tncm91bmRJbWFnZTogXCJjb3Zlci8xLmpwZ1wiLFxufTtcblxuZXhwb3J0IGNvbnN0IExheW91dFNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lOiBcIkxheW91dFNsaWNlXCIsXG4gIGluaXRpYWxTdGF0ZSxcbiAgcmVkdWNlcnM6IHtcbiAgICBzZXRJbWFnZUxpbms6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5pbWFnZUxpbmsgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuICAgIHNldEJhY2tncm91bmRJbWFnZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLmJhY2tncm91bmRJbWFnZSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgc2V0SW1hZ2VMaW5rLHNldEJhY2tncm91bmRJbWFnZSB9ID0gTGF5b3V0U2xpY2UuYWN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0U2xpY2UucmVkdWNlcjtcbiJdLCJuYW1lcyI6WyJjcmVhdGVTbGljZSIsImluaXRpYWxTdGF0ZSIsImltYWdlTGluayIsImJhY2tncm91bmRJbWFnZSIsIkxheW91dFNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwic2V0SW1hZ2VMaW5rIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwic2V0QmFja2dyb3VuZEltYWdlIiwiYWN0aW9ucyIsInJlZHVjZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/reducers/LayoutSlice.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/reducers/ShowMorePostSlice.tsx":
/*!**********************************************************!*\
  !*** ./src/redux-toolkit/reducers/ShowMorePostSlice.tsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShowMorePostSlice: function() { return /* binding */ ShowMorePostSlice; },\n/* harmony export */   handleNextPost: function() { return /* binding */ handleNextPost; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n\nconst initialState = {\n    style1: [],\n    style3: [],\n    style4: [],\n    style7: [],\n    style12: [],\n    favouriteHome: []\n};\nconst ShowMorePostSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"ShowMorePostSlice\",\n    initialState,\n    reducers: {\n        handleNextPost: (state, action)=>{\n            const tempValue = action.payload;\n            const temp = [\n                ...state[tempValue]\n            ];\n            temp.push(state[tempValue].length);\n            state[tempValue] = temp;\n        }\n    }\n});\nconst { handleNextPost } = ShowMorePostSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShowMorePostSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL1Nob3dNb3JlUG9zdFNsaWNlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFHL0MsTUFBTUMsZUFBMkM7SUFDL0NDLFFBQVEsRUFBRTtJQUNWQyxRQUFRLEVBQUU7SUFDVkMsUUFBUSxFQUFFO0lBQ1ZDLFFBQVEsRUFBRTtJQUNWQyxTQUFTLEVBQUU7SUFDWEMsZUFBZSxFQUFFO0FBVW5CO0FBRU8sTUFBTUMsb0JBQW9CUiw2REFBV0EsQ0FBQztJQUMzQ1MsTUFBTTtJQUNOUjtJQUNBUyxVQUFVO1FBQ1JDLGdCQUFnQixDQUNkQyxPQUNBQztZQUVBLE1BQU1DLFlBQVlELE9BQU9FLE9BQU87WUFDaEMsTUFBTUMsT0FBTzttQkFBSUosS0FBSyxDQUFDRSxVQUFVO2FBQUM7WUFDbENFLEtBQUtDLElBQUksQ0FBQ0wsS0FBSyxDQUFDRSxVQUFVLENBQUNJLE1BQU07WUFDakNOLEtBQUssQ0FBQ0UsVUFBVSxHQUFHRTtRQUNyQjtJQUNGO0FBQ0YsR0FBRztBQUVJLE1BQU0sRUFBRUwsY0FBYyxFQUFFLEdBQUdILGtCQUFrQlcsT0FBTyxDQUFDO0FBRTVELCtEQUFlWCxrQkFBa0JZLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcmVkdXgtdG9vbGtpdC9yZWR1Y2Vycy9TaG93TW9yZVBvc3RTbGljZS50c3g/NzcyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBTaG93TW9yZVBvc3RTbGljZUludGVyRmFjZSB9IGZyb20gXCIuLi9SZWR1Y2Vyc1R5cGVzXCI7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZTogU2hvd01vcmVQb3N0U2xpY2VJbnRlckZhY2UgPSB7XG4gIHN0eWxlMTogW10sXG4gIHN0eWxlMzogW10sXG4gIHN0eWxlNDogW10sXG4gIHN0eWxlNzogW10sXG4gIHN0eWxlMTI6IFtdLFxuICBmYXZvdXJpdGVIb21lOiBbXSxcblxuXG4gIC8vICAgc3R5bGUyOltdXG4gIC8vICAgc3R5bGUzOltdXG4gIC8vICAgc3R5bGU0OltdXG4gIC8vICAgc3R5bGU1OltdXG4gIC8vICAgc3R5bGU2OltdXG4gIC8vICAgc3R5bGU3OltdXG4gIC8vICAgc3R5bGU4OltdXG59O1xuXG5leHBvcnQgY29uc3QgU2hvd01vcmVQb3N0U2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWU6IFwiU2hvd01vcmVQb3N0U2xpY2VcIixcbiAgaW5pdGlhbFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIGhhbmRsZU5leHRQb3N0OiAoXG4gICAgICBzdGF0ZSxcbiAgICAgIGFjdGlvbjogeyBwYXlsb2FkOiBcInN0eWxlMVwiIHwgXCJzdHlsZTNcIiB8IFwic3R5bGU0XCIgfCBcInN0eWxlN1wiIHxcInN0eWxlMTJcIiB8XCJmYXZvdXJpdGVIb21lXCIgfVxuICAgICkgPT4ge1xuICAgICAgY29uc3QgdGVtcFZhbHVlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBjb25zdCB0ZW1wID0gWy4uLnN0YXRlW3RlbXBWYWx1ZV1dO1xuICAgICAgdGVtcC5wdXNoKHN0YXRlW3RlbXBWYWx1ZV0ubGVuZ3RoKTtcbiAgICAgIHN0YXRlW3RlbXBWYWx1ZV0gPSB0ZW1wO1xuICAgIH0sXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgaGFuZGxlTmV4dFBvc3QgfSA9IFNob3dNb3JlUG9zdFNsaWNlLmFjdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFNob3dNb3JlUG9zdFNsaWNlLnJlZHVjZXI7XG4iXSwibmFtZXMiOlsiY3JlYXRlU2xpY2UiLCJpbml0aWFsU3RhdGUiLCJzdHlsZTEiLCJzdHlsZTMiLCJzdHlsZTQiLCJzdHlsZTciLCJzdHlsZTEyIiwiZmF2b3VyaXRlSG9tZSIsIlNob3dNb3JlUG9zdFNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwiaGFuZGxlTmV4dFBvc3QiLCJzdGF0ZSIsImFjdGlvbiIsInRlbXBWYWx1ZSIsInBheWxvYWQiLCJ0ZW1wIiwicHVzaCIsImxlbmd0aCIsImFjdGlvbnMiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/reducers/ShowMorePostSlice.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/reducers/StoriesModalSlice.tsx":
/*!**********************************************************!*\
  !*** ./src/redux-toolkit/reducers/StoriesModalSlice.tsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setShowModal: function() { return /* binding */ setShowModal; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n\nconst initialState = {\n    showModal: false\n};\nconst storiesModalSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: \"StoriesModalSlice\",\n    initialState,\n    reducers: {\n        setShowModal: (state)=>{\n            state.showModal = !state.showModal;\n        }\n    }\n});\nconst { setShowModal } = storiesModalSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (storiesModalSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL1N0b3JpZXNNb2RhbFNsaWNlLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUcvQyxNQUFNQyxlQUE2QjtJQUNqQ0MsV0FBVztBQUNiO0FBRUEsTUFBTUMsb0JBQW9CSCw2REFBV0EsQ0FBQztJQUNwQ0ksTUFBTTtJQUNOSDtJQUNBSSxVQUFVO1FBQ1JDLGNBQWMsQ0FBQ0M7WUFDYkEsTUFBTUwsU0FBUyxHQUFHLENBQUNLLE1BQU1MLFNBQVM7UUFDcEM7SUFDRjtBQUNGO0FBRU8sTUFBTSxFQUFFSSxZQUFZLEVBQUUsR0FBR0gsa0JBQWtCSyxPQUFPLENBQUM7QUFFMUQsK0RBQWVMLGtCQUFrQk0sT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9yZWR1eC10b29sa2l0L3JlZHVjZXJzL1N0b3JpZXNNb2RhbFNsaWNlLnRzeD8wMzBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNsaWNlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IFN0b3JpZXNNb2RhbCB9IGZyb20gXCIuLi9SZWR1Y2Vyc1R5cGVzXCI7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZTogU3Rvcmllc01vZGFsID0ge1xuICBzaG93TW9kYWw6IGZhbHNlLFxufTtcblxuY29uc3Qgc3Rvcmllc01vZGFsU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWU6IFwiU3Rvcmllc01vZGFsU2xpY2VcIixcbiAgaW5pdGlhbFN0YXRlLFxuICByZWR1Y2Vyczoge1xuICAgIHNldFNob3dNb2RhbDogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5zaG93TW9kYWwgPSAhc3RhdGUuc2hvd01vZGFsO1xuICAgIH0sXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgc2V0U2hvd01vZGFsIH0gPSBzdG9yaWVzTW9kYWxTbGljZS5hY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yaWVzTW9kYWxTbGljZS5yZWR1Y2VyO1xuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiaW5pdGlhbFN0YXRlIiwic2hvd01vZGFsIiwic3Rvcmllc01vZGFsU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJzZXRTaG93TW9kYWwiLCJzdGF0ZSIsImFjdGlvbnMiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/reducers/StoriesModalSlice.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/redux-toolkit/store.tsx":
/*!*************************************!*\
  !*** ./src/redux-toolkit/store.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   store: function() { return /* binding */ store; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n/* harmony import */ var _reduxjs_toolkit_dist_query__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reduxjs/toolkit/dist/query */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js\");\n/* harmony import */ var _reduxjs_toolkit_dist_query__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_reduxjs_toolkit_dist_query__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _reducers_StoriesModalSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reducers/StoriesModalSlice */ \"(app-pages-browser)/./src/redux-toolkit/reducers/StoriesModalSlice.tsx\");\n/* harmony import */ var _reducers_FavouritePageSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reducers/FavouritePageSlice */ \"(app-pages-browser)/./src/redux-toolkit/reducers/FavouritePageSlice.tsx\");\n/* harmony import */ var _reducers_LayoutSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reducers/LayoutSlice */ \"(app-pages-browser)/./src/redux-toolkit/reducers/LayoutSlice.tsx\");\n/* harmony import */ var _reducers_ShowMorePostSlice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reducers/ShowMorePostSlice */ \"(app-pages-browser)/./src/redux-toolkit/reducers/ShowMorePostSlice.tsx\");\n\n\n\n\n\n\nconst store = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.configureStore)({\n    reducer: {\n        storiesModalSlice: _reducers_StoriesModalSlice__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n        favouritePageSlice: _reducers_FavouritePageSlice__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        LayoutSlice: _reducers_LayoutSlice__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n        ShowMorePostSlice: _reducers_ShowMorePostSlice__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    },\n    devTools: true\n});\n(0,_reduxjs_toolkit_dist_query__WEBPACK_IMPORTED_MODULE_5__.setupListeners)(store.dispatch);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9yZWR1eC10b29sa2l0L3N0b3JlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrRDtBQUNXO0FBQ0E7QUFDRTtBQUNkO0FBQ1k7QUFFdEQsTUFBTU0sUUFBUU4sZ0VBQWNBLENBQUM7SUFDbENPLFNBQVM7UUFDUEwsaUJBQWlCQSxxRUFBQUE7UUFDakJDLGtCQUFrQkEsc0VBQUFBO1FBQ2xCQyxXQUFXQSwrREFBQUE7UUFDWEMsaUJBQWlCQSxxRUFBQUE7SUFDbkI7SUFDQUcsVUFBVTtBQUNaLEdBQUc7QUFFSFAsMkVBQWNBLENBQUNLLE1BQU1HLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3JlZHV4LXRvb2xraXQvc3RvcmUudHN4PzkxMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uZmlndXJlU3RvcmUgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgc2V0dXBMaXN0ZW5lcnMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5XCI7XG5pbXBvcnQgc3Rvcmllc01vZGFsU2xpY2UgZnJvbSBcIi4vcmVkdWNlcnMvU3Rvcmllc01vZGFsU2xpY2VcIjtcbmltcG9ydCBmYXZvdXJpdGVQYWdlU2xpY2UgZnJvbSBcIi4vcmVkdWNlcnMvRmF2b3VyaXRlUGFnZVNsaWNlXCI7XG5pbXBvcnQgTGF5b3V0U2xpY2UgZnJvbSBcIi4vcmVkdWNlcnMvTGF5b3V0U2xpY2VcIjtcbmltcG9ydCBTaG93TW9yZVBvc3RTbGljZSBmcm9tIFwiLi9yZWR1Y2Vycy9TaG93TW9yZVBvc3RTbGljZVwiO1xuXG5leHBvcnQgY29uc3Qgc3RvcmUgPSBjb25maWd1cmVTdG9yZSh7XG4gIHJlZHVjZXI6IHtcbiAgICBzdG9yaWVzTW9kYWxTbGljZSxcbiAgICBmYXZvdXJpdGVQYWdlU2xpY2UsXG4gICAgTGF5b3V0U2xpY2UsXG4gICAgU2hvd01vcmVQb3N0U2xpY2VcbiAgfSxcbiAgZGV2VG9vbHM6IHRydWUsXG59KTtcblxuc2V0dXBMaXN0ZW5lcnMoc3RvcmUuZGlzcGF0Y2gpO1xuZXhwb3J0IHR5cGUgUm9vdFN0YXRlID0gUmV0dXJuVHlwZTx0eXBlb2Ygc3RvcmUuZ2V0U3RhdGU+O1xuZXhwb3J0IHR5cGUgQXBwRGlzcGF0Y2ggPSB0eXBlb2Ygc3RvcmUuZGlzcGF0Y2g7XG4iXSwibmFtZXMiOlsiY29uZmlndXJlU3RvcmUiLCJzZXR1cExpc3RlbmVycyIsInN0b3JpZXNNb2RhbFNsaWNlIiwiZmF2b3VyaXRlUGFnZVNsaWNlIiwiTGF5b3V0U2xpY2UiLCJTaG93TW9yZVBvc3RTbGljZSIsInN0b3JlIiwicmVkdWNlciIsImRldlRvb2xzIiwiZGlzcGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/redux-toolkit/store.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(obj, key, value) {\n    key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUNoQyxTQUFTQyxnQkFBZ0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3JERCxNQUFNSCw2REFBYUEsQ0FBQ0c7SUFDcEIsSUFBSUEsT0FBT0QsS0FBSztRQUNkRyxPQUFPQyxjQUFjLENBQUNKLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BHLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xQLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/NDJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0iXSwibmFtZXMiOlsidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _extends; }\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQTtJQUN0QkEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQ3pCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz84ZWMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectSpread2; }\n/* harmony export */ });\n/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEO0FBQ2pELFNBQVNDLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNKO0lBQ3BCLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQ2hDLElBQUlDLElBQUlILE9BQU9FLHFCQUFxQixDQUFDTDtRQUNyQ0MsS0FBTUssQ0FBQUEsSUFBSUEsRUFBRUMsTUFBTSxDQUFDLFNBQVVOLENBQUM7WUFDNUIsT0FBT0UsT0FBT0ssd0JBQXdCLENBQUNSLEdBQUdDLEdBQUdRLFVBQVU7UUFDekQsRUFBQyxHQUFJUCxFQUFFUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsR0FBR0k7SUFDdkI7SUFDQSxPQUFPSjtBQUNUO0FBQ2UsU0FBU1UsZUFBZVosQ0FBQztJQUN0QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVksVUFBVUMsTUFBTSxFQUFFYixJQUFLO1FBQ3pDLElBQUlDLElBQUksUUFBUVcsU0FBUyxDQUFDWixFQUFFLEdBQUdZLFNBQVMsQ0FBQ1osRUFBRSxHQUFHLENBQUM7UUFDL0NBLElBQUksSUFBSUYsUUFBUUksT0FBT0QsSUFBSSxDQUFDLEdBQUdhLE9BQU8sQ0FBQyxTQUFVZCxDQUFDO1lBQ2hESCw4REFBY0EsQ0FBQ0UsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQzNCLEtBQUtFLE9BQU9hLHlCQUF5QixHQUFHYixPQUFPYyxnQkFBZ0IsQ0FBQ2pCLEdBQUdHLE9BQU9hLHlCQUF5QixDQUFDZCxNQUFNSCxRQUFRSSxPQUFPRCxJQUFJYSxPQUFPLENBQUMsU0FBVWQsQ0FBQztZQUM5SUUsT0FBT0wsY0FBYyxDQUFDRSxHQUFHQyxHQUFHRSxPQUFPSyx3QkFBd0IsQ0FBQ04sR0FBR0Q7UUFDakU7SUFDRjtJQUNBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZDIuanM/M2IxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSBcIi4vZGVmaW5lUHJvcGVydHkuanNcIjtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn0iXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydHkiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxTQUFTQSw4QkFBOEJDLE1BQU0sRUFBRUMsUUFBUTtJQUNwRSxJQUFJRCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQzVCLElBQUlFLFNBQVMsQ0FBQztJQUNkLElBQUlDLGFBQWFDLE9BQU9DLElBQUksQ0FBQ0w7SUFDN0IsSUFBSU0sS0FBS0M7SUFDVCxJQUFLQSxJQUFJLEdBQUdBLElBQUlKLFdBQVdLLE1BQU0sRUFBRUQsSUFBSztRQUN0Q0QsTUFBTUgsVUFBVSxDQUFDSSxFQUFFO1FBQ25CLElBQUlOLFNBQVNRLE9BQU8sQ0FBQ0gsUUFBUSxHQUFHO1FBQ2hDSixNQUFNLENBQUNJLElBQUksR0FBR04sTUFBTSxDQUFDTSxJQUFJO0lBQzNCO0lBQ0EsT0FBT0o7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9lOWE1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImkiLCJsZW5ndGgiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPrimitive; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction toPrimitive(t, r) {\n    if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUNuQixTQUFTQyxZQUFZQyxDQUFDLEVBQUVDLENBQUM7SUFDdEMsSUFBSSxZQUFZSCxzREFBT0EsQ0FBQ0UsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQ3pDLElBQUlFLElBQUlGLENBQUMsQ0FBQ0csT0FBT0osV0FBVyxDQUFDO0lBQzdCLElBQUksS0FBSyxNQUFNRyxHQUFHO1FBQ2hCLElBQUlFLElBQUlGLEVBQUVHLElBQUksQ0FBQ0wsR0FBR0MsS0FBSztRQUN2QixJQUFJLFlBQVlILHNEQUFPQSxDQUFDTSxJQUFJLE9BQU9BO1FBQ25DLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQyxhQUFhTCxJQUFJTSxTQUFTQyxNQUFLLEVBQUdSO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcz8zZTYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn0iXSwibmFtZXMiOlsiX3R5cGVvZiIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiU3ltYm9sIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ toPropertyKey; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction toPropertyKey(t) {\n    var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(t, \"string\");\n    return \"symbol\" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(i) ? i : String(i);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNTO0FBQzVCLFNBQVNFLGNBQWNDLENBQUM7SUFDckMsSUFBSUMsSUFBSUgsMkRBQVdBLENBQUNFLEdBQUc7SUFDdkIsT0FBTyxZQUFZSCxzREFBT0EsQ0FBQ0ksS0FBS0EsSUFBSUMsT0FBT0Q7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJvcGVydHlLZXkuanM/MWNiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmltcG9ydCB0b1ByaW1pdGl2ZSBmcm9tIFwiLi90b1ByaW1pdGl2ZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogU3RyaW5nKGkpO1xufSJdLCJuYW1lcyI6WyJfdHlwZW9mIiwidG9QcmltaXRpdmUiLCJ0b1Byb3BlcnR5S2V5IiwidCIsImkiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLFFBQVFDLENBQUM7SUFDL0I7SUFFQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQzlGLE9BQU8sT0FBT0E7SUFDaEIsSUFBSSxTQUFVQSxDQUFDO1FBQ2IsT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFDcEgsR0FBR0QsUUFBUUM7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzP2IwZmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn0iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/typeof.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs":
/*!***********************************************!*\
  !*** ./node_modules/immer/dist/immer.esm.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: function() { return /* binding */ un; },\n/* harmony export */   applyPatches: function() { return /* binding */ pn; },\n/* harmony export */   castDraft: function() { return /* binding */ K; },\n/* harmony export */   castImmutable: function() { return /* binding */ $; },\n/* harmony export */   createDraft: function() { return /* binding */ ln; },\n/* harmony export */   current: function() { return /* binding */ R; },\n/* harmony export */   enableAllPlugins: function() { return /* binding */ J; },\n/* harmony export */   enableES5: function() { return /* binding */ F; },\n/* harmony export */   enableMapSet: function() { return /* binding */ C; },\n/* harmony export */   enablePatches: function() { return /* binding */ T; },\n/* harmony export */   finishDraft: function() { return /* binding */ dn; },\n/* harmony export */   freeze: function() { return /* binding */ d; },\n/* harmony export */   immerable: function() { return /* binding */ L; },\n/* harmony export */   isDraft: function() { return /* binding */ r; },\n/* harmony export */   isDraftable: function() { return /* binding */ t; },\n/* harmony export */   nothing: function() { return /* binding */ H; },\n/* harmony export */   original: function() { return /* binding */ e; },\n/* harmony export */   produce: function() { return /* binding */ fn; },\n/* harmony export */   produceWithPatches: function() { return /* binding */ cn; },\n/* harmony export */   setAutoFreeze: function() { return /* binding */ sn; },\n/* harmony export */   setUseProxies: function() { return /* binding */ vn; }\n/* harmony export */ });\nfunction n(n) {\n    for(var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++)t[e - 1] = arguments[e];\n    if (true) {\n        var i = Y[n], o = i ? \"function\" == typeof i ? i.apply(null, t) : i : \"unknown error nr: \" + n;\n        throw Error(\"[Immer] \" + o);\n    }\n    throw Error(\"[Immer] minified error nr: \" + n + (t.length ? \" \" + t.map(function(n) {\n        return \"'\" + n + \"'\";\n    }).join(\",\") : \"\") + \". Find the full error at: https://bit.ly/3cXEKWf\");\n}\nfunction r(n) {\n    return !!n && !!n[Q];\n}\nfunction t(n) {\n    var r;\n    return !!n && (function(n) {\n        if (!n || \"object\" != typeof n) return !1;\n        var r = Object.getPrototypeOf(n);\n        if (null === r) return !0;\n        var t = Object.hasOwnProperty.call(r, \"constructor\") && r.constructor;\n        return t === Object || \"function\" == typeof t && Function.toString.call(t) === Z;\n    }(n) || Array.isArray(n) || !!n[L] || !!(null === (r = n.constructor) || void 0 === r ? void 0 : r[L]) || s(n) || v(n));\n}\nfunction e(t) {\n    return r(t) || n(23, t), t[Q].t;\n}\nfunction i(n, r, t) {\n    void 0 === t && (t = !1), 0 === o(n) ? (t ? Object.keys : nn)(n).forEach(function(e) {\n        t && \"symbol\" == typeof e || r(e, n[e], n);\n    }) : n.forEach(function(t, e) {\n        return r(e, t, n);\n    });\n}\nfunction o(n) {\n    var r = n[Q];\n    return r ? r.i > 3 ? r.i - 4 : r.i : Array.isArray(n) ? 1 : s(n) ? 2 : v(n) ? 3 : 0;\n}\nfunction u(n, r) {\n    return 2 === o(n) ? n.has(r) : Object.prototype.hasOwnProperty.call(n, r);\n}\nfunction a(n, r) {\n    return 2 === o(n) ? n.get(r) : n[r];\n}\nfunction f(n, r, t) {\n    var e = o(n);\n    2 === e ? n.set(r, t) : 3 === e ? n.add(t) : n[r] = t;\n}\nfunction c(n, r) {\n    return n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r;\n}\nfunction s(n) {\n    return X && n instanceof Map;\n}\nfunction v(n) {\n    return q && n instanceof Set;\n}\nfunction p(n) {\n    return n.o || n.t;\n}\nfunction l(n) {\n    if (Array.isArray(n)) return Array.prototype.slice.call(n);\n    var r = rn(n);\n    delete r[Q];\n    for(var t = nn(r), e = 0; e < t.length; e++){\n        var i = t[e], o = r[i];\n        !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[i] = {\n            configurable: !0,\n            writable: !0,\n            enumerable: o.enumerable,\n            value: n[i]\n        });\n    }\n    return Object.create(Object.getPrototypeOf(n), r);\n}\nfunction d(n, e) {\n    return void 0 === e && (e = !1), y(n) || r(n) || !t(n) || (o(n) > 1 && (n.set = n.add = n.clear = n.delete = h), Object.freeze(n), e && i(n, function(n, r) {\n        return d(r, !0);\n    }, !0)), n;\n}\nfunction h() {\n    n(2);\n}\nfunction y(n) {\n    return null == n || \"object\" != typeof n || Object.isFrozen(n);\n}\nfunction b(r) {\n    var t = tn[r];\n    return t || n(18, r), t;\n}\nfunction m(n, r) {\n    tn[n] || (tn[n] = r);\n}\nfunction _() {\n    return  false || U || n(0), U;\n}\nfunction j(n, r) {\n    r && (b(\"Patches\"), n.u = [], n.s = [], n.v = r);\n}\nfunction g(n) {\n    O(n), n.p.forEach(S), n.p = null;\n}\nfunction O(n) {\n    n === U && (U = n.l);\n}\n_c = O;\nfunction w(n) {\n    return U = {\n        p: [],\n        l: U,\n        h: n,\n        m: !0,\n        _: 0\n    };\n}\nfunction S(n) {\n    var r = n[Q];\n    0 === r.i || 1 === r.i ? r.j() : r.g = !0;\n}\n_c1 = S;\nfunction P(r, e) {\n    e._ = e.p.length;\n    var i = e.p[0], o = void 0 !== r && r !== i;\n    return e.h.O || b(\"ES5\").S(e, r, o), o ? (i[Q].P && (g(e), n(4)), t(r) && (r = M(e, r), e.l || x(e, r)), e.u && b(\"Patches\").M(i[Q].t, r, e.u, e.s)) : r = M(e, i, []), g(e), e.u && e.v(e.u, e.s), r !== H ? r : void 0;\n}\n_c2 = P;\nfunction M(n, r, t) {\n    if (y(r)) return r;\n    var e = r[Q];\n    if (!e) return i(r, function(i, o) {\n        return A(n, e, r, i, o, t);\n    }, !0), r;\n    if (e.A !== n) return r;\n    if (!e.P) return x(n, e.t, !0), e.t;\n    if (!e.I) {\n        e.I = !0, e.A._--;\n        var o = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u = o, a = !1;\n        3 === e.i && (u = new Set(o), o.clear(), a = !0), i(u, function(r, i) {\n            return A(n, e, o, r, i, t, a);\n        }), x(n, o, !1), t && n.u && b(\"Patches\").N(e, t, n.u, n.s);\n    }\n    return e.o;\n}\n_c3 = M;\nfunction A(e, i, o, a, c, s, v) {\n    if ( true && c === o && n(5), r(c)) {\n        var p = M(e, c, s && i && 3 !== i.i && !u(i.R, a) ? s.concat(a) : void 0);\n        if (f(o, a, p), !r(p)) return;\n        e.m = !1;\n    } else v && o.add(c);\n    if (t(c) && !y(c)) {\n        if (!e.h.D && e._ < 1) return;\n        M(e, c), i && i.A.l || x(e, c);\n    }\n}\n_c4 = A;\nfunction x(n, r, t) {\n    void 0 === t && (t = !1), !n.l && n.h.D && n.m && d(r, t);\n}\nfunction z(n, r) {\n    var t = n[Q];\n    return (t ? p(t) : n)[r];\n}\nfunction I(n, r) {\n    if (r in n) for(var t = Object.getPrototypeOf(n); t;){\n        var e = Object.getOwnPropertyDescriptor(t, r);\n        if (e) return e;\n        t = Object.getPrototypeOf(t);\n    }\n}\n_c5 = I;\nfunction k(n) {\n    n.P || (n.P = !0, n.l && k(n.l));\n}\nfunction E(n) {\n    n.o || (n.o = l(n.t));\n}\n_c6 = E;\nfunction N(n, r, t) {\n    var e = s(r) ? b(\"MapSet\").F(r, t) : v(r) ? b(\"MapSet\").T(r, t) : n.O ? function(n, r) {\n        var t = Array.isArray(n), e = {\n            i: t ? 1 : 0,\n            A: r ? r.A : _(),\n            P: !1,\n            I: !1,\n            R: {},\n            l: r,\n            t: n,\n            k: null,\n            o: null,\n            j: null,\n            C: !1\n        }, i = e, o = en;\n        t && (i = [\n            e\n        ], o = on);\n        var u = Proxy.revocable(i, o), a = u.revoke, f = u.proxy;\n        return e.k = f, e.j = a, f;\n    }(r, t) : b(\"ES5\").J(r, t);\n    return (t ? t.A : _()).p.push(e), e;\n}\n_c7 = N;\nfunction R(e) {\n    return r(e) || n(22, e), function n(r) {\n        if (!t(r)) return r;\n        var e, u = r[Q], c = o(r);\n        if (u) {\n            if (!u.P && (u.i < 4 || !b(\"ES5\").K(u))) return u.t;\n            u.I = !0, e = D(r, c), u.I = !1;\n        } else e = D(r, c);\n        return i(e, function(r, t) {\n            u && a(u.t, r) === t || f(e, r, n(t));\n        }), 3 === c ? new Set(e) : e;\n    }(e);\n}\n_c8 = R;\nfunction D(n, r) {\n    switch(r){\n        case 2:\n            return new Map(n);\n        case 3:\n            return Array.from(n);\n    }\n    return l(n);\n}\n_c9 = D;\nfunction F() {\n    function t(n, r) {\n        var t = s[n];\n        return t ? t.enumerable = r : s[n] = t = {\n            configurable: !0,\n            enumerable: r,\n            get: function() {\n                var r = this[Q];\n                return  true && f(r), en.get(r, n);\n            },\n            set: function(r) {\n                var t = this[Q];\n                 true && f(t), en.set(t, n, r);\n            }\n        }, t;\n    }\n    function e(n) {\n        for(var r = n.length - 1; r >= 0; r--){\n            var t = n[r][Q];\n            if (!t.P) switch(t.i){\n                case 5:\n                    a(t) && k(t);\n                    break;\n                case 4:\n                    o(t) && k(t);\n            }\n        }\n    }\n    function o(n) {\n        for(var r = n.t, t = n.k, e = nn(t), i = e.length - 1; i >= 0; i--){\n            var o = e[i];\n            if (o !== Q) {\n                var a = r[o];\n                if (void 0 === a && !u(r, o)) return !0;\n                var f = t[o], s = f && f[Q];\n                if (s ? s.t !== a : !c(f, a)) return !0;\n            }\n        }\n        var v = !!r[Q];\n        return e.length !== nn(r).length + (v ? 0 : 1);\n    }\n    function a(n) {\n        var r = n.k;\n        if (r.length !== n.t.length) return !0;\n        var t = Object.getOwnPropertyDescriptor(r, r.length - 1);\n        if (t && !t.get) return !0;\n        for(var e = 0; e < r.length; e++)if (!r.hasOwnProperty(e)) return !0;\n        return !1;\n    }\n    function f(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var s = {};\n    m(\"ES5\", {\n        J: function(n, r) {\n            var e = Array.isArray(n), i = function(n, r) {\n                if (n) {\n                    for(var e = Array(r.length), i = 0; i < r.length; i++)Object.defineProperty(e, \"\" + i, t(i, !0));\n                    return e;\n                }\n                var o = rn(r);\n                delete o[Q];\n                for(var u = nn(o), a = 0; a < u.length; a++){\n                    var f = u[a];\n                    o[f] = t(f, n || !!o[f].enumerable);\n                }\n                return Object.create(Object.getPrototypeOf(r), o);\n            }(e, n), o = {\n                i: e ? 5 : 4,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                R: {},\n                l: r,\n                t: n,\n                k: i,\n                o: null,\n                g: !1,\n                C: !1\n            };\n            return Object.defineProperty(i, Q, {\n                value: o,\n                writable: !0\n            }), i;\n        },\n        S: function(n, t, o) {\n            o ? r(t) && t[Q].A === n && e(n.p) : (n.u && function n(r) {\n                if (r && \"object\" == typeof r) {\n                    var t = r[Q];\n                    if (t) {\n                        var e = t.t, o = t.k, f = t.R, c = t.i;\n                        if (4 === c) i(o, function(r) {\n                            r !== Q && (void 0 !== e[r] || u(e, r) ? f[r] || n(o[r]) : (f[r] = !0, k(t)));\n                        }), i(e, function(n) {\n                            void 0 !== o[n] || u(o, n) || (f[n] = !1, k(t));\n                        });\n                        else if (5 === c) {\n                            if (a(t) && (k(t), f.length = !0), o.length < e.length) for(var s = o.length; s < e.length; s++)f[s] = !1;\n                            else for(var v = e.length; v < o.length; v++)f[v] = !0;\n                            for(var p = Math.min(o.length, e.length), l = 0; l < p; l++)o.hasOwnProperty(l) || (f[l] = !0), void 0 === f[l] && n(o[l]);\n                        }\n                    }\n                }\n            }(n.p[0]), e(n.p));\n        },\n        K: function(n) {\n            return 4 === n.i ? o(n) : a(n);\n        }\n    });\n}\n_c10 = F;\nfunction T() {\n    function e(n) {\n        if (!t(n)) return n;\n        if (Array.isArray(n)) return n.map(e);\n        if (s(n)) return new Map(Array.from(n.entries()).map(function(n) {\n            return [\n                n[0],\n                e(n[1])\n            ];\n        }));\n        if (v(n)) return new Set(Array.from(n).map(e));\n        var r = Object.create(Object.getPrototypeOf(n));\n        for(var i in n)r[i] = e(n[i]);\n        return u(n, L) && (r[L] = n[L]), r;\n    }\n    function f(n) {\n        return r(n) ? e(n) : n;\n    }\n    var c = \"add\";\n    m(\"Patches\", {\n        $: function(r, t) {\n            return t.forEach(function(t) {\n                for(var i = t.path, u = t.op, f = r, s = 0; s < i.length - 1; s++){\n                    var v = o(f), p = i[s];\n                    \"string\" != typeof p && \"number\" != typeof p && (p = \"\" + p), 0 !== v && 1 !== v || \"__proto__\" !== p && \"constructor\" !== p || n(24), \"function\" == typeof f && \"prototype\" === p && n(24), \"object\" != typeof (f = a(f, p)) && n(15, i.join(\"/\"));\n                }\n                var l = o(f), d = e(t.value), h = i[i.length - 1];\n                switch(u){\n                    case \"replace\":\n                        switch(l){\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                n(16);\n                            default:\n                                return f[h] = d;\n                        }\n                    case c:\n                        switch(l){\n                            case 1:\n                                return \"-\" === h ? f.push(d) : f.splice(h, 0, d);\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                return f.add(d);\n                            default:\n                                return f[h] = d;\n                        }\n                    case \"remove\":\n                        switch(l){\n                            case 1:\n                                return f.splice(h, 1);\n                            case 2:\n                                return f.delete(h);\n                            case 3:\n                                return f.delete(t.value);\n                            default:\n                                return delete f[h];\n                        }\n                    default:\n                        n(17, u);\n                }\n            }), r;\n        },\n        N: function(n, r, t, e) {\n            switch(n.i){\n                case 0:\n                case 4:\n                case 2:\n                    return function(n, r, t, e) {\n                        var o = n.t, s = n.o;\n                        i(n.R, function(n, i) {\n                            var v = a(o, n), p = a(s, n), l = i ? u(o, n) ? \"replace\" : c : \"remove\";\n                            if (v !== p || \"replace\" !== l) {\n                                var d = r.concat(n);\n                                t.push(\"remove\" === l ? {\n                                    op: l,\n                                    path: d\n                                } : {\n                                    op: l,\n                                    path: d,\n                                    value: p\n                                }), e.push(l === c ? {\n                                    op: \"remove\",\n                                    path: d\n                                } : \"remove\" === l ? {\n                                    op: c,\n                                    path: d,\n                                    value: f(v)\n                                } : {\n                                    op: \"replace\",\n                                    path: d,\n                                    value: f(v)\n                                });\n                            }\n                        });\n                    }(n, r, t, e);\n                case 5:\n                case 1:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.R, u = n.o;\n                        if (u.length < i.length) {\n                            var a = [\n                                u,\n                                i\n                            ];\n                            i = a[0], u = a[1];\n                            var s = [\n                                e,\n                                t\n                            ];\n                            t = s[0], e = s[1];\n                        }\n                        for(var v = 0; v < i.length; v++)if (o[v] && u[v] !== i[v]) {\n                            var p = r.concat([\n                                v\n                            ]);\n                            t.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(u[v])\n                            }), e.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(i[v])\n                            });\n                        }\n                        for(var l = i.length; l < u.length; l++){\n                            var d = r.concat([\n                                l\n                            ]);\n                            t.push({\n                                op: c,\n                                path: d,\n                                value: f(u[l])\n                            });\n                        }\n                        i.length < u.length && e.push({\n                            op: \"replace\",\n                            path: r.concat([\n                                \"length\"\n                            ]),\n                            value: i.length\n                        });\n                    }(n, r, t, e);\n                case 3:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.o, u = 0;\n                        i.forEach(function(n) {\n                            if (!o.has(n)) {\n                                var i = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: \"remove\",\n                                    path: i,\n                                    value: n\n                                }), e.unshift({\n                                    op: c,\n                                    path: i,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        }), u = 0, o.forEach(function(n) {\n                            if (!i.has(n)) {\n                                var o = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: c,\n                                    path: o,\n                                    value: n\n                                }), e.unshift({\n                                    op: \"remove\",\n                                    path: o,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        });\n                    }(n, r, t, e);\n            }\n        },\n        M: function(n, r, t, e) {\n            t.push({\n                op: \"replace\",\n                path: [],\n                value: r === H ? void 0 : r\n            }), e.push({\n                op: \"replace\",\n                path: [],\n                value: n\n            });\n        }\n    });\n}\n_c11 = T;\nfunction C() {\n    function r(n, r) {\n        function t() {\n            this.constructor = n;\n        }\n        a(n, r), n.prototype = (t.prototype = r.prototype, new t);\n    }\n    function e(n) {\n        n.o || (n.R = new Map, n.o = new Map(n.t));\n    }\n    function o(n) {\n        n.o || (n.o = new Set, n.t.forEach(function(r) {\n            if (t(r)) {\n                var e = N(n.A.h, r, n);\n                n.p.set(r, e), n.o.add(e);\n            } else n.o.add(r);\n        }));\n    }\n    function u(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var a = function(n, r) {\n        return (a = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(n, r) {\n            n.__proto__ = r;\n        } || function(n, r) {\n            for(var t in r)r.hasOwnProperty(t) && (n[t] = r[t]);\n        })(n, r);\n    }, f = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 2,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                R: void 0,\n                t: n,\n                k: this,\n                C: !1,\n                g: !1\n            }, this;\n        }\n        r(n, Map);\n        var o = n.prototype;\n        return Object.defineProperty(o, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), o.has = function(n) {\n            return p(this[Q]).has(n);\n        }, o.set = function(n, r) {\n            var t = this[Q];\n            return u(t), p(t).has(n) && p(t).get(n) === r || (e(t), k(t), t.R.set(n, !0), t.o.set(n, r), t.R.set(n, !0)), this;\n        }, o.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), e(r), k(r), r.t.has(n) ? r.R.set(n, !1) : r.R.delete(n), r.o.delete(n), !0;\n        }, o.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (e(n), k(n), n.R = new Map, i(n.t, function(r) {\n                n.R.set(r, !1);\n            }), n.o.clear());\n        }, o.forEach = function(n, r) {\n            var t = this;\n            p(this[Q]).forEach(function(e, i) {\n                n.call(r, t.get(i), i, t);\n            });\n        }, o.get = function(n) {\n            var r = this[Q];\n            u(r);\n            var i = p(r).get(n);\n            if (r.I || !t(i)) return i;\n            if (i !== r.t.get(n)) return i;\n            var o = N(r.A.h, i, r);\n            return e(r), r.o.set(n, o), o;\n        }, o.keys = function() {\n            return p(this[Q]).keys();\n        }, o.values = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.values();\n            }, n.next = function() {\n                var n = t.next();\n                return n.done ? n : {\n                    done: !1,\n                    value: r.get(n.value)\n                };\n            }, n;\n        }, o.entries = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.entries();\n            }, n.next = function() {\n                var n = t.next();\n                if (n.done) return n;\n                var e = r.get(n.value);\n                return {\n                    done: !1,\n                    value: [\n                        n.value,\n                        e\n                    ]\n                };\n            }, n;\n        }, o[V] = function() {\n            return this.entries();\n        }, n;\n    }(), c = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 3,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                t: n,\n                k: this,\n                p: new Map,\n                g: !1,\n                C: !1\n            }, this;\n        }\n        r(n, Set);\n        var t = n.prototype;\n        return Object.defineProperty(t, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), t.has = function(n) {\n            var r = this[Q];\n            return u(r), r.o ? !!r.o.has(n) || !(!r.p.has(n) || !r.o.has(r.p.get(n))) : r.t.has(n);\n        }, t.add = function(n) {\n            var r = this[Q];\n            return u(r), this.has(n) || (o(r), k(r), r.o.add(n)), this;\n        }, t.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), o(r), k(r), r.o.delete(n) || !!r.p.has(n) && r.o.delete(r.p.get(n));\n        }, t.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (o(n), k(n), n.o.clear());\n        }, t.values = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.values();\n        }, t.entries = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.entries();\n        }, t.keys = function() {\n            return this.values();\n        }, t[V] = function() {\n            return this.values();\n        }, t.forEach = function(n, r) {\n            for(var t = this.values(), e = t.next(); !e.done;)n.call(r, e.value, e.value, this), e = t.next();\n        }, n;\n    }();\n    m(\"MapSet\", {\n        F: function(n, r) {\n            return new f(n, r);\n        },\n        T: function(n, r) {\n            return new c(n, r);\n        }\n    });\n}\n_c12 = C;\nfunction J() {\n    F(), C(), T();\n}\n_c13 = J;\nfunction K(n) {\n    return n;\n}\n_c14 = K;\nfunction $(n) {\n    return n;\n}\nvar G, U, W = \"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol(\"x\"), X = \"undefined\" != typeof Map, q = \"undefined\" != typeof Set, B = \"undefined\" != typeof Proxy && void 0 !== Proxy.revocable && \"undefined\" != typeof Reflect, H = W ? Symbol.for(\"immer-nothing\") : ((G = {})[\"immer-nothing\"] = !0, G), L = W ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\", Q = W ? Symbol.for(\"immer-state\") : \"__$immer_state\", V = \"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\", Y = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function(n) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + n;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function(n) {\n        return \"Cannot apply patch, path doesn't resolve: \" + n;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function(n) {\n        return \"Unsupported patch operation: \" + n;\n    },\n    18: function(n) {\n        return \"The plugin for '\" + n + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + n + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function(n) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + n + \"'\";\n    },\n    22: function(n) {\n        return \"'current' expects a draft, got: \" + n;\n    },\n    23: function(n) {\n        return \"'original' expects a draft, got: \" + n;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n}, Z = \"\" + Object.prototype.constructor, nn = \"undefined\" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n) {\n    return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));\n} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n) {\n    var r = {};\n    return nn(n).forEach(function(t) {\n        r[t] = Object.getOwnPropertyDescriptor(n, t);\n    }), r;\n}, tn = {}, en = {\n    get: function(n, r) {\n        if (r === Q) return n;\n        var e = p(n);\n        if (!u(e, r)) return function(n, r, t) {\n            var e, i = I(r, t);\n            return i ? \"value\" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;\n        }(n, e, r);\n        var i = e[r];\n        return n.I || !t(i) ? i : i === z(n.t, r) ? (E(n), n.o[r] = N(n.A.h, i, n)) : i;\n    },\n    has: function(n, r) {\n        return r in p(n);\n    },\n    ownKeys: function(n) {\n        return Reflect.ownKeys(p(n));\n    },\n    set: function(n, r, t) {\n        var e = I(p(n), r);\n        if (null == e ? void 0 : e.set) return e.set.call(n.k, t), !0;\n        if (!n.P) {\n            var i = z(p(n), r), o = null == i ? void 0 : i[Q];\n            if (o && o.t === t) return n.o[r] = t, n.R[r] = !1, !0;\n            if (c(t, i) && (void 0 !== t || u(n.t, r))) return !0;\n            E(n), k(n);\n        }\n        return n.o[r] === t && (void 0 !== t || r in n.o) || Number.isNaN(t) && Number.isNaN(n.o[r]) || (n.o[r] = t, n.R[r] = !0), !0;\n    },\n    deleteProperty: function(n, r) {\n        return void 0 !== z(n.t, r) || r in n.t ? (n.R[r] = !1, E(n), k(n)) : delete n.R[r], n.o && delete n.o[r], !0;\n    },\n    getOwnPropertyDescriptor: function(n, r) {\n        var t = p(n), e = Reflect.getOwnPropertyDescriptor(t, r);\n        return e ? {\n            writable: !0,\n            configurable: 1 !== n.i || \"length\" !== r,\n            enumerable: e.enumerable,\n            value: t[r]\n        } : e;\n    },\n    defineProperty: function() {\n        n(11);\n    },\n    getPrototypeOf: function(n) {\n        return Object.getPrototypeOf(n.t);\n    },\n    setPrototypeOf: function() {\n        n(12);\n    }\n}, on = {};\ni(en, function(n, r) {\n    on[n] = function() {\n        return arguments[0] = arguments[0][0], r.apply(this, arguments);\n    };\n}), on.deleteProperty = function(r, t) {\n    return  true && isNaN(parseInt(t)) && n(13), on.set.call(this, r, t, void 0);\n}, on.set = function(r, t, e) {\n    return  true && \"length\" !== t && isNaN(parseInt(t)) && n(14), en.set.call(this, r[0], t, e, r[0]);\n};\nvar un = function() {\n    function e(r) {\n        var e = this;\n        this.O = B, this.D = !0, this.produce = function(r, i, o) {\n            if (\"function\" == typeof r && \"function\" != typeof i) {\n                var u = i;\n                i = r;\n                var a = e;\n                return function(n) {\n                    var r = this;\n                    void 0 === n && (n = u);\n                    for(var t = arguments.length, e = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)e[o - 1] = arguments[o];\n                    return a.produce(n, function(n) {\n                        var t;\n                        return (t = i).call.apply(t, [\n                            r,\n                            n\n                        ].concat(e));\n                    });\n                };\n            }\n            var f;\n            if (\"function\" != typeof i && n(6), void 0 !== o && \"function\" != typeof o && n(7), t(r)) {\n                var c = w(e), s = N(e, r, void 0), v = !0;\n                try {\n                    f = i(s), v = !1;\n                } finally{\n                    v ? g(c) : O(c);\n                }\n                return \"undefined\" != typeof Promise && f instanceof Promise ? f.then(function(n) {\n                    return j(c, o), P(n, c);\n                }, function(n) {\n                    throw g(c), n;\n                }) : (j(c, o), P(f, c));\n            }\n            if (!r || \"object\" != typeof r) {\n                if (void 0 === (f = i(r)) && (f = r), f === H && (f = void 0), e.D && d(f, !0), o) {\n                    var p = [], l = [];\n                    b(\"Patches\").M(r, f, p, l), o(p, l);\n                }\n                return f;\n            }\n            n(21, r);\n        }, this.produceWithPatches = function(n, r) {\n            if (\"function\" == typeof n) return function(r) {\n                for(var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)i[o - 1] = arguments[o];\n                return e.produceWithPatches(r, function(r) {\n                    return n.apply(void 0, [\n                        r\n                    ].concat(i));\n                });\n            };\n            var t, i, o = e.produce(n, r, function(n, r) {\n                t = n, i = r;\n            });\n            return \"undefined\" != typeof Promise && o instanceof Promise ? o.then(function(n) {\n                return [\n                    n,\n                    t,\n                    i\n                ];\n            }) : [\n                o,\n                t,\n                i\n            ];\n        }, \"boolean\" == typeof (null == r ? void 0 : r.useProxies) && this.setUseProxies(r.useProxies), \"boolean\" == typeof (null == r ? void 0 : r.autoFreeze) && this.setAutoFreeze(r.autoFreeze);\n    }\n    var i = e.prototype;\n    return i.createDraft = function(e) {\n        t(e) || n(8), r(e) && (e = R(e));\n        var i = w(this), o = N(this, e, void 0);\n        return o[Q].C = !0, O(i), o;\n    }, i.finishDraft = function(r, t) {\n        var e = r && r[Q];\n         true && (e && e.C || n(9), e.I && n(10));\n        var i = e.A;\n        return j(i, t), P(void 0, i);\n    }, i.setAutoFreeze = function(n) {\n        this.D = n;\n    }, i.setUseProxies = function(r) {\n        r && !B && n(20), this.O = r;\n    }, i.applyPatches = function(n, t) {\n        var e;\n        for(e = t.length - 1; e >= 0; e--){\n            var i = t[e];\n            if (0 === i.path.length && \"replace\" === i.op) {\n                n = i.value;\n                break;\n            }\n        }\n        e > -1 && (t = t.slice(e + 1));\n        var o = b(\"Patches\").$;\n        return r(n) ? o(n, t) : this.produce(n, function(n) {\n            return o(n, t);\n        });\n    }, e;\n}(), an = new un, fn = an.produce, cn = an.produceWithPatches.bind(an), sn = an.setAutoFreeze.bind(an), vn = an.setUseProxies.bind(an), pn = an.applyPatches.bind(an), ln = an.createDraft.bind(an), dn = an.finishDraft.bind(an);\n/* harmony default export */ __webpack_exports__[\"default\"] = (fn);\n //# sourceMappingURL=immer.esm.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14;\n$RefreshReg$(_c, \"O\");\n$RefreshReg$(_c1, \"S\");\n$RefreshReg$(_c2, \"P\");\n$RefreshReg$(_c3, \"M\");\n$RefreshReg$(_c4, \"A\");\n$RefreshReg$(_c5, \"I\");\n$RefreshReg$(_c6, \"E\");\n$RefreshReg$(_c7, \"N\");\n$RefreshReg$(_c8, \"R\");\n$RefreshReg$(_c9, \"D\");\n$RefreshReg$(_c10, \"F\");\n$RefreshReg$(_c11, \"T\");\n$RefreshReg$(_c12, \"C\");\n$RefreshReg$(_c13, \"J\");\n$RefreshReg$(_c14, \"K\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsRUFBRUEsQ0FBQztJQUFFLElBQUksSUFBSUMsSUFBRUMsVUFBVUMsTUFBTSxFQUFDQyxJQUFFQyxNQUFNSixJQUFFLElBQUVBLElBQUUsSUFBRSxJQUFHSyxJQUFFLEdBQUVBLElBQUVMLEdBQUVLLElBQUlGLENBQUMsQ0FBQ0UsSUFBRSxFQUFFLEdBQUNKLFNBQVMsQ0FBQ0ksRUFBRTtJQUFDLElBQUcsSUFBL0YsRUFBbUk7UUFBQyxJQUFJQyxJQUFFQyxDQUFDLENBQUNSLEVBQUUsRUFBQ1MsSUFBRUYsSUFBRSxjQUFZLE9BQU9BLElBQUVBLEVBQUVHLEtBQUssQ0FBQyxNQUFLTixLQUFHRyxJQUFFLHVCQUFxQlA7UUFBRSxNQUFNVyxNQUFNLGFBQVdGO0lBQUU7SUFBQyxNQUFNRSxNQUFNLGdDQUE4QlgsSUFBR0ksQ0FBQUEsRUFBRUQsTUFBTSxHQUFDLE1BQUlDLEVBQUVRLEdBQUcsQ0FBRSxTQUFTWixDQUFDO1FBQUUsT0FBTSxNQUFJQSxJQUFFO0lBQUcsR0FBSWEsSUFBSSxDQUFDLE9BQUssRUFBQyxJQUFHO0FBQW1EO0FBQUMsU0FBU1osRUFBRUQsQ0FBQztJQUFFLE9BQU0sQ0FBQyxDQUFDQSxLQUFHLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDYyxFQUFFO0FBQUE7QUFBQyxTQUFTVixFQUFFSixDQUFDO0lBQUUsSUFBSUM7SUFBRSxPQUFNLENBQUMsQ0FBQ0QsS0FBSSxVQUFTQSxDQUFDO1FBQUUsSUFBRyxDQUFDQSxLQUFHLFlBQVUsT0FBT0EsR0FBRSxPQUFNLENBQUM7UUFBRSxJQUFJQyxJQUFFYyxPQUFPQyxjQUFjLENBQUNoQjtRQUFHLElBQUcsU0FBT0MsR0FBRSxPQUFNLENBQUM7UUFBRSxJQUFJRyxJQUFFVyxPQUFPRSxjQUFjLENBQUNDLElBQUksQ0FB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a0QsRUFBRSxXQUFXMkMsQ0FBQztRQUFDLE9BQU9yRyxFQUFFRCxLQUFHUyxFQUFFVCxHQUFFSSxLQUFHLElBQUksQ0FBQzhILE9BQU8sQ0FBQ2xJLEdBQUcsU0FBU0EsQ0FBQztZQUFFLE9BQU9TLEVBQUVULEdBQUVJO1FBQUU7SUFBRyxHQUFFRTtBQUFDLEtBQUl1SSxLQUFHLElBQUlaLElBQUdhLEtBQUdELEdBQUdYLE9BQU8sRUFBQ2EsS0FBR0YsR0FBR1Isa0JBQWtCLENBQUNXLElBQUksQ0FBQ0gsS0FBSUksS0FBR0osR0FBR0osYUFBYSxDQUFDTyxJQUFJLENBQUNILEtBQUlLLEtBQUdMLEdBQUdOLGFBQWEsQ0FBQ1MsSUFBSSxDQUFDSCxLQUFJTSxLQUFHTixHQUFHRCxZQUFZLENBQUNJLElBQUksQ0FBQ0gsS0FBSU8sS0FBR1AsR0FBR0gsV0FBVyxDQUFDTSxJQUFJLENBQUNILEtBQUlRLEtBQUdSLEdBQUdGLFdBQVcsQ0FBQ0ssSUFBSSxDQUFDSDtBQUFJLCtEQUFlQyxFQUFFQSxFQUFDO0FBQXVXLENBQ2o5akIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanM/MTBiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBuKG4pe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkocj4xP3ItMTowKSxlPTE7ZTxyO2UrKyl0W2UtMV09YXJndW1lbnRzW2VdO2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpe3ZhciBpPVlbbl0sbz1pP1wiZnVuY3Rpb25cIj09dHlwZW9mIGk/aS5hcHBseShudWxsLHQpOmk6XCJ1bmtub3duIGVycm9yIG5yOiBcIituO3Rocm93IEVycm9yKFwiW0ltbWVyXSBcIitvKX10aHJvdyBFcnJvcihcIltJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6IFwiK24rKHQubGVuZ3RoP1wiIFwiK3QubWFwKChmdW5jdGlvbihuKXtyZXR1cm5cIidcIituK1wiJ1wifSkpLmpvaW4oXCIsXCIpOlwiXCIpK1wiLiBGaW5kIHRoZSBmdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmXCIpfWZ1bmN0aW9uIHIobil7cmV0dXJuISFuJiYhIW5bUV19ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4hIW4mJihmdW5jdGlvbihuKXtpZighbnx8XCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuITE7dmFyIHI9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO2lmKG51bGw9PT1yKXJldHVybiEwO3ZhciB0PU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJjb25zdHJ1Y3RvclwiKSYmci5jb25zdHJ1Y3RvcjtyZXR1cm4gdD09PU9iamVjdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KT09PVp9KG4pfHxBcnJheS5pc0FycmF5KG4pfHwhIW5bTF18fCEhKG51bGw9PT0ocj1uLmNvbnN0cnVjdG9yKXx8dm9pZCAwPT09cj92b2lkIDA6cltMXSl8fHMobil8fHYobikpfWZ1bmN0aW9uIGUodCl7cmV0dXJuIHIodCl8fG4oMjMsdCksdFtRXS50fWZ1bmN0aW9uIGkobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSwwPT09byhuKT8odD9PYmplY3Qua2V5czpubikobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dCYmXCJzeW1ib2xcIj09dHlwZW9mIGV8fHIoZSxuW2VdLG4pfSkpOm4uZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcihlLHQsbil9KSl9ZnVuY3Rpb24gbyhuKXt2YXIgcj1uW1FdO3JldHVybiByP3IuaT4zP3IuaS00OnIuaTpBcnJheS5pc0FycmF5KG4pPzE6cyhuKT8yOnYobik/MzowfWZ1bmN0aW9uIHUobixyKXtyZXR1cm4gMj09PW8obik/bi5oYXMocik6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scil9ZnVuY3Rpb24gYShuLHIpe3JldHVybiAyPT09byhuKT9uLmdldChyKTpuW3JdfWZ1bmN0aW9uIGYobixyLHQpe3ZhciBlPW8obik7Mj09PWU/bi5zZXQocix0KTozPT09ZT9uLmFkZCh0KTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pfHwobyhuKT4xJiYobi5zZXQ9bi5hZGQ9bi5jbGVhcj1uLmRlbGV0ZT1oKSxPYmplY3QuZnJlZXplKG4pLGUmJmkobiwoZnVuY3Rpb24obixyKXtyZXR1cm4gZChyLCEwKX0pLCEwKSksbn1mdW5jdGlvbiBoKCl7bigyKX1mdW5jdGlvbiB5KG4pe3JldHVybiBudWxsPT1ufHxcIm9iamVjdFwiIT10eXBlb2Ygbnx8T2JqZWN0LmlzRnJvemVuKG4pfWZ1bmN0aW9uIGIocil7dmFyIHQ9dG5bcl07cmV0dXJuIHR8fG4oMTgsciksdH1mdW5jdGlvbiBtKG4scil7dG5bbl18fCh0bltuXT1yKX1mdW5jdGlvbiBfKCl7cmV0dXJuXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8VXx8bigwKSxVfWZ1bmN0aW9uIGoobixyKXtyJiYoYihcIlBhdGNoZXNcIiksbi51PVtdLG4ucz1bXSxuLnY9cil9ZnVuY3Rpb24gZyhuKXtPKG4pLG4ucC5mb3JFYWNoKFMpLG4ucD1udWxsfWZ1bmN0aW9uIE8obil7bj09PVUmJihVPW4ubCl9ZnVuY3Rpb24gdyhuKXtyZXR1cm4gVT17cDpbXSxsOlUsaDpuLG06ITAsXzowfX1mdW5jdGlvbiBTKG4pe3ZhciByPW5bUV07MD09PXIuaXx8MT09PXIuaT9yLmooKTpyLmc9ITB9ZnVuY3Rpb24gUChyLGUpe2UuXz1lLnAubGVuZ3RoO3ZhciBpPWUucFswXSxvPXZvaWQgMCE9PXImJnIhPT1pO3JldHVybiBlLmguT3x8YihcIkVTNVwiKS5TKGUscixvKSxvPyhpW1FdLlAmJihnKGUpLG4oNCkpLHQocikmJihyPU0oZSxyKSxlLmx8fHgoZSxyKSksZS51JiZiKFwiUGF0Y2hlc1wiKS5NKGlbUV0udCxyLGUudSxlLnMpKTpyPU0oZSxpLFtdKSxnKGUpLGUudSYmZS52KGUudSxlLnMpLHIhPT1IP3I6dm9pZCAwfWZ1bmN0aW9uIE0obixyLHQpe2lmKHkocikpcmV0dXJuIHI7dmFyIGU9cltRXTtpZighZSlyZXR1cm4gaShyLChmdW5jdGlvbihpLG8pe3JldHVybiBBKG4sZSxyLGksbyx0KX0pLCEwKSxyO2lmKGUuQSE9PW4pcmV0dXJuIHI7aWYoIWUuUClyZXR1cm4geChuLGUudCwhMCksZS50O2lmKCFlLkkpe2UuST0hMCxlLkEuXy0tO3ZhciBvPTQ9PT1lLml8fDU9PT1lLmk/ZS5vPWwoZS5rKTplLm8sdT1vLGE9ITE7Mz09PWUuaSYmKHU9bmV3IFNldChvKSxvLmNsZWFyKCksYT0hMCksaSh1LChmdW5jdGlvbihyLGkpe3JldHVybiBBKG4sZSxvLHIsaSx0LGEpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLk4oZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyx2KXtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZjPT09byYmbig1KSxyKGMpKXt2YXIgcD1NKGUsYyxzJiZpJiYzIT09aS5pJiYhdShpLlIsYSk/cy5jb25jYXQoYSk6dm9pZCAwKTtpZihmKG8sYSxwKSwhcihwKSlyZXR1cm47ZS5tPSExfWVsc2UgdiYmby5hZGQoYyk7aWYodChjKSYmIXkoYykpe2lmKCFlLmguRCYmZS5fPDEpcmV0dXJuO00oZSxjKSxpJiZpLkEubHx8eChlLGMpfX1mdW5jdGlvbiB4KG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksIW4ubCYmbi5oLkQmJm4ubSYmZChyLHQpfWZ1bmN0aW9uIHoobixyKXt2YXIgdD1uW1FdO3JldHVybih0P3AodCk6bilbcl19ZnVuY3Rpb24gSShuLHIpe2lmKHIgaW4gbilmb3IodmFyIHQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO3Q7KXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7aWYoZSlyZXR1cm4gZTt0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0KX19ZnVuY3Rpb24gayhuKXtuLlB8fChuLlA9ITAsbi5sJiZrKG4ubCkpfWZ1bmN0aW9uIEUobil7bi5vfHwobi5vPWwobi50KSl9ZnVuY3Rpb24gTihuLHIsdCl7dmFyIGU9cyhyKT9iKFwiTWFwU2V0XCIpLkYocix0KTp2KHIpP2IoXCJNYXBTZXRcIikuVChyLHQpOm4uTz9mdW5jdGlvbihuLHIpe3ZhciB0PUFycmF5LmlzQXJyYXkobiksZT17aTp0PzE6MCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6bnVsbCxvOm51bGwsajpudWxsLEM6ITF9LGk9ZSxvPWVuO3QmJihpPVtlXSxvPW9uKTt2YXIgdT1Qcm94eS5yZXZvY2FibGUoaSxvKSxhPXUucmV2b2tlLGY9dS5wcm94eTtyZXR1cm4gZS5rPWYsZS5qPWEsZn0ocix0KTpiKFwiRVM1XCIpLkoocix0KTtyZXR1cm4odD90LkE6XygpKS5wLnB1c2goZSksZX1mdW5jdGlvbiBSKGUpe3JldHVybiByKGUpfHxuKDIyLGUpLGZ1bmN0aW9uIG4ocil7aWYoIXQocikpcmV0dXJuIHI7dmFyIGUsdT1yW1FdLGM9byhyKTtpZih1KXtpZighdS5QJiYodS5pPDR8fCFiKFwiRVM1XCIpLksodSkpKXJldHVybiB1LnQ7dS5JPSEwLGU9RChyLGMpLHUuST0hMX1lbHNlIGU9RChyLGMpO3JldHVybiBpKGUsKGZ1bmN0aW9uKHIsdCl7dSYmYSh1LnQscik9PT10fHxmKGUscixuKHQpKX0pKSwzPT09Yz9uZXcgU2V0KGUpOmV9KGUpfWZ1bmN0aW9uIEQobixyKXtzd2l0Y2gocil7Y2FzZSAyOnJldHVybiBuZXcgTWFwKG4pO2Nhc2UgMzpyZXR1cm4gQXJyYXkuZnJvbShuKX1yZXR1cm4gbChuKX1mdW5jdGlvbiBGKCl7ZnVuY3Rpb24gdChuLHIpe3ZhciB0PXNbbl07cmV0dXJuIHQ/dC5lbnVtZXJhYmxlPXI6c1tuXT10PXtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTpyLGdldDpmdW5jdGlvbigpe3ZhciByPXRoaXNbUV07cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZihyKSxlbi5nZXQocixuKX0sc2V0OmZ1bmN0aW9uKHIpe3ZhciB0PXRoaXNbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZih0KSxlbi5zZXQodCxuLHIpfX0sdH1mdW5jdGlvbiBlKG4pe2Zvcih2YXIgcj1uLmxlbmd0aC0xO3I+PTA7ci0tKXt2YXIgdD1uW3JdW1FdO2lmKCF0LlApc3dpdGNoKHQuaSl7Y2FzZSA1OmEodCkmJmsodCk7YnJlYWs7Y2FzZSA0Om8odCkmJmsodCl9fX1mdW5jdGlvbiBvKG4pe2Zvcih2YXIgcj1uLnQsdD1uLmssZT1ubih0KSxpPWUubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBvPWVbaV07aWYobyE9PVEpe3ZhciBhPXJbb107aWYodm9pZCAwPT09YSYmIXUocixvKSlyZXR1cm4hMDt2YXIgZj10W29dLHM9ZiYmZltRXTtpZihzP3MudCE9PWE6IWMoZixhKSlyZXR1cm4hMH19dmFyIHY9ISFyW1FdO3JldHVybiBlLmxlbmd0aCE9PW5uKHIpLmxlbmd0aCsodj8wOjEpfWZ1bmN0aW9uIGEobil7dmFyIHI9bi5rO2lmKHIubGVuZ3RoIT09bi50Lmxlbmd0aClyZXR1cm4hMDt2YXIgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsci5sZW5ndGgtMSk7aWYodCYmIXQuZ2V0KXJldHVybiEwO2Zvcih2YXIgZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKCFyLmhhc093blByb3BlcnR5KGUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGYocil7ci5nJiZuKDMsSlNPTi5zdHJpbmdpZnkocChyKSkpfXZhciBzPXt9O20oXCJFUzVcIix7SjpmdW5jdGlvbihuLHIpe3ZhciBlPUFycmF5LmlzQXJyYXkobiksaT1mdW5jdGlvbihuLHIpe2lmKG4pe2Zvcih2YXIgZT1BcnJheShyLmxlbmd0aCksaT0wO2k8ci5sZW5ndGg7aSsrKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiXCIraSx0KGksITApKTtyZXR1cm4gZX12YXIgbz1ybihyKTtkZWxldGUgb1tRXTtmb3IodmFyIHU9bm4obyksYT0wO2E8dS5sZW5ndGg7YSsrKXt2YXIgZj11W2FdO29bZl09dChmLG58fCEhb1tmXS5lbnVtZXJhYmxlKX1yZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yociksbyl9KGUsbiksbz17aTplPzU6NCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6aSxvOm51bGwsZzohMSxDOiExfTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksUSx7dmFsdWU6byx3cml0YWJsZTohMH0pLGl9LFM6ZnVuY3Rpb24obix0LG8pe28/cih0KSYmdFtRXS5BPT09biYmZShuLnApOihuLnUmJmZ1bmN0aW9uIG4ocil7aWYociYmXCJvYmplY3RcIj09dHlwZW9mIHIpe3ZhciB0PXJbUV07aWYodCl7dmFyIGU9dC50LG89dC5rLGY9dC5SLGM9dC5pO2lmKDQ9PT1jKWkobywoZnVuY3Rpb24ocil7ciE9PVEmJih2b2lkIDAhPT1lW3JdfHx1KGUscik/ZltyXXx8bihvW3JdKTooZltyXT0hMCxrKHQpKSl9KSksaShlLChmdW5jdGlvbihuKXt2b2lkIDAhPT1vW25dfHx1KG8sbil8fChmW25dPSExLGsodCkpfSkpO2Vsc2UgaWYoNT09PWMpe2lmKGEodCkmJihrKHQpLGYubGVuZ3RoPSEwKSxvLmxlbmd0aDxlLmxlbmd0aClmb3IodmFyIHM9by5sZW5ndGg7czxlLmxlbmd0aDtzKyspZltzXT0hMTtlbHNlIGZvcih2YXIgdj1lLmxlbmd0aDt2PG8ubGVuZ3RoO3YrKylmW3ZdPSEwO2Zvcih2YXIgcD1NYXRoLm1pbihvLmxlbmd0aCxlLmxlbmd0aCksbD0wO2w8cDtsKyspby5oYXNPd25Qcm9wZXJ0eShsKXx8KGZbbF09ITApLHZvaWQgMD09PWZbbF0mJm4ob1tsXSl9fX19KG4ucFswXSksZShuLnApKX0sSzpmdW5jdGlvbihuKXtyZXR1cm4gND09PW4uaT9vKG4pOmEobil9fSl9ZnVuY3Rpb24gVCgpe2Z1bmN0aW9uIGUobil7aWYoIXQobikpcmV0dXJuIG47aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gbi5tYXAoZSk7aWYocyhuKSlyZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG4uZW50cmllcygpKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybltuWzBdLGUoblsxXSldfSkpKTtpZih2KG4pKXJldHVybiBuZXcgU2V0KEFycmF5LmZyb20obikubWFwKGUpKTt2YXIgcj1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihuKSk7Zm9yKHZhciBpIGluIG4pcltpXT1lKG5baV0pO3JldHVybiB1KG4sTCkmJihyW0xdPW5bTF0pLHJ9ZnVuY3Rpb24gZihuKXtyZXR1cm4gcihuKT9lKG4pOm59dmFyIGM9XCJhZGRcIjttKFwiUGF0Y2hlc1wiLHskOmZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQucGF0aCx1PXQub3AsZj1yLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgdj1vKGYpLHA9aVtzXTtcInN0cmluZ1wiIT10eXBlb2YgcCYmXCJudW1iZXJcIiE9dHlwZW9mIHAmJihwPVwiXCIrcCksMCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LE46ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uUiwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLlIsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLlI9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1OKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuZyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsUjp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLGc6ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5SLnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5SLnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5SLnNldChuLCExKTpyLlIuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uUj1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLlIuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89TihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxnOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7RjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe0YoKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1OKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5SW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJih2b2lkIDAhPT10fHxyIGluIG4ubyl8fE51bWJlci5pc05hTih0KSYmTnVtYmVyLmlzTmFOKG4ub1tyXSl8fChuLm9bcl09dCxuLlJbcl09ITApLCEwfSxkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbihuLHIpe3JldHVybiB2b2lkIDAhPT16KG4udCxyKXx8ciBpbiBuLnQ/KG4uUltyXT0hMSxFKG4pLGsobikpOmRlbGV0ZSBuLlJbcl0sbi5vJiZkZWxldGUgbi5vW3JdLCEwfSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24obixyKXt2YXIgdD1wKG4pLGU9UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtyZXR1cm4gZT97d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOjEhPT1uLml8fFwibGVuZ3RoXCIhPT1yLGVudW1lcmFibGU6ZS5lbnVtZXJhYmxlLHZhbHVlOnRbcl19OmV9LGRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKCl7bigxMSl9LGdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobi50KX0sc2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oKXtuKDEyKX19LG9uPXt9O2koZW4sKGZ1bmN0aW9uKG4scil7b25bbl09ZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzWzBdPWFyZ3VtZW50c1swXVswXSxyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KSksb24uZGVsZXRlUHJvcGVydHk9ZnVuY3Rpb24ocix0KXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpc05hTihwYXJzZUludCh0KSkmJm4oMTMpLG9uLnNldC5jYWxsKHRoaXMscix0LHZvaWQgMCl9LG9uLnNldD1mdW5jdGlvbihyLHQsZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJsZW5ndGhcIiE9PXQmJmlzTmFOKHBhcnNlSW50KHQpKSYmbigxNCksZW4uc2V0LmNhbGwodGhpcyxyWzBdLHQsZSxyWzBdKX07dmFyIHVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt2YXIgZT10aGlzO3RoaXMuTz1CLHRoaXMuRD0hMCx0aGlzLnByb2R1Y2U9ZnVuY3Rpb24ocixpLG8pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpe3ZhciB1PWk7aT1yO3ZhciBhPWU7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPXRoaXM7dm9pZCAwPT09biYmKG49dSk7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0PjE/dC0xOjApLG89MTtvPHQ7bysrKWVbby0xXT1hcmd1bWVudHNbb107cmV0dXJuIGEucHJvZHVjZShuLChmdW5jdGlvbihuKXt2YXIgdDtyZXR1cm4odD1pKS5jYWxsLmFwcGx5KHQsW3Isbl0uY29uY2F0KGUpKX0pKX19dmFyIGY7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmbig2KSx2b2lkIDAhPT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBvJiZuKDcpLHQocikpe3ZhciBjPXcoZSkscz1OKGUscix2b2lkIDApLHY9ITA7dHJ5e2Y9aShzKSx2PSExfWZpbmFsbHl7dj9nKGMpOk8oYyl9cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmYgaW5zdGFuY2VvZiBQcm9taXNlP2YudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGooYyxvKSxQKG4sYyl9KSwoZnVuY3Rpb24obil7dGhyb3cgZyhjKSxufSkpOihqKGMsbyksUChmLGMpKX1pZighcnx8XCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKHZvaWQgMD09PShmPWkocikpJiYoZj1yKSxmPT09SCYmKGY9dm9pZCAwKSxlLkQmJmQoZiwhMCksbyl7dmFyIHA9W10sbD1bXTtiKFwiUGF0Y2hlc1wiKS5NKHIsZixwLGwpLG8ocCxsKX1yZXR1cm4gZn1uKDIxLHIpfSx0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcz1mdW5jdGlvbihuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIGZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKylpW28tMV09YXJndW1lbnRzW29dO3JldHVybiBlLnByb2R1Y2VXaXRoUGF0Y2hlcyhyLChmdW5jdGlvbihyKXtyZXR1cm4gbi5hcHBseSh2b2lkIDAsW3JdLmNvbmNhdChpKSl9KSl9O3ZhciB0LGksbz1lLnByb2R1Y2UobixyLChmdW5jdGlvbihuLHIpe3Q9bixpPXJ9KSk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJm8gaW5zdGFuY2VvZiBQcm9taXNlP28udGhlbigoZnVuY3Rpb24obil7cmV0dXJuW24sdCxpXX0pKTpbbyx0LGldfSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIudXNlUHJveGllcykmJnRoaXMuc2V0VXNlUHJveGllcyhyLnVzZVByb3hpZXMpLFwiYm9vbGVhblwiPT10eXBlb2YobnVsbD09cj92b2lkIDA6ci5hdXRvRnJlZXplKSYmdGhpcy5zZXRBdXRvRnJlZXplKHIuYXV0b0ZyZWV6ZSl9dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuY3JlYXRlRHJhZnQ9ZnVuY3Rpb24oZSl7dChlKXx8big4KSxyKGUpJiYoZT1SKGUpKTt2YXIgaT13KHRoaXMpLG89Tih0aGlzLGUsdm9pZCAwKTtyZXR1cm4gb1tRXS5DPSEwLE8oaSksb30saS5maW5pc2hEcmFmdD1mdW5jdGlvbihyLHQpe3ZhciBlPXImJnJbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKGUmJmUuQ3x8big5KSxlLkkmJm4oMTApKTt2YXIgaT1lLkE7cmV0dXJuIGooaSx0KSxQKHZvaWQgMCxpKX0saS5zZXRBdXRvRnJlZXplPWZ1bmN0aW9uKG4pe3RoaXMuRD1ufSxpLnNldFVzZVByb3hpZXM9ZnVuY3Rpb24ocil7ciYmIUImJm4oMjApLHRoaXMuTz1yfSxpLmFwcGx5UGF0Y2hlcz1mdW5jdGlvbihuLHQpe3ZhciBlO2ZvcihlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe3ZhciBpPXRbZV07aWYoMD09PWkucGF0aC5sZW5ndGgmJlwicmVwbGFjZVwiPT09aS5vcCl7bj1pLnZhbHVlO2JyZWFrfX1lPi0xJiYodD10LnNsaWNlKGUrMSkpO3ZhciBvPWIoXCJQYXRjaGVzXCIpLiQ7cmV0dXJuIHIobik/byhuLHQpOnRoaXMucHJvZHVjZShuLChmdW5jdGlvbihuKXtyZXR1cm4gbyhuLHQpfSkpfSxlfSgpLGFuPW5ldyB1bixmbj1hbi5wcm9kdWNlLGNuPWFuLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGFuKSxzbj1hbi5zZXRBdXRvRnJlZXplLmJpbmQoYW4pLHZuPWFuLnNldFVzZVByb3hpZXMuYmluZChhbikscG49YW4uYXBwbHlQYXRjaGVzLmJpbmQoYW4pLGxuPWFuLmNyZWF0ZURyYWZ0LmJpbmQoYW4pLGRuPWFuLmZpbmlzaERyYWZ0LmJpbmQoYW4pO2V4cG9ydCBkZWZhdWx0IGZuO2V4cG9ydHt1biBhcyBJbW1lcixwbiBhcyBhcHBseVBhdGNoZXMsSyBhcyBjYXN0RHJhZnQsJCBhcyBjYXN0SW1tdXRhYmxlLGxuIGFzIGNyZWF0ZURyYWZ0LFIgYXMgY3VycmVudCxKIGFzIGVuYWJsZUFsbFBsdWdpbnMsRiBhcyBlbmFibGVFUzUsQyBhcyBlbmFibGVNYXBTZXQsVCBhcyBlbmFibGVQYXRjaGVzLGRuIGFzIGZpbmlzaERyYWZ0LGQgYXMgZnJlZXplLEwgYXMgaW1tZXJhYmxlLHIgYXMgaXNEcmFmdCx0IGFzIGlzRHJhZnRhYmxlLEggYXMgbm90aGluZyxlIGFzIG9yaWdpbmFsLGZuIGFzIHByb2R1Y2UsY24gYXMgcHJvZHVjZVdpdGhQYXRjaGVzLHNuIGFzIHNldEF1dG9GcmVlemUsdm4gYXMgc2V0VXNlUHJveGllc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5lc20uanMubWFwXG4iXSwibmFtZXMiOlsibiIsInIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ0IiwiQXJyYXkiLCJlIiwiaSIsIlkiLCJvIiwiYXBwbHkiLCJFcnJvciIsIm1hcCIsImpvaW4iLCJRIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwidG9TdHJpbmciLCJaIiwiaXNBcnJheSIsIkwiLCJzIiwidiIsImtleXMiLCJubiIsImZvckVhY2giLCJ1IiwiaGFzIiwicHJvdG90eXBlIiwiYSIsImdldCIsImYiLCJzZXQiLCJhZGQiLCJjIiwiWCIsIk1hcCIsInEiLCJTZXQiLCJwIiwibCIsInNsaWNlIiwicm4iLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsImNyZWF0ZSIsImQiLCJ5IiwiY2xlYXIiLCJkZWxldGUiLCJoIiwiZnJlZXplIiwiaXNGcm96ZW4iLCJiIiwidG4iLCJtIiwiXyIsIlUiLCJqIiwiZyIsIk8iLCJTIiwidyIsIlAiLCJNIiwieCIsIkgiLCJBIiwiSSIsImsiLCJOIiwiUiIsImNvbmNhdCIsIkQiLCJ6IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRSIsIkYiLCJUIiwiQyIsImVuIiwib24iLCJQcm94eSIsInJldm9jYWJsZSIsInJldm9rZSIsInByb3h5IiwiSiIsInB1c2giLCJLIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWZpbmVQcm9wZXJ0eSIsIk1hdGgiLCJtaW4iLCJlbnRyaWVzIiwiJCIsInBhdGgiLCJvcCIsInNwbGljZSIsInVuc2hpZnQiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInNpemUiLCJ2YWx1ZXMiLCJWIiwibmV4dCIsImRvbmUiLCJHIiwiVyIsIlN5bWJvbCIsIkIiLCJSZWZsZWN0IiwiZm9yIiwiaXRlcmF0b3IiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJOdW1iZXIiLCJpc05hTiIsImRlbGV0ZVByb3BlcnR5IiwicGFyc2VJbnQiLCJ1biIsInByb2R1Y2UiLCJQcm9taXNlIiwidGhlbiIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsInVzZVByb3hpZXMiLCJzZXRVc2VQcm94aWVzIiwiYXV0b0ZyZWV6ZSIsInNldEF1dG9GcmVlemUiLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiYXBwbHlQYXRjaGVzIiwiYW4iLCJmbiIsImNuIiwiYmluZCIsInNuIiwidm4iLCJwbiIsImxuIiwiZG4iLCJJbW1lciIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiLCJjdXJyZW50IiwiZW5hYmxlQWxsUGx1Z2lucyIsImVuYWJsZUVTNSIsImVuYWJsZU1hcFNldCIsImVuYWJsZVBhdGNoZXMiLCJpbW1lcmFibGUiLCJpc0RyYWZ0IiwiaXNEcmFmdGFibGUiLCJub3RoaW5nIiwib3JpZ2luYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/immer/dist/immer.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/react-toastify/dist/react-toastify.esm.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bounce: function() { return /* binding */ R; },\n/* harmony export */   Flip: function() { return /* binding */ $; },\n/* harmony export */   Icons: function() { return /* binding */ E; },\n/* harmony export */   Slide: function() { return /* binding */ w; },\n/* harmony export */   ToastContainer: function() { return /* binding */ k; },\n/* harmony export */   Zoom: function() { return /* binding */ x; },\n/* harmony export */   collapseToast: function() { return /* binding */ g; },\n/* harmony export */   cssTransition: function() { return /* binding */ h; },\n/* harmony export */   toast: function() { return /* binding */ Q; },\n/* harmony export */   useToast: function() { return /* binding */ _; },\n/* harmony export */   useToastContainer: function() { return /* binding */ C; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.m.js\");\n/* __next_internal_client_entry_do_not_use__ Bounce,Flip,Icons,Slide,ToastContainer,Zoom,collapseToast,cssTransition,toast,useToast,useToastContainer auto */ \n\nconst u = (t)=>\"number\" == typeof t && !isNaN(t), d = (t)=>\"string\" == typeof t, p = (t)=>\"function\" == typeof t, m = (t)=>d(t) || p(t) ? t : null, f = (t)=>/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t) || d(t) || p(t) || u(t);\nfunction g(t, e, n) {\n    void 0 === n && (n = 300);\n    const { scrollHeight: o, style: s } = t;\n    requestAnimationFrame(()=>{\n        s.minHeight = \"initial\", s.height = o + \"px\", s.transition = \"all \".concat(n, \"ms\"), requestAnimationFrame(()=>{\n            s.height = \"0\", s.padding = \"0\", s.margin = \"0\", setTimeout(e, n);\n        });\n    });\n}\nfunction h(e) {\n    let { enter: a, exit: r, appendPosition: i = !1, collapse: l = !0, collapseDuration: c = 300 } = e;\n    return function(e) {\n        let { children: u, position: d, preventExitTransition: p, done: m, nodeRef: f, isIn: h } = e;\n        const y = i ? \"\".concat(a, \"--\").concat(d) : a, v = i ? \"\".concat(r, \"--\").concat(d) : r, T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n            const t = f.current, e = y.split(\" \"), n = (o)=>{\n                o.target === f.current && (t.dispatchEvent(new Event(\"d\")), t.removeEventListener(\"animationend\", n), t.removeEventListener(\"animationcancel\", n), 0 === T.current && \"animationcancel\" !== o.type && t.classList.remove(...e));\n            };\n            t.classList.add(...e), t.addEventListener(\"animationend\", n), t.addEventListener(\"animationcancel\", n);\n        }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            const t = f.current, e = ()=>{\n                t.removeEventListener(\"animationend\", e), l ? g(t, m, c) : m();\n            };\n            h || (p ? e() : (T.current = 1, t.className += \" \".concat(v), t.addEventListener(\"animationend\", e)));\n        }, [\n            h\n        ]), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, u);\n    };\n}\nfunction y(t, e) {\n    return null != t ? {\n        content: t.content,\n        containerId: t.props.containerId,\n        id: t.props.toastId,\n        theme: t.props.theme,\n        type: t.props.type,\n        data: t.props.data || {},\n        isLoading: t.props.isLoading,\n        icon: t.props.icon,\n        status: e\n    } : {};\n}\nconst v = {\n    list: new Map,\n    emitQueue: new Map,\n    on (t, e) {\n        return this.list.has(t) || this.list.set(t, []), this.list.get(t).push(e), this;\n    },\n    off (t, e) {\n        if (e) {\n            const n = this.list.get(t).filter((t)=>t !== e);\n            return this.list.set(t, n), this;\n        }\n        return this.list.delete(t), this;\n    },\n    cancelEmit (t) {\n        const e = this.emitQueue.get(t);\n        return e && (e.forEach(clearTimeout), this.emitQueue.delete(t)), this;\n    },\n    emit (t) {\n        this.list.has(t) && this.list.get(t).forEach((e)=>{\n            const n = setTimeout(()=>{\n                e(...[].slice.call(arguments, 1));\n            }, 0);\n            this.emitQueue.has(t) || this.emitQueue.set(t, []), this.emitQueue.get(t).push(n);\n        });\n    }\n}, T = (e)=>{\n    let { theme: n, type: o, ...s } = e;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        viewBox: \"0 0 24 24\",\n        width: \"100%\",\n        height: \"100%\",\n        fill: \"colored\" === n ? \"currentColor\" : \"var(--toastify-icon-color-\".concat(o, \")\"),\n        ...s\n    });\n}, E = {\n    info: function(e) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, {\n            ...e\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            d: \"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"\n        }));\n    },\n    warning: function(e) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, {\n            ...e\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            d: \"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"\n        }));\n    },\n    success: function(e) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, {\n            ...e\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            d: \"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"\n        }));\n    },\n    error: function(e) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(T, {\n            ...e\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n            d: \"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"\n        }));\n    },\n    spinner: function() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            className: \"Toastify__spinner\"\n        });\n    }\n};\nfunction C(t) {\n    const [, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((t)=>t + 1, 0), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map).current, T = (t)=>-1 !== l.indexOf(t), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        toastKey: 1,\n        displayedToast: 0,\n        count: 0,\n        queue: [],\n        props: t,\n        containerId: null,\n        isToastActive: T,\n        getToast: (t)=>h.get(t)\n    }).current;\n    function b(t) {\n        let { containerId: e } = t;\n        const { limit: n } = C.props;\n        !n || e && C.containerId !== e || (C.count -= C.queue.length, C.queue = []);\n    }\n    function I(t) {\n        c((e)=>null == t ? [] : e.filter((e)=>e !== t));\n    }\n    function _() {\n        const { toastContent: t, toastProps: e, staleId: n } = C.queue.shift();\n        O(t, e, n);\n    }\n    function L(t, n) {\n        let { delay: s, staleId: r, ...i } = n;\n        if (!f(t) || function(t) {\n            return !g.current || C.props.enableMultiContainer && t.containerId !== C.props.containerId || h.has(t.toastId) && null == t.updateId;\n        }(i)) return;\n        const { toastId: l, updateId: c, data: T } = i, { props: b } = C, L = ()=>I(l), N = null == c;\n        N && C.count++;\n        const M = {\n            ...b,\n            style: b.toastStyle,\n            key: C.toastKey++,\n            ...Object.fromEntries(Object.entries(i).filter((t)=>{\n                let [e, n] = t;\n                return null != n;\n            })),\n            toastId: l,\n            updateId: c,\n            data: T,\n            closeToast: L,\n            isIn: !1,\n            className: m(i.className || b.toastClassName),\n            bodyClassName: m(i.bodyClassName || b.bodyClassName),\n            progressClassName: m(i.progressClassName || b.progressClassName),\n            autoClose: !i.isLoading && (R = i.autoClose, w = b.autoClose, !1 === R || u(R) && R > 0 ? R : w),\n            deleteToast () {\n                const t = y(h.get(l), \"removed\");\n                h.delete(l), v.emit(4, t);\n                const e = C.queue.length;\n                if (C.count = null == l ? C.count - C.displayedToast : C.count - 1, C.count < 0 && (C.count = 0), e > 0) {\n                    const t = null == l ? C.props.limit : 1;\n                    if (1 === e || 1 === t) C.displayedToast++, _();\n                    else {\n                        const n = t > e ? e : t;\n                        C.displayedToast = n;\n                        for(let t = 0; t < n; t++)_();\n                    }\n                } else o();\n            }\n        };\n        var R, w;\n        M.iconOut = function(t) {\n            let { theme: n, type: o, isLoading: s, icon: r } = t, i = null;\n            const l = {\n                theme: n,\n                type: o\n            };\n            return !1 === r || (p(r) ? i = r(l) : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(r) ? i = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(r, l) : d(r) || u(r) ? i = r : s ? i = E.spinner() : ((t)=>t in E)(o) && (i = E[o](l))), i;\n        }(M), p(i.onOpen) && (M.onOpen = i.onOpen), p(i.onClose) && (M.onClose = i.onClose), M.closeButton = b.closeButton, !1 === i.closeButton || f(i.closeButton) ? M.closeButton = i.closeButton : !0 === i.closeButton && (M.closeButton = !f(b.closeButton) || b.closeButton);\n        let x = t;\n        /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t) && !d(t.type) ? x = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(t, {\n            closeToast: L,\n            toastProps: M,\n            data: T\n        }) : p(t) && (x = t({\n            closeToast: L,\n            toastProps: M,\n            data: T\n        })), b.limit && b.limit > 0 && C.count > b.limit && N ? C.queue.push({\n            toastContent: x,\n            toastProps: M,\n            staleId: r\n        }) : u(s) ? setTimeout(()=>{\n            O(x, M, r);\n        }, s) : O(x, M, r);\n    }\n    function O(t, e, n) {\n        const { toastId: o } = e;\n        n && h.delete(n);\n        const s = {\n            content: t,\n            props: e\n        };\n        h.set(o, s), c((t)=>[\n                ...t,\n                o\n            ].filter((t)=>t !== n)), v.emit(4, y(s, null == s.props.updateId ? \"added\" : \"updated\"));\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(C.containerId = t.containerId, v.cancelEmit(3).on(0, L).on(1, (t)=>g.current && I(t)).on(5, b).emit(2, C), ()=>{\n            h.clear(), v.emit(3, C);\n        }), []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        C.props = t, C.isToastActive = T, C.displayedToast = l.length;\n    }), {\n        getToastToRender: function(e) {\n            const n = new Map, o = Array.from(h.values());\n            return t.newestOnTop && o.reverse(), o.forEach((t)=>{\n                const { position: e } = t.props;\n                n.has(e) || n.set(e, []), n.get(e).push(t);\n            }), Array.from(n, (t)=>e(t[0], t[1]));\n        },\n        containerRef: g,\n        isToastActive: T\n    };\n}\n_c = C;\nfunction b(t) {\n    return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientX : t.clientX;\n}\nfunction I(t) {\n    return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientY : t.clientY;\n}\n_c1 = I;\nfunction _(t) {\n    const [o, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [r, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        start: 0,\n        x: 0,\n        y: 0,\n        delta: 0,\n        removalDistance: 0,\n        canCloseOnClick: !0,\n        canDrag: !1,\n        boundingRect: null,\n        didMove: !1\n    }).current, d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), { autoClose: m, pauseOnHover: f, closeToast: g, onClick: h, closeOnClick: y } = t;\n    function v(e) {\n        if (t.draggable) {\n            \"touchstart\" === e.nativeEvent.type && e.nativeEvent.preventDefault(), u.didMove = !1, document.addEventListener(\"mousemove\", _), document.addEventListener(\"mouseup\", L), document.addEventListener(\"touchmove\", _), document.addEventListener(\"touchend\", L);\n            const n = c.current;\n            u.canCloseOnClick = !0, u.canDrag = !0, u.boundingRect = n.getBoundingClientRect(), n.style.transition = \"\", u.x = b(e.nativeEvent), u.y = I(e.nativeEvent), \"x\" === t.draggableDirection ? (u.start = u.x, u.removalDistance = n.offsetWidth * (t.draggablePercent / 100)) : (u.start = u.y, u.removalDistance = n.offsetHeight * (80 === t.draggablePercent ? 1.5 * t.draggablePercent : t.draggablePercent / 100));\n        }\n    }\n    function T(e) {\n        if (u.boundingRect) {\n            const { top: n, bottom: o, left: s, right: a } = u.boundingRect;\n            \"touchend\" !== e.nativeEvent.type && t.pauseOnHover && u.x >= s && u.x <= a && u.y >= n && u.y <= o ? C() : E();\n        }\n    }\n    function E() {\n        a(!0);\n    }\n    function C() {\n        a(!1);\n    }\n    function _(e) {\n        const n = c.current;\n        u.canDrag && n && (u.didMove = !0, o && C(), u.x = b(e), u.y = I(e), u.delta = \"x\" === t.draggableDirection ? u.x - u.start : u.y - u.start, u.start !== u.x && (u.canCloseOnClick = !1), n.style.transform = \"translate\".concat(t.draggableDirection, \"(\").concat(u.delta, \"px)\"), n.style.opacity = \"\" + (1 - Math.abs(u.delta / u.removalDistance)));\n    }\n    function L() {\n        document.removeEventListener(\"mousemove\", _), document.removeEventListener(\"mouseup\", L), document.removeEventListener(\"touchmove\", _), document.removeEventListener(\"touchend\", L);\n        const e = c.current;\n        if (u.canDrag && u.didMove && e) {\n            if (u.canDrag = !1, Math.abs(u.delta) > u.removalDistance) return l(!0), void t.closeToast();\n            e.style.transition = \"transform 0.2s, opacity 0.2s\", e.style.transform = \"translate\".concat(t.draggableDirection, \"(0)\"), e.style.opacity = \"1\";\n        }\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        d.current = t;\n    }), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(c.current && c.current.addEventListener(\"d\", E, {\n            once: !0\n        }), p(t.onOpen) && t.onOpen(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t.children) && t.children.props), ()=>{\n            const t = d.current;\n            p(t.onClose) && t.onClose(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(t.children) && t.children.props);\n        }), []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(t.pauseOnFocusLoss && (document.hasFocus() || C(), window.addEventListener(\"focus\", E), window.addEventListener(\"blur\", C)), ()=>{\n            t.pauseOnFocusLoss && (window.removeEventListener(\"focus\", E), window.removeEventListener(\"blur\", C));\n        }), [\n        t.pauseOnFocusLoss\n    ]);\n    const O = {\n        onMouseDown: v,\n        onTouchStart: v,\n        onMouseUp: T,\n        onTouchEnd: T\n    };\n    return m && f && (O.onMouseEnter = C, O.onMouseLeave = E), y && (O.onClick = (t)=>{\n        h && h(t), u.canCloseOnClick && g();\n    }), {\n        playToast: E,\n        pauseToast: C,\n        isRunning: o,\n        preventExitTransition: r,\n        toastRef: c,\n        eventHandlers: O\n    };\n}\nfunction L(e) {\n    let { closeToast: n, theme: o, ariaLabel: s = \"close\" } = e;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: \"Toastify__close-button Toastify__close-button--\".concat(o),\n        type: \"button\",\n        onClick: (t)=>{\n            t.stopPropagation(), n(t);\n        },\n        \"aria-label\": s\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        \"aria-hidden\": \"true\",\n        viewBox: \"0 0 14 16\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        fillRule: \"evenodd\",\n        d: \"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n    })));\n}\n_c2 = L;\nfunction O(e) {\n    let { delay: n, isRunning: o, closeToast: s, type: a = \"default\", hide: r, className: i, style: l, controlledProgress: u, progress: d, rtl: m, isIn: f, theme: g } = e;\n    const h = r || u && 0 === d, y = {\n        ...l,\n        animationDuration: \"\".concat(n, \"ms\"),\n        animationPlayState: o ? \"running\" : \"paused\",\n        opacity: h ? 0 : 1\n    };\n    u && (y.transform = \"scaleX(\".concat(d, \")\"));\n    const v = (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__progress-bar\", u ? \"Toastify__progress-bar--controlled\" : \"Toastify__progress-bar--animated\", \"Toastify__progress-bar-theme--\".concat(g), \"Toastify__progress-bar--\".concat(a), {\n        \"Toastify__progress-bar--rtl\": m\n    }), T = p(i) ? i({\n        rtl: m,\n        type: a,\n        defaultClassName: v\n    }) : (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(v, i);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        role: \"progressbar\",\n        \"aria-hidden\": h ? \"true\" : \"false\",\n        \"aria-label\": \"notification timer\",\n        className: T,\n        style: y,\n        [u && d >= 1 ? \"onTransitionEnd\" : \"onAnimationEnd\"]: u && d < 1 ? null : ()=>{\n            f && s();\n        }\n    });\n}\n_c3 = O;\nconst N = (n)=>{\n    const { isRunning: o, preventExitTransition: s, toastRef: r, eventHandlers: i } = _(n), { closeButton: l, children: u, autoClose: d, onClick: m, type: f, hideProgressBar: g, closeToast: h, transition: y, position: v, className: T, style: E, bodyClassName: C, bodyStyle: b, progressClassName: I, progressStyle: N, updateId: M, role: R, progress: w, rtl: x, toastId: $, deleteToast: k, isIn: P, isLoading: B, iconOut: D, closeOnClick: A, theme: z } = n, F = (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast\", \"Toastify__toast-theme--\".concat(z), \"Toastify__toast--\".concat(f), {\n        \"Toastify__toast--rtl\": x\n    }, {\n        \"Toastify__toast--close-on-click\": A\n    }), H = p(T) ? T({\n        rtl: x,\n        position: v,\n        type: f,\n        defaultClassName: F\n    }) : (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(F, T), S = !!w || !d, q = {\n        closeToast: h,\n        type: f,\n        theme: z\n    };\n    let Q = null;\n    return !1 === l || (Q = p(l) ? l(q) : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(l) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(l, q) : L(q)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(y, {\n        isIn: P,\n        done: k,\n        position: v,\n        preventExitTransition: s,\n        nodeRef: r\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        id: $,\n        onClick: m,\n        className: H,\n        ...i,\n        style: E,\n        ref: r\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...P && {\n            role: R\n        },\n        className: p(C) ? C({\n            type: f\n        }) : (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-body\", C),\n        style: b\n    }, null != D && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-icon\", {\n            \"Toastify--animate-icon Toastify__zoom-enter\": !B\n        })\n    }, D), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, u)), Q, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(O, {\n        ...M && !S ? {\n            key: \"pb-\".concat(M)\n        } : {},\n        rtl: x,\n        theme: z,\n        delay: d,\n        isRunning: o,\n        isIn: P,\n        closeToast: h,\n        hide: g,\n        type: f,\n        style: N,\n        className: I,\n        controlledProgress: S,\n        progress: w || 0\n    })));\n}, M = function(t, e) {\n    return void 0 === e && (e = !1), {\n        enter: \"Toastify--animate Toastify__\".concat(t, \"-enter\"),\n        exit: \"Toastify--animate Toastify__\".concat(t, \"-exit\"),\n        appendPosition: e\n    };\n}, R = h(M(\"bounce\", !0)), w = h(M(\"slide\", !0)), x = h(M(\"zoom\")), $ = h(M(\"flip\")), k = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, n)=>{\n    const { getToastToRender: o, containerRef: a, isToastActive: r } = C(e), { className: i, style: l, rtl: u, containerId: d } = e;\n    function f(t) {\n        const e = (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"Toastify__toast-container\", \"Toastify__toast-container--\".concat(t), {\n            \"Toastify__toast-container--rtl\": u\n        });\n        return p(i) ? i({\n            position: t,\n            rtl: u,\n            defaultClassName: e\n        }) : (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e, m(i));\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        n && (n.current = a.current);\n    }, []), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: a,\n        className: \"Toastify\",\n        id: d\n    }, o((e, n)=>{\n        const o = n.length ? {\n            ...l\n        } : {\n            ...l,\n            pointerEvents: \"none\"\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            className: f(e),\n            style: o,\n            key: \"container-\".concat(e)\n        }, n.map((e, o)=>{\n            let { content: s, props: a } = e;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(N, {\n                ...a,\n                isIn: r(a.toastId),\n                style: {\n                    ...a.style,\n                    \"--nth\": o + 1,\n                    \"--len\": n.length\n                },\n                key: \"toast-\".concat(a.key)\n            }, s);\n        }));\n    }));\n});\nk.displayName = \"ToastContainer\", k.defaultProps = {\n    position: \"top-right\",\n    transition: R,\n    autoClose: 5e3,\n    closeButton: L,\n    pauseOnHover: !0,\n    pauseOnFocusLoss: !0,\n    closeOnClick: !0,\n    draggable: !0,\n    draggablePercent: 80,\n    draggableDirection: \"x\",\n    role: \"alert\",\n    theme: \"light\"\n};\nlet P, B = new Map, D = [], A = 1;\nfunction z() {\n    return \"\" + A++;\n}\nfunction F(t) {\n    return t && (d(t.toastId) || u(t.toastId)) ? t.toastId : z();\n}\n_c4 = F;\nfunction H(t, e) {\n    return B.size > 0 ? v.emit(0, t, e) : D.push({\n        content: t,\n        options: e\n    }), e.toastId;\n}\n_c5 = H;\nfunction S(t, e) {\n    return {\n        ...e,\n        type: e && e.type || t,\n        toastId: F(e)\n    };\n}\n_c6 = S;\nfunction q(t) {\n    return (e, n)=>H(e, S(t, n));\n}\nfunction Q(t, e) {\n    return H(t, S(\"default\", e));\n}\n_c7 = Q;\nQ.loading = (t, e)=>H(t, S(\"default\", {\n        isLoading: !0,\n        autoClose: !1,\n        closeOnClick: !1,\n        closeButton: !1,\n        draggable: !1,\n        ...e\n    })), Q.promise = function(t, e, n) {\n    let o, { pending: s, error: a, success: r } = e;\n    s && (o = d(s) ? Q.loading(s, n) : Q.loading(s.render, {\n        ...n,\n        ...s\n    }));\n    const i = {\n        isLoading: null,\n        autoClose: null,\n        closeOnClick: null,\n        closeButton: null,\n        draggable: null\n    }, l = (t, e, s)=>{\n        if (null == e) return void Q.dismiss(o);\n        const a = {\n            type: t,\n            ...i,\n            ...n,\n            data: s\n        }, r = d(e) ? {\n            render: e\n        } : e;\n        return o ? Q.update(o, {\n            ...a,\n            ...r\n        }) : Q(r.render, {\n            ...a,\n            ...r\n        }), s;\n    }, c = p(t) ? t() : t;\n    return c.then((t)=>l(\"success\", r, t)).catch((t)=>l(\"error\", a, t)), c;\n}, Q.success = q(\"success\"), Q.info = q(\"info\"), Q.error = q(\"error\"), Q.warning = q(\"warning\"), Q.warn = Q.warning, Q.dark = (t, e)=>H(t, S(\"default\", {\n        theme: \"dark\",\n        ...e\n    })), Q.dismiss = (t)=>{\n    B.size > 0 ? v.emit(1, t) : D = D.filter((e)=>null != t && e.options.toastId !== t);\n}, Q.clearWaitingQueue = function(t) {\n    return void 0 === t && (t = {}), v.emit(5, t);\n}, Q.isActive = (t)=>{\n    let e = !1;\n    return B.forEach((n)=>{\n        n.isToastActive && n.isToastActive(t) && (e = !0);\n    }), e;\n}, Q.update = function(t, e) {\n    void 0 === e && (e = {}), setTimeout(()=>{\n        const n = function(t, e) {\n            let { containerId: n } = e;\n            const o = B.get(n || P);\n            return o && o.getToast(t);\n        }(t, e);\n        if (n) {\n            const { props: o, content: s } = n, a = {\n                delay: 100,\n                ...o,\n                ...e,\n                toastId: e.toastId || t,\n                updateId: z()\n            };\n            a.toastId !== t && (a.staleId = t);\n            const r = a.render || s;\n            delete a.render, H(r, a);\n        }\n    }, 0);\n}, Q.done = (t)=>{\n    Q.update(t, {\n        progress: 1\n    });\n}, Q.onChange = (t)=>(v.on(4, t), ()=>{\n        v.off(4, t);\n    }), Q.POSITION = {\n    TOP_LEFT: \"top-left\",\n    TOP_RIGHT: \"top-right\",\n    TOP_CENTER: \"top-center\",\n    BOTTOM_LEFT: \"bottom-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    BOTTOM_CENTER: \"bottom-center\"\n}, Q.TYPE = {\n    INFO: \"info\",\n    SUCCESS: \"success\",\n    WARNING: \"warning\",\n    ERROR: \"error\",\n    DEFAULT: \"default\"\n}, v.on(2, (t)=>{\n    P = t.containerId || t, B.set(P, t), D.forEach((t)=>{\n        v.emit(0, t.content, t.options);\n    }), D = [];\n}).on(3, (t)=>{\n    B.delete(t.containerId || t), 0 === B.size && v.off(0).off(1).off(5);\n});\n //# sourceMappingURL=react-toastify.esm.mjs.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"C\");\n$RefreshReg$(_c1, \"I\");\n$RefreshReg$(_c2, \"L\");\n$RefreshReg$(_c3, \"O\");\n$RefreshReg$(_c4, \"F\");\n$RefreshReg$(_c5, \"H\");\n$RefreshReg$(_c6, \"S\");\n$RefreshReg$(_c7, \"Q\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC10b2FzdGlmeS9kaXN0L3JlYWN0LXRvYXN0aWZ5LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs4SkFDMEo7QUFBb0I7QUFBQSxNQUFNa0IsSUFBRWxCLENBQUFBLElBQUcsWUFBVSxPQUFPQSxLQUFHLENBQUNtQixNQUFNbkIsSUFBR29CLElBQUVwQixDQUFBQSxJQUFHLFlBQVUsT0FBT0EsR0FBRXFCLElBQUVyQixDQUFBQSxJQUFHLGNBQVksT0FBT0EsR0FBRXNCLElBQUV0QixDQUFBQSxJQUFHb0IsRUFBRXBCLE1BQUlxQixFQUFFckIsS0FBR0EsSUFBRSxNQUFLdUIsSUFBRXZCLENBQUFBLGtCQUFHRSxxREFBQ0EsQ0FBQ0YsTUFBSW9CLEVBQUVwQixNQUFJcUIsRUFBRXJCLE1BQUlrQixFQUFFbEI7QUFBRyxTQUFTd0IsRUFBRXhCLENBQUMsRUFBQ0UsQ0FBQyxFQUFDRSxDQUFDO0lBQUUsS0FBSyxNQUFJQSxLQUFJQSxDQUFBQSxJQUFFLEdBQUU7SUFBRyxNQUFLLEVBQUNxQixjQUFhbkIsQ0FBQyxFQUFDb0IsT0FBTWxCLENBQUMsRUFBQyxHQUFDUjtJQUFFMkIsc0JBQXNCO1FBQUtuQixFQUFFb0IsU0FBUyxHQUFDLFdBQVVwQixFQUFFcUIsTUFBTSxHQUFDdkIsSUFBRSxNQUFLRSxFQUFFc0IsVUFBVSxHQUFDLE9BQVMsT0FBRjFCLEdBQUUsT0FBSXVCLHNCQUFzQjtZQUFLbkIsRUFBRXFCLE1BQU0sR0FBQyxLQUFJckIsRUFBRXVCLE9BQU8sR0FBQyxLQUFJdkIsRUFBRXdCLE1BQU0sR0FBQyxLQUFJQyxXQUFXL0IsR0FBRUU7UUFBRTtJQUFFO0FBQUU7QUFBQyxTQUFTOEIsRUFBRWhDLENBQUM7SUFBRSxJQUFHLEVBQUNpQyxPQUFNekIsQ0FBQyxFQUFDMEIsTUFBS3hCLENBQUMsRUFBQ3lCLGdCQUFldkIsSUFBRSxDQUFDLENBQUMsRUFBQ3dCLFVBQVN0QixJQUFFLENBQUMsQ0FBQyxFQUFDdUIsa0JBQWlCdEIsSUFBRSxHQUFHLEVBQUMsR0FBQ2Y7SUFBRSxPQUFPLFNBQVNBLENBQUM7UUFBRSxJQUFHLEVBQUNzQyxVQUFTdEIsQ0FBQyxFQUFDdUIsVUFBU3JCLENBQUMsRUFBQ3NCLHVCQUFzQnJCLENBQUMsRUFBQ3NCLE1BQUtyQixDQUFDLEVBQUNzQixTQUFRckIsQ0FBQyxFQUFDc0IsTUFBS1gsQ0FBQyxFQUFDLEdBQUNoQztRQUFFLE1BQU00QyxJQUFFaEMsSUFBRSxHQUFTTSxPQUFOVixHQUFFLE1BQU0sT0FBRlUsS0FBSVYsR0FBRXFDLElBQUVqQyxJQUFFLEdBQVNNLE9BQU5SLEdBQUUsTUFBTSxPQUFGUSxLQUFJUixHQUFFb0MsSUFBRTVDLDZDQUFDQSxDQUFDO1FBQUcsT0FBT0Usc0RBQUNBLENBQUM7WUFBSyxNQUFNTixJQUFFdUIsRUFBRTBCLE9BQU8sRUFBQy9DLElBQUU0QyxFQUFFSSxLQUFLLENBQUMsTUFBSzlDLElBQUVFLENBQUFBO2dCQUFJQSxFQUFFNkMsTUFBTSxLQUFHNUIsRUFBRTBCLE9BQU8sSUFBR2pELENBQUFBLEVBQUVvRCxhQUFhLENBQUMsSUFBSUMsTUFBTSxPQUFNckQsRUFBRXNELG1CQUFtQixDQUFDLGdCQUFlbEQsSUFBR0osRUFBRXNELG1CQUFtQixDQUFDLG1CQUFrQmxELElBQUcsTUFBSTRDLEVBQUVDLE9BQU8sSUFBRSxzQkFBb0IzQyxFQUFFaUQsSUFBSSxJQUFFdkQsRUFBRXdELFNBQVMsQ0FBQ0MsTUFBTSxJQUFJdkQsRUFBQztZQUFFO1lBQUVGLEVBQUV3RCxTQUFTLENBQUNFLEdBQUcsSUFBSXhELElBQUdGLEVBQUUyRCxnQkFBZ0IsQ0FBQyxnQkFBZXZELElBQUdKLEVBQUUyRCxnQkFBZ0IsQ0FBQyxtQkFBa0J2RDtRQUFFLEdBQUUsRUFBRSxHQUFFSSxnREFBQ0EsQ0FBQztZQUFLLE1BQU1SLElBQUV1QixFQUFFMEIsT0FBTyxFQUFDL0MsSUFBRTtnQkFBS0YsRUFBRXNELG1CQUFtQixDQUFDLGdCQUFlcEQsSUFBR2MsSUFBRVEsRUFBRXhCLEdBQUVzQixHQUFFTCxLQUFHSztZQUFHO1lBQUVZLEtBQUliLENBQUFBLElBQUVuQixNQUFLOEMsQ0FBQUEsRUFBRUMsT0FBTyxHQUFDLEdBQUVqRCxFQUFFNEQsU0FBUyxJQUFFLElBQU0sT0FBRmIsSUFBSS9DLEVBQUUyRCxnQkFBZ0IsQ0FBQyxnQkFBZXpELEVBQUMsQ0FBQztRQUFFLEdBQUU7WUFBQ2dDO1NBQUUsaUJBQUVsQyxnREFBZSxDQUFDQSwyQ0FBVSxFQUFDLE1BQUtrQjtJQUFFO0FBQUM7QUFBQyxTQUFTNEIsRUFBRTlDLENBQUMsRUFBQ0UsQ0FBQztJQUFFLE9BQU8sUUFBTUYsSUFBRTtRQUFDK0QsU0FBUS9ELEVBQUUrRCxPQUFPO1FBQUNDLGFBQVloRSxFQUFFaUUsS0FBSyxDQUFDRCxXQUFXO1FBQUNFLElBQUdsRSxFQUFFaUUsS0FBSyxDQUFDRSxPQUFPO1FBQUNDLE9BQU1wRSxFQUFFaUUsS0FBSyxDQUFDRyxLQUFLO1FBQUNiLE1BQUt2RCxFQUFFaUUsS0FBSyxDQUFDVixJQUFJO1FBQUNjLE1BQUtyRSxFQUFFaUUsS0FBSyxDQUFDSSxJQUFJLElBQUUsQ0FBQztRQUFFQyxXQUFVdEUsRUFBRWlFLEtBQUssQ0FBQ0ssU0FBUztRQUFDQyxNQUFLdkUsRUFBRWlFLEtBQUssQ0FBQ00sSUFBSTtRQUFDQyxRQUFPdEU7SUFBQyxJQUFFLENBQUM7QUFBQztBQUFDLE1BQU02QyxJQUFFO0lBQUMwQixNQUFLLElBQUlDO0lBQUlDLFdBQVUsSUFBSUQ7SUFBSUUsSUFBRzVFLENBQUMsRUFBQ0UsQ0FBQztRQUFFLE9BQU8sSUFBSSxDQUFDdUUsSUFBSSxDQUFDSSxHQUFHLENBQUM3RSxNQUFJLElBQUksQ0FBQ3lFLElBQUksQ0FBQ0ssR0FBRyxDQUFDOUUsR0FBRSxFQUFFLEdBQUUsSUFBSSxDQUFDeUUsSUFBSSxDQUFDTSxHQUFHLENBQUMvRSxHQUFHZ0YsSUFBSSxDQUFDOUUsSUFBRyxJQUFJO0lBQUE7SUFBRStFLEtBQUlqRixDQUFDLEVBQUNFLENBQUM7UUFBRSxJQUFHQSxHQUFFO1lBQUMsTUFBTUUsSUFBRSxJQUFJLENBQUNxRSxJQUFJLENBQUNNLEdBQUcsQ0FBQy9FLEdBQUdrRixNQUFNLENBQUNsRixDQUFBQSxJQUFHQSxNQUFJRTtZQUFHLE9BQU8sSUFBSSxDQUFDdUUsSUFBSSxDQUFDSyxHQUFHLENBQUM5RSxHQUFFSSxJQUFHLElBQUk7UUFBQTtRQUFDLE9BQU8sSUFBSSxDQUFDcUUsSUFBSSxDQUFDVSxNQUFNLENBQUNuRixJQUFHLElBQUk7SUFBQTtJQUFFb0YsWUFBV3BGLENBQUM7UUFBRSxNQUFNRSxJQUFFLElBQUksQ0FBQ3lFLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDL0U7UUFBRyxPQUFPRSxLQUFJQSxDQUFBQSxFQUFFbUYsT0FBTyxDQUFDQyxlQUFjLElBQUksQ0FBQ1gsU0FBUyxDQUFDUSxNQUFNLENBQUNuRixFQUFDLEdBQUcsSUFBSTtJQUFBO0lBQUV1RixNQUFLdkYsQ0FBQztRQUFFLElBQUksQ0FBQ3lFLElBQUksQ0FBQ0ksR0FBRyxDQUFDN0UsTUFBSSxJQUFJLENBQUN5RSxJQUFJLENBQUNNLEdBQUcsQ0FBQy9FLEdBQUdxRixPQUFPLENBQUNuRixDQUFBQTtZQUFJLE1BQU1FLElBQUU2QixXQUFXO2dCQUFLL0IsS0FBSyxFQUFFLENBQUNzRixLQUFLLENBQUNDLElBQUksQ0FBQ0MsV0FBVTtZQUFHLEdBQUU7WUFBRyxJQUFJLENBQUNmLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDN0UsTUFBSSxJQUFJLENBQUMyRSxTQUFTLENBQUNHLEdBQUcsQ0FBQzlFLEdBQUUsRUFBRSxHQUFFLElBQUksQ0FBQzJFLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDL0UsR0FBR2dGLElBQUksQ0FBQzVFO1FBQUU7SUFBRTtBQUFDLEdBQUU0QyxJQUFFOUMsQ0FBQUE7SUFBSSxJQUFHLEVBQUNrRSxPQUFNaEUsQ0FBQyxFQUFDbUQsTUFBS2pELENBQUMsRUFBQyxHQUFHRSxHQUFFLEdBQUNOO0lBQUUscUJBQU9GLGdEQUFlLENBQUMsT0FBTTtRQUFDMkYsU0FBUTtRQUFZQyxPQUFNO1FBQU8vRCxRQUFPO1FBQU9nRSxNQUFLLGNBQVl6RixJQUFFLGlCQUFlLDZCQUErQixPQUFGRSxHQUFFO1FBQUcsR0FBR0UsQ0FBQztJQUFBO0FBQUUsR0FBRXNGLElBQUU7SUFBQ0MsTUFBSyxTQUFTN0YsQ0FBQztRQUFFLHFCQUFPRixnREFBZSxDQUFDZ0QsR0FBRTtZQUFDLEdBQUc5QyxDQUFDO1FBQUEsaUJBQUVGLGdEQUFlLENBQUMsUUFBTztZQUFDb0IsR0FBRTtRQUErTztJQUFHO0lBQUU0RSxTQUFRLFNBQVM5RixDQUFDO1FBQUUscUJBQU9GLGdEQUFlLENBQUNnRCxHQUFFO1lBQUMsR0FBRzlDLENBQUM7UUFBQSxpQkFBRUYsZ0RBQWUsQ0FBQyxRQUFPO1lBQUNvQixHQUFFO1FBQTRlO0lBQUc7SUFBRTZFLFNBQVEsU0FBUy9GLENBQUM7UUFBRSxxQkFBT0YsZ0RBQWUsQ0FBQ2dELEdBQUU7WUFBQyxHQUFHOUMsQ0FBQztRQUFBLGlCQUFFRixnREFBZSxDQUFDLFFBQU87WUFBQ29CLEdBQUU7UUFBNEs7SUFBRztJQUFFOEUsT0FBTSxTQUFTaEcsQ0FBQztRQUFFLHFCQUFPRixnREFBZSxDQUFDZ0QsR0FBRTtZQUFDLEdBQUc5QyxDQUFDO1FBQUEsaUJBQUVGLGdEQUFlLENBQUMsUUFBTztZQUFDb0IsR0FBRTtRQUFvVTtJQUFHO0lBQUUrRSxTQUFRO1FBQVcscUJBQU9uRyxnREFBZSxDQUFDLE9BQU07WUFBQzRELFdBQVU7UUFBbUI7SUFBRTtBQUFDO0FBQUUsU0FBU3dDLEVBQUVwRyxDQUFDO0lBQUUsTUFBSyxHQUFFTSxFQUFFLEdBQUNNLGlEQUFDQSxDQUFDWixDQUFBQSxJQUFHQSxJQUFFLEdBQUUsSUFBRyxDQUFDZ0IsR0FBRUMsRUFBRSxHQUFDSCwrQ0FBQ0EsQ0FBQyxFQUFFLEdBQUVVLElBQUVwQiw2Q0FBQ0EsQ0FBQyxPQUFNOEIsSUFBRTlCLDZDQUFDQSxDQUFDLElBQUlzRSxLQUFLekIsT0FBTyxFQUFDRCxJQUFFaEQsQ0FBQUEsSUFBRyxDQUFDLE1BQUlnQixFQUFFcUYsT0FBTyxDQUFDckcsSUFBR29HLElBQUVoRyw2Q0FBQ0EsQ0FBQztRQUFDa0csVUFBUztRQUFFQyxnQkFBZTtRQUFFQyxPQUFNO1FBQUVDLE9BQU0sRUFBRTtRQUFDeEMsT0FBTWpFO1FBQUVnRSxhQUFZO1FBQUswQyxlQUFjMUQ7UUFBRTJELFVBQVMzRyxDQUFBQSxJQUFHa0MsRUFBRTZDLEdBQUcsQ0FBQy9FO0lBQUUsR0FBR2lELE9BQU87SUFBQyxTQUFTMkQsRUFBRTVHLENBQUM7UUFBRSxJQUFHLEVBQUNnRSxhQUFZOUQsQ0FBQyxFQUFDLEdBQUNGO1FBQUUsTUFBSyxFQUFDNkcsT0FBTXpHLENBQUMsRUFBQyxHQUFDZ0csRUFBRW5DLEtBQUs7UUFBQyxDQUFDN0QsS0FBR0YsS0FBR2tHLEVBQUVwQyxXQUFXLEtBQUc5RCxLQUFJa0csQ0FBQUEsRUFBRUksS0FBSyxJQUFFSixFQUFFSyxLQUFLLENBQUNLLE1BQU0sRUFBQ1YsRUFBRUssS0FBSyxHQUFDLEVBQUU7SUFBQztJQUFDLFNBQVNNLEVBQUUvRyxDQUFDO1FBQUVpQixFQUFFZixDQUFBQSxJQUFHLFFBQU1GLElBQUUsRUFBRSxHQUFDRSxFQUFFZ0YsTUFBTSxDQUFDaEYsQ0FBQUEsSUFBR0EsTUFBSUY7SUFBRztJQUFDLFNBQVNnSDtRQUFJLE1BQUssRUFBQ0MsY0FBYWpILENBQUMsRUFBQ2tILFlBQVdoSCxDQUFDLEVBQUNpSCxTQUFRL0csQ0FBQyxFQUFDLEdBQUNnRyxFQUFFSyxLQUFLLENBQUNXLEtBQUs7UUFBR0MsRUFBRXJILEdBQUVFLEdBQUVFO0lBQUU7SUFBQyxTQUFTa0gsRUFBRXRILENBQUMsRUFBQ0ksQ0FBQztRQUFFLElBQUcsRUFBQ21ILE9BQU0vRyxDQUFDLEVBQUMyRyxTQUFRdkcsQ0FBQyxFQUFDLEdBQUdFLEdBQUUsR0FBQ1Y7UUFBRSxJQUFHLENBQUNtQixFQUFFdkIsTUFBSSxTQUFTQSxDQUFDO1lBQUUsT0FBTSxDQUFDd0IsRUFBRXlCLE9BQU8sSUFBRW1ELEVBQUVuQyxLQUFLLENBQUN1RCxvQkFBb0IsSUFBRXhILEVBQUVnRSxXQUFXLEtBQUdvQyxFQUFFbkMsS0FBSyxDQUFDRCxXQUFXLElBQUU5QixFQUFFMkMsR0FBRyxDQUFDN0UsRUFBRW1FLE9BQU8sS0FBRyxRQUFNbkUsRUFBRXlILFFBQVE7UUFBQSxFQUFFM0csSUFBRztRQUFPLE1BQUssRUFBQ3FELFNBQVFuRCxDQUFDLEVBQUN5RyxVQUFTeEcsQ0FBQyxFQUFDb0QsTUFBS3JCLENBQUMsRUFBQyxHQUFDbEMsR0FBRSxFQUFDbUQsT0FBTTJDLENBQUMsRUFBQyxHQUFDUixHQUFFa0IsSUFBRSxJQUFJUCxFQUFFL0YsSUFBRzBHLElBQUUsUUFBTXpHO1FBQUV5RyxLQUFHdEIsRUFBRUksS0FBSztRQUFHLE1BQU1tQixJQUFFO1lBQUMsR0FBR2YsQ0FBQztZQUFDbEYsT0FBTWtGLEVBQUVnQixVQUFVO1lBQUNDLEtBQUl6QixFQUFFRSxRQUFRO1lBQUcsR0FBR3dCLE9BQU9DLFdBQVcsQ0FBQ0QsT0FBT0UsT0FBTyxDQUFDbEgsR0FBR29FLE1BQU0sQ0FBQ2xGLENBQUFBO2dCQUFJLElBQUcsQ0FBQ0UsR0FBRUUsRUFBRSxHQUFDSjtnQkFBRSxPQUFPLFFBQU1JO1lBQUMsR0FBRztZQUFDK0QsU0FBUW5EO1lBQUV5RyxVQUFTeEc7WUFBRW9ELE1BQUtyQjtZQUFFaUYsWUFBV1g7WUFBRXpFLE1BQUssQ0FBQztZQUFFZSxXQUFVdEMsRUFBRVIsRUFBRThDLFNBQVMsSUFBRWdELEVBQUVzQixjQUFjO1lBQUVDLGVBQWM3RyxFQUFFUixFQUFFcUgsYUFBYSxJQUFFdkIsRUFBRXVCLGFBQWE7WUFBRUMsbUJBQWtCOUcsRUFBRVIsRUFBRXNILGlCQUFpQixJQUFFeEIsRUFBRXdCLGlCQUFpQjtZQUFFQyxXQUFVLENBQUN2SCxFQUFFd0QsU0FBUyxJQUFHZ0UsQ0FBQUEsSUFBRXhILEVBQUV1SCxTQUFTLEVBQUNFLElBQUUzQixFQUFFeUIsU0FBUyxFQUFDLENBQUMsTUFBSUMsS0FBR3BILEVBQUVvSCxNQUFJQSxJQUFFLElBQUVBLElBQUVDLENBQUFBO1lBQUdDO2dCQUFjLE1BQU14SSxJQUFFOEMsRUFBRVosRUFBRTZDLEdBQUcsQ0FBQy9ELElBQUc7Z0JBQVdrQixFQUFFaUQsTUFBTSxDQUFDbkUsSUFBRytCLEVBQUV3QyxJQUFJLENBQUMsR0FBRXZGO2dCQUFHLE1BQU1FLElBQUVrRyxFQUFFSyxLQUFLLENBQUNLLE1BQU07Z0JBQUMsSUFBR1YsRUFBRUksS0FBSyxHQUFDLFFBQU14RixJQUFFb0YsRUFBRUksS0FBSyxHQUFDSixFQUFFRyxjQUFjLEdBQUNILEVBQUVJLEtBQUssR0FBQyxHQUFFSixFQUFFSSxLQUFLLEdBQUMsS0FBSUosQ0FBQUEsRUFBRUksS0FBSyxHQUFDLElBQUd0RyxJQUFFLEdBQUU7b0JBQUMsTUFBTUYsSUFBRSxRQUFNZ0IsSUFBRW9GLEVBQUVuQyxLQUFLLENBQUM0QyxLQUFLLEdBQUM7b0JBQUUsSUFBRyxNQUFJM0csS0FBRyxNQUFJRixHQUFFb0csRUFBRUcsY0FBYyxJQUFHUzt5QkFBUTt3QkFBQyxNQUFNNUcsSUFBRUosSUFBRUUsSUFBRUEsSUFBRUY7d0JBQUVvRyxFQUFFRyxjQUFjLEdBQUNuRzt3QkFBRSxJQUFJLElBQUlKLElBQUUsR0FBRUEsSUFBRUksR0FBRUosSUFBSWdIO29CQUFHO2dCQUFDLE9BQU0xRztZQUFHO1FBQUM7UUFBRSxJQUFJZ0ksR0FBRUM7UUFBRVosRUFBRWMsT0FBTyxHQUFDLFNBQVN6SSxDQUFDO1lBQUUsSUFBRyxFQUFDb0UsT0FBTWhFLENBQUMsRUFBQ21ELE1BQUtqRCxDQUFDLEVBQUNnRSxXQUFVOUQsQ0FBQyxFQUFDK0QsTUFBSzNELENBQUMsRUFBQyxHQUFDWixHQUFFYyxJQUFFO1lBQUssTUFBTUUsSUFBRTtnQkFBQ29ELE9BQU1oRTtnQkFBRW1ELE1BQUtqRDtZQUFDO1lBQUUsT0FBTSxDQUFDLE1BQUlNLEtBQUlTLENBQUFBLEVBQUVULEtBQUdFLElBQUVGLEVBQUVJLG1CQUFHZCxxREFBQ0EsQ0FBQ1UsS0FBR0Usa0JBQUVKLG1EQUFDQSxDQUFDRSxHQUFFSSxLQUFHSSxFQUFFUixNQUFJTSxFQUFFTixLQUFHRSxJQUFFRixJQUFFSixJQUFFTSxJQUFFZ0YsRUFBRUssT0FBTyxLQUFHLENBQUNuRyxDQUFBQSxJQUFHQSxLQUFLOEYsQ0FBQUEsRUFBR3hGLE1BQUtRLENBQUFBLElBQUVnRixDQUFDLENBQUN4RixFQUFFLENBQUNVLEVBQUMsQ0FBQyxHQUFHRjtRQUFDLEVBQUU2RyxJQUFHdEcsRUFBRVAsRUFBRTRILE1BQU0sS0FBSWYsQ0FBQUEsRUFBRWUsTUFBTSxHQUFDNUgsRUFBRTRILE1BQU0sR0FBRXJILEVBQUVQLEVBQUU2SCxPQUFPLEtBQUloQixDQUFBQSxFQUFFZ0IsT0FBTyxHQUFDN0gsRUFBRTZILE9BQU8sR0FBRWhCLEVBQUVpQixXQUFXLEdBQUNoQyxFQUFFZ0MsV0FBVyxFQUFDLENBQUMsTUFBSTlILEVBQUU4SCxXQUFXLElBQUVySCxFQUFFVCxFQUFFOEgsV0FBVyxJQUFFakIsRUFBRWlCLFdBQVcsR0FBQzlILEVBQUU4SCxXQUFXLEdBQUMsQ0FBQyxNQUFJOUgsRUFBRThILFdBQVcsSUFBR2pCLENBQUFBLEVBQUVpQixXQUFXLEdBQUMsQ0FBQ3JILEVBQUVxRixFQUFFZ0MsV0FBVyxLQUFHaEMsRUFBRWdDLFdBQVc7UUFBRSxJQUFJQyxJQUFFN0k7c0JBQUVFLHFEQUFDQSxDQUFDRixNQUFJLENBQUNvQixFQUFFcEIsRUFBRXVELElBQUksSUFBRXNGLGtCQUFFbkksbURBQUNBLENBQUNWLEdBQUU7WUFBQ2lJLFlBQVdYO1lBQUVKLFlBQVdTO1lBQUV0RCxNQUFLckI7UUFBQyxLQUFHM0IsRUFBRXJCLE1BQUs2SSxDQUFBQSxJQUFFN0ksRUFBRTtZQUFDaUksWUFBV1g7WUFBRUosWUFBV1M7WUFBRXRELE1BQUtyQjtRQUFDLEVBQUMsR0FBRzRELEVBQUVDLEtBQUssSUFBRUQsRUFBRUMsS0FBSyxHQUFDLEtBQUdULEVBQUVJLEtBQUssR0FBQ0ksRUFBRUMsS0FBSyxJQUFFYSxJQUFFdEIsRUFBRUssS0FBSyxDQUFDekIsSUFBSSxDQUFDO1lBQUNpQyxjQUFhNEI7WUFBRTNCLFlBQVdTO1lBQUVSLFNBQVF2RztRQUFDLEtBQUdNLEVBQUVWLEtBQUd5QixXQUFXO1lBQUtvRixFQUFFd0IsR0FBRWxCLEdBQUUvRztRQUFFLEdBQUVKLEtBQUc2RyxFQUFFd0IsR0FBRWxCLEdBQUUvRztJQUFFO0lBQUMsU0FBU3lHLEVBQUVySCxDQUFDLEVBQUNFLENBQUMsRUFBQ0UsQ0FBQztRQUFFLE1BQUssRUFBQytELFNBQVE3RCxDQUFDLEVBQUMsR0FBQ0o7UUFBRUUsS0FBRzhCLEVBQUVpRCxNQUFNLENBQUMvRTtRQUFHLE1BQU1JLElBQUU7WUFBQ3VELFNBQVEvRDtZQUFFaUUsT0FBTS9EO1FBQUM7UUFBRWdDLEVBQUU0QyxHQUFHLENBQUN4RSxHQUFFRSxJQUFHUyxFQUFFakIsQ0FBQUEsSUFBRzttQkFBSUE7Z0JBQUVNO2FBQUUsQ0FBQzRFLE1BQU0sQ0FBQ2xGLENBQUFBLElBQUdBLE1BQUlJLEtBQUkyQyxFQUFFd0MsSUFBSSxDQUFDLEdBQUV6QyxFQUFFdEMsR0FBRSxRQUFNQSxFQUFFeUQsS0FBSyxDQUFDd0QsUUFBUSxHQUFDLFVBQVE7SUFBVztJQUFDLE9BQU9qSCxnREFBQ0EsQ0FBQyxJQUFLNEYsQ0FBQUEsRUFBRXBDLFdBQVcsR0FBQ2hFLEVBQUVnRSxXQUFXLEVBQUNqQixFQUFFcUMsVUFBVSxDQUFDLEdBQUdSLEVBQUUsQ0FBQyxHQUFFMEMsR0FBRzFDLEVBQUUsQ0FBQyxHQUFFNUUsQ0FBQUEsSUFBR3dCLEVBQUV5QixPQUFPLElBQUU4RCxFQUFFL0csSUFBSTRFLEVBQUUsQ0FBQyxHQUFFZ0MsR0FBR3JCLElBQUksQ0FBQyxHQUFFYSxJQUFHO1lBQUtsRSxFQUFFNEcsS0FBSyxJQUFHL0YsRUFBRXdDLElBQUksQ0FBQyxHQUFFYTtRQUFFLElBQUcsRUFBRSxHQUFFNUYsZ0RBQUNBLENBQUM7UUFBSzRGLEVBQUVuQyxLQUFLLEdBQUNqRSxHQUFFb0csRUFBRU0sYUFBYSxHQUFDMUQsR0FBRW9ELEVBQUVHLGNBQWMsR0FBQ3ZGLEVBQUU4RixNQUFNO0lBQUEsSUFBRztRQUFDaUMsa0JBQWlCLFNBQVM3SSxDQUFDO1lBQUUsTUFBTUUsSUFBRSxJQUFJc0UsS0FBSXBFLElBQUUwSSxNQUFNQyxJQUFJLENBQUMvRyxFQUFFZ0gsTUFBTTtZQUFJLE9BQU9sSixFQUFFbUosV0FBVyxJQUFFN0ksRUFBRThJLE9BQU8sSUFBRzlJLEVBQUUrRSxPQUFPLENBQUNyRixDQUFBQTtnQkFBSSxNQUFLLEVBQUN5QyxVQUFTdkMsQ0FBQyxFQUFDLEdBQUNGLEVBQUVpRSxLQUFLO2dCQUFDN0QsRUFBRXlFLEdBQUcsQ0FBQzNFLE1BQUlFLEVBQUUwRSxHQUFHLENBQUM1RSxHQUFFLEVBQUUsR0FBRUUsRUFBRTJFLEdBQUcsQ0FBQzdFLEdBQUc4RSxJQUFJLENBQUNoRjtZQUFFLElBQUdnSixNQUFNQyxJQUFJLENBQUM3SSxHQUFFSixDQUFBQSxJQUFHRSxFQUFFRixDQUFDLENBQUMsRUFBRSxFQUFDQSxDQUFDLENBQUMsRUFBRTtRQUFFO1FBQUVxSixjQUFhN0g7UUFBRWtGLGVBQWMxRDtJQUFDO0FBQUM7S0FBcnZGb0Q7QUFBc3ZGLFNBQVNRLEVBQUU1RyxDQUFDO0lBQUUsT0FBT0EsRUFBRXNKLGFBQWEsSUFBRXRKLEVBQUVzSixhQUFhLENBQUN4QyxNQUFNLElBQUUsSUFBRTlHLEVBQUVzSixhQUFhLENBQUMsRUFBRSxDQUFDQyxPQUFPLEdBQUN2SixFQUFFdUosT0FBTztBQUFBO0FBQUMsU0FBU3hDLEVBQUUvRyxDQUFDO0lBQUUsT0FBT0EsRUFBRXNKLGFBQWEsSUFBRXRKLEVBQUVzSixhQUFhLENBQUN4QyxNQUFNLElBQUUsSUFBRTlHLEVBQUVzSixhQUFhLENBQUMsRUFBRSxDQUFDRSxPQUFPLEdBQUN4SixFQUFFd0osT0FBTztBQUFBO01BQTNGekM7QUFBNEYsU0FBU0MsRUFBRWhILENBQUM7SUFBRSxNQUFLLENBQUNNLEdBQUVJLEVBQUUsR0FBQ0ksK0NBQUNBLENBQUMsQ0FBQyxJQUFHLENBQUNGLEdBQUVJLEVBQUUsR0FBQ0YsK0NBQUNBLENBQUMsQ0FBQyxJQUFHRyxJQUFFYiw2Q0FBQ0EsQ0FBQyxPQUFNYyxJQUFFZCw2Q0FBQ0EsQ0FBQztRQUFDcUosT0FBTTtRQUFFWixHQUFFO1FBQUUvRixHQUFFO1FBQUU0RyxPQUFNO1FBQUVDLGlCQUFnQjtRQUFFQyxpQkFBZ0IsQ0FBQztRQUFFQyxTQUFRLENBQUM7UUFBRUMsY0FBYTtRQUFLQyxTQUFRLENBQUM7SUFBQyxHQUFHOUcsT0FBTyxFQUFDN0IsSUFBRWhCLDZDQUFDQSxDQUFDSixJQUFHLEVBQUNxSSxXQUFVL0csQ0FBQyxFQUFDMEksY0FBYXpJLENBQUMsRUFBQzBHLFlBQVd6RyxDQUFDLEVBQUN5SSxTQUFRL0gsQ0FBQyxFQUFDZ0ksY0FBYXBILENBQUMsRUFBQyxHQUFDOUM7SUFBRSxTQUFTK0MsRUFBRTdDLENBQUM7UUFBRSxJQUFHRixFQUFFbUssU0FBUyxFQUFDO1lBQUMsaUJBQWVqSyxFQUFFa0ssV0FBVyxDQUFDN0csSUFBSSxJQUFFckQsRUFBRWtLLFdBQVcsQ0FBQ0MsY0FBYyxJQUFHbkosRUFBRTZJLE9BQU8sR0FBQyxDQUFDLEdBQUVPLFNBQVMzRyxnQkFBZ0IsQ0FBQyxhQUFZcUQsSUFBR3NELFNBQVMzRyxnQkFBZ0IsQ0FBQyxXQUFVMkQsSUFBR2dELFNBQVMzRyxnQkFBZ0IsQ0FBQyxhQUFZcUQsSUFBR3NELFNBQVMzRyxnQkFBZ0IsQ0FBQyxZQUFXMkQ7WUFBRyxNQUFNbEgsSUFBRWEsRUFBRWdDLE9BQU87WUFBQy9CLEVBQUUwSSxlQUFlLEdBQUMsQ0FBQyxHQUFFMUksRUFBRTJJLE9BQU8sR0FBQyxDQUFDLEdBQUUzSSxFQUFFNEksWUFBWSxHQUFDMUosRUFBRW1LLHFCQUFxQixJQUFHbkssRUFBRXNCLEtBQUssQ0FBQ0ksVUFBVSxHQUFDLElBQUdaLEVBQUUySCxDQUFDLEdBQUNqQyxFQUFFMUcsRUFBRWtLLFdBQVcsR0FBRWxKLEVBQUU0QixDQUFDLEdBQUNpRSxFQUFFN0csRUFBRWtLLFdBQVcsR0FBRSxRQUFNcEssRUFBRXdLLGtCQUFrQixHQUFFdEosQ0FBQUEsRUFBRXVJLEtBQUssR0FBQ3ZJLEVBQUUySCxDQUFDLEVBQUMzSCxFQUFFeUksZUFBZSxHQUFDdkosRUFBRXFLLFdBQVcsR0FBRXpLLENBQUFBLEVBQUUwSyxnQkFBZ0IsR0FBQyxHQUFFLENBQUMsSUFBSXhKLENBQUFBLEVBQUV1SSxLQUFLLEdBQUN2SSxFQUFFNEIsQ0FBQyxFQUFDNUIsRUFBRXlJLGVBQWUsR0FBQ3ZKLEVBQUV1SyxZQUFZLEdBQUUsUUFBSzNLLEVBQUUwSyxnQkFBZ0IsR0FBQyxNQUFJMUssRUFBRTBLLGdCQUFnQixHQUFDMUssRUFBRTBLLGdCQUFnQixHQUFDLEdBQUUsQ0FBQztRQUFFO0lBQUM7SUFBQyxTQUFTMUgsRUFBRTlDLENBQUM7UUFBRSxJQUFHZ0IsRUFBRTRJLFlBQVksRUFBQztZQUFDLE1BQUssRUFBQ2MsS0FBSXhLLENBQUMsRUFBQ3lLLFFBQU92SyxDQUFDLEVBQUN3SyxNQUFLdEssQ0FBQyxFQUFDdUssT0FBTXJLLENBQUMsRUFBQyxHQUFDUSxFQUFFNEksWUFBWTtZQUFDLGVBQWE1SixFQUFFa0ssV0FBVyxDQUFDN0csSUFBSSxJQUFFdkQsRUFBRWdLLFlBQVksSUFBRTlJLEVBQUUySCxDQUFDLElBQUVySSxLQUFHVSxFQUFFMkgsQ0FBQyxJQUFFbkksS0FBR1EsRUFBRTRCLENBQUMsSUFBRTFDLEtBQUdjLEVBQUU0QixDQUFDLElBQUV4QyxJQUFFOEYsTUFBSU47UUFBRztJQUFDO0lBQUMsU0FBU0E7UUFBSXBGLEVBQUUsQ0FBQztJQUFFO0lBQUMsU0FBUzBGO1FBQUkxRixFQUFFLENBQUM7SUFBRTtJQUFDLFNBQVNzRyxFQUFFOUcsQ0FBQztRQUFFLE1BQU1FLElBQUVhLEVBQUVnQyxPQUFPO1FBQUMvQixFQUFFMkksT0FBTyxJQUFFekosS0FBSWMsQ0FBQUEsRUFBRTZJLE9BQU8sR0FBQyxDQUFDLEdBQUV6SixLQUFHOEYsS0FBSWxGLEVBQUUySCxDQUFDLEdBQUNqQyxFQUFFMUcsSUFBR2dCLEVBQUU0QixDQUFDLEdBQUNpRSxFQUFFN0csSUFBR2dCLEVBQUV3SSxLQUFLLEdBQUMsUUFBTTFKLEVBQUV3SyxrQkFBa0IsR0FBQ3RKLEVBQUUySCxDQUFDLEdBQUMzSCxFQUFFdUksS0FBSyxHQUFDdkksRUFBRTRCLENBQUMsR0FBQzVCLEVBQUV1SSxLQUFLLEVBQUN2SSxFQUFFdUksS0FBSyxLQUFHdkksRUFBRTJILENBQUMsSUFBRzNILENBQUFBLEVBQUUwSSxlQUFlLEdBQUMsQ0FBQyxJQUFHeEosRUFBRXNCLEtBQUssQ0FBQ3NKLFNBQVMsR0FBQyxZQUFvQzlKLE9BQXhCbEIsRUFBRXdLLGtCQUFrQixFQUFDLEtBQVcsT0FBUnRKLEVBQUV3SSxLQUFLLEVBQUMsUUFBS3RKLEVBQUVzQixLQUFLLENBQUN1SixPQUFPLEdBQUMsS0FBSSxLQUFFQyxLQUFLQyxHQUFHLENBQUNqSyxFQUFFd0ksS0FBSyxHQUFDeEksRUFBRXlJLGVBQWUsRUFBQztJQUFFO0lBQUMsU0FBU3JDO1FBQUlnRCxTQUFTaEgsbUJBQW1CLENBQUMsYUFBWTBELElBQUdzRCxTQUFTaEgsbUJBQW1CLENBQUMsV0FBVWdFLElBQUdnRCxTQUFTaEgsbUJBQW1CLENBQUMsYUFBWTBELElBQUdzRCxTQUFTaEgsbUJBQW1CLENBQUMsWUFBV2dFO1FBQUcsTUFBTXBILElBQUVlLEVBQUVnQyxPQUFPO1FBQUMsSUFBRy9CLEVBQUUySSxPQUFPLElBQUUzSSxFQUFFNkksT0FBTyxJQUFFN0osR0FBRTtZQUFDLElBQUdnQixFQUFFMkksT0FBTyxHQUFDLENBQUMsR0FBRXFCLEtBQUtDLEdBQUcsQ0FBQ2pLLEVBQUV3SSxLQUFLLElBQUV4SSxFQUFFeUksZUFBZSxFQUFDLE9BQU8zSSxFQUFFLENBQUMsSUFBRyxLQUFLaEIsRUFBRWlJLFVBQVU7WUFBRy9ILEVBQUV3QixLQUFLLENBQUNJLFVBQVUsR0FBQyxnQ0FBK0I1QixFQUFFd0IsS0FBSyxDQUFDc0osU0FBUyxHQUFDLFlBQWlDLE9BQXJCaEwsRUFBRXdLLGtCQUFrQixFQUFDLFFBQUt0SyxFQUFFd0IsS0FBSyxDQUFDdUosT0FBTyxHQUFDO1FBQUc7SUFBQztJQUFDekssZ0RBQUNBLENBQUM7UUFBS1ksRUFBRTZCLE9BQU8sR0FBQ2pEO0lBQUMsSUFBR1EsZ0RBQUNBLENBQUMsSUFBS1MsQ0FBQUEsRUFBRWdDLE9BQU8sSUFBRWhDLEVBQUVnQyxPQUFPLENBQUNVLGdCQUFnQixDQUFDLEtBQUltQyxHQUFFO1lBQUNzRixNQUFLLENBQUM7UUFBQyxJQUFHL0osRUFBRXJCLEVBQUUwSSxNQUFNLEtBQUcxSSxFQUFFMEksTUFBTSxlQUFDeEkscURBQUNBLENBQUNGLEVBQUV3QyxRQUFRLEtBQUd4QyxFQUFFd0MsUUFBUSxDQUFDeUIsS0FBSyxHQUFFO1lBQUssTUFBTWpFLElBQUVvQixFQUFFNkIsT0FBTztZQUFDNUIsRUFBRXJCLEVBQUUySSxPQUFPLEtBQUczSSxFQUFFMkksT0FBTyxlQUFDekkscURBQUNBLENBQUNGLEVBQUV3QyxRQUFRLEtBQUd4QyxFQUFFd0MsUUFBUSxDQUFDeUIsS0FBSztRQUFDLElBQUcsRUFBRSxHQUFFekQsZ0RBQUNBLENBQUMsSUFBS1IsQ0FBQUEsRUFBRXFMLGdCQUFnQixJQUFHZixDQUFBQSxTQUFTZ0IsUUFBUSxNQUFJbEYsS0FBSW1GLE9BQU81SCxnQkFBZ0IsQ0FBQyxTQUFRbUMsSUFBR3lGLE9BQU81SCxnQkFBZ0IsQ0FBQyxRQUFPeUMsRUFBQyxHQUFHO1lBQUtwRyxFQUFFcUwsZ0JBQWdCLElBQUdFLENBQUFBLE9BQU9qSSxtQkFBbUIsQ0FBQyxTQUFRd0MsSUFBR3lGLE9BQU9qSSxtQkFBbUIsQ0FBQyxRQUFPOEMsRUFBQztRQUFFLElBQUc7UUFBQ3BHLEVBQUVxTCxnQkFBZ0I7S0FBQztJQUFFLE1BQU1oRSxJQUFFO1FBQUNtRSxhQUFZekk7UUFBRTBJLGNBQWExSTtRQUFFMkksV0FBVTFJO1FBQUUySSxZQUFXM0k7SUFBQztJQUFFLE9BQU8xQixLQUFHQyxLQUFJOEYsQ0FBQUEsRUFBRXVFLFlBQVksR0FBQ3hGLEdBQUVpQixFQUFFd0UsWUFBWSxHQUFDL0YsQ0FBQUEsR0FBR2hELEtBQUl1RSxDQUFBQSxFQUFFNEMsT0FBTyxHQUFDakssQ0FBQUE7UUFBSWtDLEtBQUdBLEVBQUVsQyxJQUFHa0IsRUFBRTBJLGVBQWUsSUFBRXBJO0lBQUcsSUFBRztRQUFDc0ssV0FBVWhHO1FBQUVpRyxZQUFXM0Y7UUFBRTRGLFdBQVUxTDtRQUFFb0MsdUJBQXNCOUI7UUFBRXFMLFVBQVNoTDtRQUFFaUwsZUFBYzdFO0lBQUM7QUFBQztBQUFDLFNBQVNDLEVBQUVwSCxDQUFDO0lBQUUsSUFBRyxFQUFDK0gsWUFBVzdILENBQUMsRUFBQ2dFLE9BQU05RCxDQUFDLEVBQUM2TCxXQUFVM0wsSUFBRSxPQUFPLEVBQUMsR0FBQ047SUFBRSxxQkFBT0YsZ0RBQWUsQ0FBQyxVQUFTO1FBQUM0RCxXQUFVLGtEQUFvRCxPQUFGdEQ7UUFBSWlELE1BQUs7UUFBUzBHLFNBQVFqSyxDQUFBQTtZQUFJQSxFQUFFb00sZUFBZSxJQUFHaE0sRUFBRUo7UUFBRTtRQUFFLGNBQWFRO0lBQUMsaUJBQUVSLGdEQUFlLENBQUMsT0FBTTtRQUFDLGVBQWM7UUFBTzJGLFNBQVE7SUFBVyxpQkFBRTNGLGdEQUFlLENBQUMsUUFBTztRQUFDcU0sVUFBUztRQUFVakwsR0FBRTtJQUEwSDtBQUFJO01BQXRja0c7QUFBdWMsU0FBU0QsRUFBRW5ILENBQUM7SUFBRSxJQUFHLEVBQUNxSCxPQUFNbkgsQ0FBQyxFQUFDNEwsV0FBVTFMLENBQUMsRUFBQzJILFlBQVd6SCxDQUFDLEVBQUMrQyxNQUFLN0MsSUFBRSxTQUFTLEVBQUM0TCxNQUFLMUwsQ0FBQyxFQUFDZ0QsV0FBVTlDLENBQUMsRUFBQ1ksT0FBTVYsQ0FBQyxFQUFDdUwsb0JBQW1CckwsQ0FBQyxFQUFDc0wsVUFBU3BMLENBQUMsRUFBQ3FMLEtBQUluTCxDQUFDLEVBQUN1QixNQUFLdEIsQ0FBQyxFQUFDNkMsT0FBTTVDLENBQUMsRUFBQyxHQUFDdEI7SUFBRSxNQUFNZ0MsSUFBRXRCLEtBQUdNLEtBQUcsTUFBSUUsR0FBRTBCLElBQUU7UUFBQyxHQUFHOUIsQ0FBQztRQUFDMEwsbUJBQWtCLEdBQUssT0FBRnRNLEdBQUU7UUFBSXVNLG9CQUFtQnJNLElBQUUsWUFBVTtRQUFTMkssU0FBUS9JLElBQUUsSUFBRTtJQUFDO0lBQUVoQixLQUFJNEIsQ0FBQUEsRUFBRWtJLFNBQVMsR0FBQyxVQUFZLE9BQUY1SixHQUFFLElBQUM7SUFBRyxNQUFNMkIsSUFBRTlCLGdEQUFDQSxDQUFDLDBCQUF5QkMsSUFBRSx1Q0FBcUMsb0NBQW1DLGlDQUFtQyxPQUFGTSxJQUFJLDJCQUE2QixPQUFGZCxJQUFJO1FBQUMsK0JBQThCWTtJQUFDLElBQUcwQixJQUFFM0IsRUFBRVAsS0FBR0EsRUFBRTtRQUFDMkwsS0FBSW5MO1FBQUVpQyxNQUFLN0M7UUFBRWtNLGtCQUFpQjdKO0lBQUMsS0FBRzlCLGdEQUFDQSxDQUFDOEIsR0FBRWpDO0lBQUcscUJBQU9kLGdEQUFlLENBQUMsT0FBTTtRQUFDNk0sTUFBSztRQUFjLGVBQWMzSyxJQUFFLFNBQU87UUFBUSxjQUFhO1FBQXFCMEIsV0FBVVo7UUFBRXRCLE9BQU1vQjtRQUFFLENBQUM1QixLQUFHRSxLQUFHLElBQUUsb0JBQWtCLGlCQUFpQixFQUFDRixLQUFHRSxJQUFFLElBQUUsT0FBSztZQUFLRyxLQUFHZjtRQUFHO0lBQUM7QUFBRTtNQUFodkI2RztBQUFpdkIsTUFBTUssSUFBRXRILENBQUFBO0lBQUksTUFBSyxFQUFDNEwsV0FBVTFMLENBQUMsRUFBQ29DLHVCQUFzQmxDLENBQUMsRUFBQ3lMLFVBQVNyTCxDQUFDLEVBQUNzTCxlQUFjcEwsQ0FBQyxFQUFDLEdBQUNrRyxFQUFFNUcsSUFBRyxFQUFDd0ksYUFBWTVILENBQUMsRUFBQ3dCLFVBQVN0QixDQUFDLEVBQUNtSCxXQUFVakgsQ0FBQyxFQUFDNkksU0FBUTNJLENBQUMsRUFBQ2lDLE1BQUtoQyxDQUFDLEVBQUN1TCxpQkFBZ0J0TCxDQUFDLEVBQUN5RyxZQUFXL0YsQ0FBQyxFQUFDSixZQUFXZ0IsQ0FBQyxFQUFDTCxVQUFTTSxDQUFDLEVBQUNhLFdBQVVaLENBQUMsRUFBQ3RCLE9BQU1vRSxDQUFDLEVBQUNxQyxlQUFjL0IsQ0FBQyxFQUFDMkcsV0FBVW5HLENBQUMsRUFBQ3dCLG1CQUFrQnJCLENBQUMsRUFBQ2lHLGVBQWN0RixDQUFDLEVBQUNELFVBQVNFLENBQUMsRUFBQ2tGLE1BQUt2RSxDQUFDLEVBQUNrRSxVQUFTakUsQ0FBQyxFQUFDa0UsS0FBSTVELENBQUMsRUFBQzFFLFNBQVE4SSxDQUFDLEVBQUN6RSxhQUFZMEUsQ0FBQyxFQUFDckssTUFBS3NLLENBQUMsRUFBQzdJLFdBQVU4SSxDQUFDLEVBQUMzRSxTQUFRNEUsQ0FBQyxFQUFDbkQsY0FBYW9ELENBQUMsRUFBQ2xKLE9BQU1tSixDQUFDLEVBQUMsR0FBQ25OLEdBQUVvTixJQUFFdk0sZ0RBQUNBLENBQUMsbUJBQWtCLDBCQUE0QixPQUFGc00sSUFBSSxvQkFBc0IsT0FBRmhNLElBQUk7UUFBQyx3QkFBdUJzSDtJQUFDLEdBQUU7UUFBQyxtQ0FBa0N5RTtJQUFDLElBQUdHLElBQUVwTSxFQUFFMkIsS0FBR0EsRUFBRTtRQUFDeUosS0FBSTVEO1FBQUVwRyxVQUFTTTtRQUFFUSxNQUFLaEM7UUFBRXFMLGtCQUFpQlk7SUFBQyxLQUFHdk0sZ0RBQUNBLENBQUN1TSxHQUFFeEssSUFBRzBLLElBQUUsQ0FBQyxDQUFDbkYsS0FBRyxDQUFDbkgsR0FBRXVNLElBQUU7UUFBQzFGLFlBQVcvRjtRQUFFcUIsTUFBS2hDO1FBQUU2QyxPQUFNbUo7SUFBQztJQUFFLElBQUlLLElBQUU7SUFBSyxPQUFNLENBQUMsTUFBSTVNLEtBQUk0TSxDQUFBQSxJQUFFdk0sRUFBRUwsS0FBR0EsRUFBRTJNLG1CQUFHek4scURBQUNBLENBQUNjLG1CQUFHTixtREFBQ0EsQ0FBQ00sR0FBRTJNLEtBQUdyRyxFQUFFcUcsRUFBQyxpQkFBRzNOLGdEQUFlLENBQUM4QyxHQUFFO1FBQUNELE1BQUtzSztRQUFFeEssTUFBS3VLO1FBQUV6SyxVQUFTTTtRQUFFTCx1QkFBc0JsQztRQUFFb0MsU0FBUWhDO0lBQUMsaUJBQUVaLGdEQUFlLENBQUMsT0FBTTtRQUFDa0UsSUFBRytJO1FBQUVoRCxTQUFRM0k7UUFBRXNDLFdBQVU2SjtRQUFFLEdBQUczTSxDQUFDO1FBQUNZLE9BQU1vRTtRQUFFK0gsS0FBSWpOO0lBQUMsaUJBQUVaLGdEQUFlLENBQUMsT0FBTTtRQUFDLEdBQUdtTixLQUFHO1lBQUNOLE1BQUt2RTtRQUFDLENBQUM7UUFBQzFFLFdBQVV2QyxFQUFFK0UsS0FBR0EsRUFBRTtZQUFDN0MsTUFBS2hDO1FBQUMsS0FBR04sZ0RBQUNBLENBQUMsd0JBQXVCbUY7UUFBRzFFLE9BQU1rRjtJQUFDLEdBQUUsUUFBTXlHLG1CQUFHck4sZ0RBQWUsQ0FBQyxPQUFNO1FBQUM0RCxXQUFVM0MsZ0RBQUNBLENBQUMsd0JBQXVCO1lBQUMsK0NBQThDLENBQUNtTTtRQUFDO0lBQUUsR0FBRUMsa0JBQUdyTixnREFBZSxDQUFDLE9BQU0sTUFBS2tCLEtBQUkwTSxpQkFBRTVOLGdEQUFlLENBQUNxSCxHQUFFO1FBQUMsR0FBR00sS0FBRyxDQUFDK0YsSUFBRTtZQUFDN0YsS0FBSSxNQUFRLE9BQUZGO1FBQUcsSUFBRSxDQUFDLENBQUM7UUFBQzhFLEtBQUk1RDtRQUFFekUsT0FBTW1KO1FBQUVoRyxPQUFNbkc7UUFBRTRLLFdBQVUxTDtRQUFFdUMsTUFBS3NLO1FBQUVsRixZQUFXL0Y7UUFBRW9LLE1BQUs5SztRQUFFK0IsTUFBS2hDO1FBQUVHLE9BQU1nRztRQUFFOUQsV0FBVW1EO1FBQUV3RixvQkFBbUJtQjtRQUFFbEIsVUFBU2pFLEtBQUc7SUFBQztBQUFJLEdBQUVaLElBQUUsU0FBUzNILENBQUMsRUFBQ0UsQ0FBQztJQUFFLE9BQU8sS0FBSyxNQUFJQSxLQUFJQSxDQUFBQSxJQUFFLENBQUMsSUFBRztRQUFDaUMsT0FBTSwrQkFBaUMsT0FBRm5DLEdBQUU7UUFBUW9DLE1BQUssK0JBQWlDLE9BQUZwQyxHQUFFO1FBQU9xQyxnQkFBZW5DO0lBQUM7QUFBQyxHQUFFb0ksSUFBRXBHLEVBQUV5RixFQUFFLFVBQVMsQ0FBQyxLQUFJWSxJQUFFckcsRUFBRXlGLEVBQUUsU0FBUSxDQUFDLEtBQUlrQixJQUFFM0csRUFBRXlGLEVBQUUsVUFBU3NGLElBQUUvSyxFQUFFeUYsRUFBRSxVQUFTdUYsa0JBQUVsTSxpREFBQ0EsQ0FBQyxDQUFDZCxHQUFFRTtJQUFLLE1BQUssRUFBQzJJLGtCQUFpQnpJLENBQUMsRUFBQytJLGNBQWEzSSxDQUFDLEVBQUNnRyxlQUFjOUYsQ0FBQyxFQUFDLEdBQUN3RixFQUFFbEcsSUFBRyxFQUFDMEQsV0FBVTlDLENBQUMsRUFBQ1ksT0FBTVYsQ0FBQyxFQUFDeUwsS0FBSXZMLENBQUMsRUFBQzhDLGFBQVk1QyxDQUFDLEVBQUMsR0FBQ2xCO0lBQUUsU0FBU3FCLEVBQUV2QixDQUFDO1FBQUUsTUFBTUUsSUFBRWUsZ0RBQUNBLENBQUMsNkJBQTRCLDhCQUFnQyxPQUFGakIsSUFBSTtZQUFDLGtDQUFpQ2tCO1FBQUM7UUFBRyxPQUFPRyxFQUFFUCxLQUFHQSxFQUFFO1lBQUMyQixVQUFTekM7WUFBRXlNLEtBQUl2TDtZQUFFMEwsa0JBQWlCMU07UUFBQyxLQUFHZSxnREFBQ0EsQ0FBQ2YsR0FBRW9CLEVBQUVSO0lBQUc7SUFBQyxPQUFPTixnREFBQ0EsQ0FBQztRQUFLSixLQUFJQSxDQUFBQSxFQUFFNkMsT0FBTyxHQUFDdkMsRUFBRXVDLE9BQU87SUFBQyxHQUFFLEVBQUUsaUJBQUVqRCxnREFBZSxDQUFDLE9BQU07UUFBQzZOLEtBQUluTjtRQUFFa0QsV0FBVTtRQUFXTSxJQUFHOUM7SUFBQyxHQUFFZCxFQUFFLENBQUNKLEdBQUVFO1FBQUssTUFBTUUsSUFBRUYsRUFBRTBHLE1BQU0sR0FBQztZQUFDLEdBQUc5RixDQUFDO1FBQUEsSUFBRTtZQUFDLEdBQUdBLENBQUM7WUFBQzhNLGVBQWM7UUFBTTtRQUFFLHFCQUFPOU4sZ0RBQWUsQ0FBQyxPQUFNO1lBQUM0RCxXQUFVckMsRUFBRXJCO1lBQUd3QixPQUFNcEI7WUFBRXVILEtBQUksYUFBZSxPQUFGM0g7UUFBRyxHQUFFRSxFQUFFMk4sR0FBRyxDQUFDLENBQUM3TixHQUFFSTtZQUFLLElBQUcsRUFBQ3lELFNBQVF2RCxDQUFDLEVBQUN5RCxPQUFNdkQsQ0FBQyxFQUFDLEdBQUNSO1lBQUUscUJBQU9GLGdEQUFlLENBQUMwSCxHQUFFO2dCQUFDLEdBQUdoSCxDQUFDO2dCQUFDbUMsTUFBS2pDLEVBQUVGLEVBQUV5RCxPQUFPO2dCQUFFekMsT0FBTTtvQkFBQyxHQUFHaEIsRUFBRWdCLEtBQUs7b0JBQUMsU0FBUXBCLElBQUU7b0JBQUUsU0FBUUYsRUFBRTBHLE1BQU07Z0JBQUE7Z0JBQUVlLEtBQUksU0FBZSxPQUFObkgsRUFBRW1ILEdBQUc7WUFBRSxHQUFFckg7UUFBRTtJQUFHO0FBQUc7QUFBRzBNLEVBQUVjLFdBQVcsR0FBQyxrQkFBaUJkLEVBQUVlLFlBQVksR0FBQztJQUFDeEwsVUFBUztJQUFZWCxZQUFXd0c7SUFBRUQsV0FBVTtJQUFJTyxhQUFZdEI7SUFBRTBDLGNBQWEsQ0FBQztJQUFFcUIsa0JBQWlCLENBQUM7SUFBRW5CLGNBQWEsQ0FBQztJQUFFQyxXQUFVLENBQUM7SUFBRU8sa0JBQWlCO0lBQUdGLG9CQUFtQjtJQUFJcUMsTUFBSztJQUFRekksT0FBTTtBQUFPO0FBQUUsSUFBSStJLEdBQUVDLElBQUUsSUFBSTFJLEtBQUkySSxJQUFFLEVBQUUsRUFBQ0MsSUFBRTtBQUFFLFNBQVNDO0lBQUksT0FBTSxLQUFHRDtBQUFHO0FBQUMsU0FBU0UsRUFBRXhOLENBQUM7SUFBRSxPQUFPQSxLQUFJb0IsQ0FBQUEsRUFBRXBCLEVBQUVtRSxPQUFPLEtBQUdqRCxFQUFFbEIsRUFBRW1FLE9BQU8sS0FBR25FLEVBQUVtRSxPQUFPLEdBQUNvSjtBQUFHO01BQXpEQztBQUEwRCxTQUFTQyxFQUFFek4sQ0FBQyxFQUFDRSxDQUFDO0lBQUUsT0FBT2tOLEVBQUVjLElBQUksR0FBQyxJQUFFbkwsRUFBRXdDLElBQUksQ0FBQyxHQUFFdkYsR0FBRUUsS0FBR21OLEVBQUVySSxJQUFJLENBQUM7UUFBQ2pCLFNBQVEvRDtRQUFFbU8sU0FBUWpPO0lBQUMsSUFBR0EsRUFBRWlFLE9BQU87QUFBQTtNQUE1RXNKO0FBQTZFLFNBQVNDLEVBQUUxTixDQUFDLEVBQUNFLENBQUM7SUFBRSxPQUFNO1FBQUMsR0FBR0EsQ0FBQztRQUFDcUQsTUFBS3JELEtBQUdBLEVBQUVxRCxJQUFJLElBQUV2RDtRQUFFbUUsU0FBUXFKLEVBQUV0TjtJQUFFO0FBQUM7TUFBbER3TjtBQUFtRCxTQUFTQyxFQUFFM04sQ0FBQztJQUFFLE9BQU0sQ0FBQ0UsR0FBRUUsSUFBSXFOLEVBQUV2TixHQUFFd04sRUFBRTFOLEdBQUVJO0FBQUc7QUFBQyxTQUFTd04sRUFBRTVOLENBQUMsRUFBQ0UsQ0FBQztJQUFFLE9BQU91TixFQUFFek4sR0FBRTBOLEVBQUUsV0FBVXhOO0FBQUc7TUFBakMwTjtBQUFrQ0EsRUFBRVEsT0FBTyxHQUFDLENBQUNwTyxHQUFFRSxJQUFJdU4sRUFBRXpOLEdBQUUwTixFQUFFLFdBQVU7UUFBQ3BKLFdBQVUsQ0FBQztRQUFFK0QsV0FBVSxDQUFDO1FBQUU2QixjQUFhLENBQUM7UUFBRXRCLGFBQVksQ0FBQztRQUFFdUIsV0FBVSxDQUFDO1FBQUUsR0FBR2pLLENBQUM7SUFBQSxLQUFJME4sRUFBRVMsT0FBTyxHQUFDLFNBQVNyTyxDQUFDLEVBQUNFLENBQUMsRUFBQ0UsQ0FBQztJQUFFLElBQUlFLEdBQUUsRUFBQ2dPLFNBQVE5TixDQUFDLEVBQUMwRixPQUFNeEYsQ0FBQyxFQUFDdUYsU0FBUXJGLENBQUMsRUFBQyxHQUFDVjtJQUFFTSxLQUFJRixDQUFBQSxJQUFFYyxFQUFFWixLQUFHb04sRUFBRVEsT0FBTyxDQUFDNU4sR0FBRUosS0FBR3dOLEVBQUVRLE9BQU8sQ0FBQzVOLEVBQUUrTixNQUFNLEVBQUM7UUFBQyxHQUFHbk8sQ0FBQztRQUFDLEdBQUdJLENBQUM7SUFBQSxFQUFDO0lBQUcsTUFBTU0sSUFBRTtRQUFDd0QsV0FBVTtRQUFLK0QsV0FBVTtRQUFLNkIsY0FBYTtRQUFLdEIsYUFBWTtRQUFLdUIsV0FBVTtJQUFJLEdBQUVuSixJQUFFLENBQUNoQixHQUFFRSxHQUFFTTtRQUFLLElBQUcsUUFBTU4sR0FBRSxPQUFPLEtBQUswTixFQUFFWSxPQUFPLENBQUNsTztRQUFHLE1BQU1JLElBQUU7WUFBQzZDLE1BQUt2RDtZQUFFLEdBQUdjLENBQUM7WUFBQyxHQUFHVixDQUFDO1lBQUNpRSxNQUFLN0Q7UUFBQyxHQUFFSSxJQUFFUSxFQUFFbEIsS0FBRztZQUFDcU8sUUFBT3JPO1FBQUMsSUFBRUE7UUFBRSxPQUFPSSxJQUFFc04sRUFBRWEsTUFBTSxDQUFDbk8sR0FBRTtZQUFDLEdBQUdJLENBQUM7WUFBQyxHQUFHRSxDQUFDO1FBQUEsS0FBR2dOLEVBQUVoTixFQUFFMk4sTUFBTSxFQUFDO1lBQUMsR0FBRzdOLENBQUM7WUFBQyxHQUFHRSxDQUFDO1FBQUEsSUFBR0o7SUFBQyxHQUFFUyxJQUFFSSxFQUFFckIsS0FBR0EsTUFBSUE7SUFBRSxPQUFPaUIsRUFBRXlOLElBQUksQ0FBQzFPLENBQUFBLElBQUdnQixFQUFFLFdBQVVKLEdBQUVaLElBQUkyTyxLQUFLLENBQUMzTyxDQUFBQSxJQUFHZ0IsRUFBRSxTQUFRTixHQUFFVixLQUFJaUI7QUFBQyxHQUFFMk0sRUFBRTNILE9BQU8sR0FBQzBILEVBQUUsWUFBV0MsRUFBRTdILElBQUksR0FBQzRILEVBQUUsU0FBUUMsRUFBRTFILEtBQUssR0FBQ3lILEVBQUUsVUFBU0MsRUFBRTVILE9BQU8sR0FBQzJILEVBQUUsWUFBV0MsRUFBRWdCLElBQUksR0FBQ2hCLEVBQUU1SCxPQUFPLEVBQUM0SCxFQUFFaUIsSUFBSSxHQUFDLENBQUM3TyxHQUFFRSxJQUFJdU4sRUFBRXpOLEdBQUUwTixFQUFFLFdBQVU7UUFBQ3RKLE9BQU07UUFBTyxHQUFHbEUsQ0FBQztJQUFBLEtBQUkwTixFQUFFWSxPQUFPLEdBQUN4TyxDQUFBQTtJQUFJb04sRUFBRWMsSUFBSSxHQUFDLElBQUVuTCxFQUFFd0MsSUFBSSxDQUFDLEdBQUV2RixLQUFHcU4sSUFBRUEsRUFBRW5JLE1BQU0sQ0FBQ2hGLENBQUFBLElBQUcsUUFBTUYsS0FBR0UsRUFBRWlPLE9BQU8sQ0FBQ2hLLE9BQU8sS0FBR25FO0FBQUUsR0FBRTROLEVBQUVrQixpQkFBaUIsR0FBQyxTQUFTOU8sQ0FBQztJQUFFLE9BQU8sS0FBSyxNQUFJQSxLQUFJQSxDQUFBQSxJQUFFLENBQUMsSUFBRytDLEVBQUV3QyxJQUFJLENBQUMsR0FBRXZGO0FBQUUsR0FBRTROLEVBQUVtQixRQUFRLEdBQUMvTyxDQUFBQTtJQUFJLElBQUlFLElBQUUsQ0FBQztJQUFFLE9BQU9rTixFQUFFL0gsT0FBTyxDQUFDakYsQ0FBQUE7UUFBSUEsRUFBRXNHLGFBQWEsSUFBRXRHLEVBQUVzRyxhQUFhLENBQUMxRyxNQUFLRSxDQUFBQSxJQUFFLENBQUM7SUFBRSxJQUFHQTtBQUFDLEdBQUUwTixFQUFFYSxNQUFNLEdBQUMsU0FBU3pPLENBQUMsRUFBQ0UsQ0FBQztJQUFFLEtBQUssTUFBSUEsS0FBSUEsQ0FBQUEsSUFBRSxDQUFDLElBQUcrQixXQUFXO1FBQUssTUFBTTdCLElBQUUsU0FBU0osQ0FBQyxFQUFDRSxDQUFDO1lBQUUsSUFBRyxFQUFDOEQsYUFBWTVELENBQUMsRUFBQyxHQUFDRjtZQUFFLE1BQU1JLElBQUU4TSxFQUFFckksR0FBRyxDQUFDM0UsS0FBRytNO1lBQUcsT0FBTzdNLEtBQUdBLEVBQUVxRyxRQUFRLENBQUMzRztRQUFFLEVBQUVBLEdBQUVFO1FBQUcsSUFBR0UsR0FBRTtZQUFDLE1BQUssRUFBQzZELE9BQU0zRCxDQUFDLEVBQUN5RCxTQUFRdkQsQ0FBQyxFQUFDLEdBQUNKLEdBQUVNLElBQUU7Z0JBQUM2RyxPQUFNO2dCQUFJLEdBQUdqSCxDQUFDO2dCQUFDLEdBQUdKLENBQUM7Z0JBQUNpRSxTQUFRakUsRUFBRWlFLE9BQU8sSUFBRW5FO2dCQUFFeUgsVUFBUzhGO1lBQUc7WUFBRTdNLEVBQUV5RCxPQUFPLEtBQUduRSxLQUFJVSxDQUFBQSxFQUFFeUcsT0FBTyxHQUFDbkgsQ0FBQUE7WUFBRyxNQUFNWSxJQUFFRixFQUFFNk4sTUFBTSxJQUFFL047WUFBRSxPQUFPRSxFQUFFNk4sTUFBTSxFQUFDZCxFQUFFN00sR0FBRUY7UUFBRTtJQUFDLEdBQUU7QUFBRSxHQUFFa04sRUFBRWpMLElBQUksR0FBQzNDLENBQUFBO0lBQUk0TixFQUFFYSxNQUFNLENBQUN6TyxHQUFFO1FBQUN3TSxVQUFTO0lBQUM7QUFBRSxHQUFFb0IsRUFBRW9CLFFBQVEsR0FBQ2hQLENBQUFBLElBQUkrQyxDQUFBQSxFQUFFNkIsRUFBRSxDQUFDLEdBQUU1RSxJQUFHO1FBQUsrQyxFQUFFa0MsR0FBRyxDQUFDLEdBQUVqRjtJQUFFLElBQUc0TixFQUFFcUIsUUFBUSxHQUFDO0lBQUNDLFVBQVM7SUFBV0MsV0FBVTtJQUFZQyxZQUFXO0lBQWFDLGFBQVk7SUFBY0MsY0FBYTtJQUFlQyxlQUFjO0FBQWUsR0FBRTNCLEVBQUU0QixJQUFJLEdBQUM7SUFBQ0MsTUFBSztJQUFPQyxTQUFRO0lBQVVDLFNBQVE7SUFBVUMsT0FBTTtJQUFRQyxTQUFRO0FBQVMsR0FBRTlNLEVBQUU2QixFQUFFLENBQUMsR0FBRTVFLENBQUFBO0lBQUltTixJQUFFbk4sRUFBRWdFLFdBQVcsSUFBRWhFLEdBQUVvTixFQUFFdEksR0FBRyxDQUFDcUksR0FBRW5OLElBQUdxTixFQUFFaEksT0FBTyxDQUFDckYsQ0FBQUE7UUFBSStDLEVBQUV3QyxJQUFJLENBQUMsR0FBRXZGLEVBQUUrRCxPQUFPLEVBQUMvRCxFQUFFbU8sT0FBTztJQUFDLElBQUdkLElBQUUsRUFBRTtBQUFBLEdBQUd6SSxFQUFFLENBQUMsR0FBRTVFLENBQUFBO0lBQUlvTixFQUFFakksTUFBTSxDQUFDbkYsRUFBRWdFLFdBQVcsSUFBRWhFLElBQUcsTUFBSW9OLEVBQUVjLElBQUksSUFBRW5MLEVBQUVrQyxHQUFHLENBQUMsR0FBR0EsR0FBRyxDQUFDLEdBQUdBLEdBQUcsQ0FBQztBQUFFO0FBQTJLLENBQ3ZzZSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L2Rpc3QvcmVhY3QtdG9hc3RpZnkuZXNtLm1qcz9lY2IzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCB0LHtpc1ZhbGlkRWxlbWVudCBhcyBlLHVzZVJlZiBhcyBuLHVzZUxheW91dEVmZmVjdCBhcyBvLHVzZUVmZmVjdCBhcyBzLGNsb25lRWxlbWVudCBhcyBhLHVzZVJlZHVjZXIgYXMgcix1c2VTdGF0ZSBhcyBpLGZvcndhcmRSZWYgYXMgbH1mcm9tXCJyZWFjdFwiO2ltcG9ydCBjIGZyb21cImNsc3hcIjtjb25zdCB1PXQ9PlwibnVtYmVyXCI9PXR5cGVvZiB0JiYhaXNOYU4odCksZD10PT5cInN0cmluZ1wiPT10eXBlb2YgdCxwPXQ9PlwiZnVuY3Rpb25cIj09dHlwZW9mIHQsbT10PT5kKHQpfHxwKHQpP3Q6bnVsbCxmPXQ9PmUodCl8fGQodCl8fHAodCl8fHUodCk7ZnVuY3Rpb24gZyh0LGUsbil7dm9pZCAwPT09biYmKG49MzAwKTtjb25zdHtzY3JvbGxIZWlnaHQ6byxzdHlsZTpzfT10O3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e3MubWluSGVpZ2h0PVwiaW5pdGlhbFwiLHMuaGVpZ2h0PW8rXCJweFwiLHMudHJhbnNpdGlvbj1gYWxsICR7bn1tc2AscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57cy5oZWlnaHQ9XCIwXCIscy5wYWRkaW5nPVwiMFwiLHMubWFyZ2luPVwiMFwiLHNldFRpbWVvdXQoZSxuKX0pfSl9ZnVuY3Rpb24gaChlKXtsZXR7ZW50ZXI6YSxleGl0OnIsYXBwZW5kUG9zaXRpb246aT0hMSxjb2xsYXBzZTpsPSEwLGNvbGxhcHNlRHVyYXRpb246Yz0zMDB9PWU7cmV0dXJuIGZ1bmN0aW9uKGUpe2xldHtjaGlsZHJlbjp1LHBvc2l0aW9uOmQscHJldmVudEV4aXRUcmFuc2l0aW9uOnAsZG9uZTptLG5vZGVSZWY6Zixpc0luOmh9PWU7Y29uc3QgeT1pP2Ake2F9LS0ke2R9YDphLHY9aT9gJHtyfS0tJHtkfWA6cixUPW4oMCk7cmV0dXJuIG8oKCk9Pntjb25zdCB0PWYuY3VycmVudCxlPXkuc3BsaXQoXCIgXCIpLG49bz0+e28udGFyZ2V0PT09Zi5jdXJyZW50JiYodC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImRcIikpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLG4pLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmNhbmNlbFwiLG4pLDA9PT1ULmN1cnJlbnQmJlwiYW5pbWF0aW9uY2FuY2VsXCIhPT1vLnR5cGUmJnQuY2xhc3NMaXN0LnJlbW92ZSguLi5lKSl9O3QuY2xhc3NMaXN0LmFkZCguLi5lKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIixuKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25jYW5jZWxcIixuKX0sW10pLHMoKCk9Pntjb25zdCB0PWYuY3VycmVudCxlPSgpPT57dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsZSksbD9nKHQsbSxjKTptKCl9O2h8fChwP2UoKTooVC5jdXJyZW50PTEsdC5jbGFzc05hbWUrPWAgJHt2fWAsdC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsZSkpKX0sW2hdKSx0LmNyZWF0ZUVsZW1lbnQodC5GcmFnbWVudCxudWxsLHUpfX1mdW5jdGlvbiB5KHQsZSl7cmV0dXJuIG51bGwhPXQ/e2NvbnRlbnQ6dC5jb250ZW50LGNvbnRhaW5lcklkOnQucHJvcHMuY29udGFpbmVySWQsaWQ6dC5wcm9wcy50b2FzdElkLHRoZW1lOnQucHJvcHMudGhlbWUsdHlwZTp0LnByb3BzLnR5cGUsZGF0YTp0LnByb3BzLmRhdGF8fHt9LGlzTG9hZGluZzp0LnByb3BzLmlzTG9hZGluZyxpY29uOnQucHJvcHMuaWNvbixzdGF0dXM6ZX06e319Y29uc3Qgdj17bGlzdDpuZXcgTWFwLGVtaXRRdWV1ZTpuZXcgTWFwLG9uKHQsZSl7cmV0dXJuIHRoaXMubGlzdC5oYXModCl8fHRoaXMubGlzdC5zZXQodCxbXSksdGhpcy5saXN0LmdldCh0KS5wdXNoKGUpLHRoaXN9LG9mZih0LGUpe2lmKGUpe2NvbnN0IG49dGhpcy5saXN0LmdldCh0KS5maWx0ZXIodD0+dCE9PWUpO3JldHVybiB0aGlzLmxpc3Quc2V0KHQsbiksdGhpc31yZXR1cm4gdGhpcy5saXN0LmRlbGV0ZSh0KSx0aGlzfSxjYW5jZWxFbWl0KHQpe2NvbnN0IGU9dGhpcy5lbWl0UXVldWUuZ2V0KHQpO3JldHVybiBlJiYoZS5mb3JFYWNoKGNsZWFyVGltZW91dCksdGhpcy5lbWl0UXVldWUuZGVsZXRlKHQpKSx0aGlzfSxlbWl0KHQpe3RoaXMubGlzdC5oYXModCkmJnRoaXMubGlzdC5nZXQodCkuZm9yRWFjaChlPT57Y29uc3Qgbj1zZXRUaW1lb3V0KCgpPT57ZSguLi5bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9LDApO3RoaXMuZW1pdFF1ZXVlLmhhcyh0KXx8dGhpcy5lbWl0UXVldWUuc2V0KHQsW10pLHRoaXMuZW1pdFF1ZXVlLmdldCh0KS5wdXNoKG4pfSl9fSxUPWU9PntsZXR7dGhlbWU6bix0eXBlOm8sLi4uc309ZTtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMjQgMjRcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIsZmlsbDpcImNvbG9yZWRcIj09PW4/XCJjdXJyZW50Q29sb3JcIjpgdmFyKC0tdG9hc3RpZnktaWNvbi1jb2xvci0ke299KWAsLi4uc30pfSxFPXtpbmZvOmZ1bmN0aW9uKGUpe3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoVCx7Li4uZX0sdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTEyIDBhMTIgMTIgMCAxMDEyIDEyQTEyLjAxMyAxMi4wMTMgMCAwMDEyIDB6bS4yNSA1YTEuNSAxLjUgMCAxMS0xLjUgMS41IDEuNSAxLjUgMCAwMTEuNS0xLjV6bTIuMjUgMTMuNWgtNGExIDEgMCAwMTAtMmguNzVhLjI1LjI1IDAgMDAuMjUtLjI1di00LjVhLjI1LjI1IDAgMDAtLjI1LS4yNWgtLjc1YTEgMSAwIDAxMC0yaDFhMiAyIDAgMDEyIDJ2NC43NWEuMjUuMjUgMCAwMC4yNS4yNWguNzVhMSAxIDAgMTEwIDJ6XCJ9KSl9LHdhcm5pbmc6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChULHsuLi5lfSx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMjMuMzIgMTcuMTkxTDE1LjQzOCAyLjE4NEMxNC43MjguODMzIDEzLjQxNiAwIDExLjk5NiAwYy0xLjQyIDAtMi43MzMuODMzLTMuNDQzIDIuMTg0TC41MzMgMTcuNDQ4YTQuNzQ0IDQuNzQ0IDAgMDAwIDQuMzY4QzEuMjQzIDIzLjE2NyAyLjU1NSAyNCAzLjk3NSAyNGgxNi4wNUMyMi4yMiAyNCAyNCAyMi4wNDQgMjQgMTkuNjMyYzAtLjkwNC0uMjUxLTEuNzQ2LS42OC0yLjQ0em0tOS42MjIgMS40NmMwIDEuMDMzLS43MjQgMS44MjMtMS42OTggMS44MjNzLTEuNjk4LS43OS0xLjY5OC0xLjgyMnYtLjA0M2MwLTEuMDI4LjcyNC0xLjgyMiAxLjY5OC0xLjgyMnMxLjY5OC43OSAxLjY5OCAxLjgyMnYuMDQzem0uMDM5LTEyLjI4NWwtLjg0IDguMDZjLS4wNTcuNTgxLS40MDguOTQzLS44OTcuOTQzLS40OSAwLS44NC0uMzY3LS44OTYtLjk0MmwtLjg0LTguMDY1Yy0uMDU3LS42MjQuMjUtMS4wOTUuNzc5LTEuMDk1aDEuOTFjLjUyOC4wMDUuODQuNDc2Ljc4NCAxLjF6XCJ9KSl9LHN1Y2Nlc3M6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChULHsuLi5lfSx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTIgMGExMiAxMiAwIDEwMTIgMTJBMTIuMDE0IDEyLjAxNCAwIDAwMTIgMHptNi45MjcgOC4ybC02Ljg0NSA5LjI4OWExLjAxMSAxLjAxMSAwIDAxLTEuNDMuMTg4bC00Ljg4OC0zLjkwOGExIDEgMCAxMTEuMjUtMS41NjJsNC4wNzYgMy4yNjEgNi4yMjctOC40NTFhMSAxIDAgMTExLjYxIDEuMTgzelwifSkpfSxlcnJvcjpmdW5jdGlvbihlKXtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFQsey4uLmV9LHQuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk0xMS45ODMgMGExMi4yMDYgMTIuMjA2IDAgMDAtOC41MSAzLjY1M0ExMS44IDExLjggMCAwMDAgMTIuMjA3IDExLjc3OSAxMS43NzkgMCAwMDExLjggMjRoLjIxNEExMi4xMTEgMTIuMTExIDAgMDAyNCAxMS43OTEgMTEuNzY2IDExLjc2NiAwIDAwMTEuOTgzIDB6TTEwLjUgMTYuNTQyYTEuNDc2IDEuNDc2IDAgMDExLjQ0OS0xLjUzaC4wMjdhMS41MjcgMS41MjcgMCAwMTEuNTIzIDEuNDcgMS40NzUgMS40NzUgMCAwMS0xLjQ0OSAxLjUzaC0uMDI3YTEuNTI5IDEuNTI5IDAgMDEtMS41MjMtMS40N3pNMTEgMTIuNXYtNmExIDEgMCAwMTIgMHY2YTEgMSAwIDExLTIgMHpcIn0pKX0sc3Bpbm5lcjpmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiVG9hc3RpZnlfX3NwaW5uZXJcIn0pfX07ZnVuY3Rpb24gQyh0KXtjb25zdFssb109cih0PT50KzEsMCksW2wsY109aShbXSksZz1uKG51bGwpLGg9bihuZXcgTWFwKS5jdXJyZW50LFQ9dD0+LTEhPT1sLmluZGV4T2YodCksQz1uKHt0b2FzdEtleToxLGRpc3BsYXllZFRvYXN0OjAsY291bnQ6MCxxdWV1ZTpbXSxwcm9wczp0LGNvbnRhaW5lcklkOm51bGwsaXNUb2FzdEFjdGl2ZTpULGdldFRvYXN0OnQ9PmguZ2V0KHQpfSkuY3VycmVudDtmdW5jdGlvbiBiKHQpe2xldHtjb250YWluZXJJZDplfT10O2NvbnN0e2xpbWl0Om59PUMucHJvcHM7IW58fGUmJkMuY29udGFpbmVySWQhPT1lfHwoQy5jb3VudC09Qy5xdWV1ZS5sZW5ndGgsQy5xdWV1ZT1bXSl9ZnVuY3Rpb24gSSh0KXtjKGU9Pm51bGw9PXQ/W106ZS5maWx0ZXIoZT0+ZSE9PXQpKX1mdW5jdGlvbiBfKCl7Y29uc3R7dG9hc3RDb250ZW50OnQsdG9hc3RQcm9wczplLHN0YWxlSWQ6bn09Qy5xdWV1ZS5zaGlmdCgpO08odCxlLG4pfWZ1bmN0aW9uIEwodCxuKXtsZXR7ZGVsYXk6cyxzdGFsZUlkOnIsLi4uaX09bjtpZighZih0KXx8ZnVuY3Rpb24odCl7cmV0dXJuIWcuY3VycmVudHx8Qy5wcm9wcy5lbmFibGVNdWx0aUNvbnRhaW5lciYmdC5jb250YWluZXJJZCE9PUMucHJvcHMuY29udGFpbmVySWR8fGguaGFzKHQudG9hc3RJZCkmJm51bGw9PXQudXBkYXRlSWR9KGkpKXJldHVybjtjb25zdHt0b2FzdElkOmwsdXBkYXRlSWQ6YyxkYXRhOlR9PWkse3Byb3BzOmJ9PUMsTD0oKT0+SShsKSxOPW51bGw9PWM7TiYmQy5jb3VudCsrO2NvbnN0IE09ey4uLmIsc3R5bGU6Yi50b2FzdFN0eWxlLGtleTpDLnRvYXN0S2V5KyssLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGkpLmZpbHRlcih0PT57bGV0W2Usbl09dDtyZXR1cm4gbnVsbCE9bn0pKSx0b2FzdElkOmwsdXBkYXRlSWQ6YyxkYXRhOlQsY2xvc2VUb2FzdDpMLGlzSW46ITEsY2xhc3NOYW1lOm0oaS5jbGFzc05hbWV8fGIudG9hc3RDbGFzc05hbWUpLGJvZHlDbGFzc05hbWU6bShpLmJvZHlDbGFzc05hbWV8fGIuYm9keUNsYXNzTmFtZSkscHJvZ3Jlc3NDbGFzc05hbWU6bShpLnByb2dyZXNzQ2xhc3NOYW1lfHxiLnByb2dyZXNzQ2xhc3NOYW1lKSxhdXRvQ2xvc2U6IWkuaXNMb2FkaW5nJiYoUj1pLmF1dG9DbG9zZSx3PWIuYXV0b0Nsb3NlLCExPT09Unx8dShSKSYmUj4wP1I6dyksZGVsZXRlVG9hc3QoKXtjb25zdCB0PXkoaC5nZXQobCksXCJyZW1vdmVkXCIpO2guZGVsZXRlKGwpLHYuZW1pdCg0LHQpO2NvbnN0IGU9Qy5xdWV1ZS5sZW5ndGg7aWYoQy5jb3VudD1udWxsPT1sP0MuY291bnQtQy5kaXNwbGF5ZWRUb2FzdDpDLmNvdW50LTEsQy5jb3VudDwwJiYoQy5jb3VudD0wKSxlPjApe2NvbnN0IHQ9bnVsbD09bD9DLnByb3BzLmxpbWl0OjE7aWYoMT09PWV8fDE9PT10KUMuZGlzcGxheWVkVG9hc3QrKyxfKCk7ZWxzZXtjb25zdCBuPXQ+ZT9lOnQ7Qy5kaXNwbGF5ZWRUb2FzdD1uO2ZvcihsZXQgdD0wO3Q8bjt0KyspXygpfX1lbHNlIG8oKX19O3ZhciBSLHc7TS5pY29uT3V0PWZ1bmN0aW9uKHQpe2xldHt0aGVtZTpuLHR5cGU6byxpc0xvYWRpbmc6cyxpY29uOnJ9PXQsaT1udWxsO2NvbnN0IGw9e3RoZW1lOm4sdHlwZTpvfTtyZXR1cm4hMT09PXJ8fChwKHIpP2k9cihsKTplKHIpP2k9YShyLGwpOmQocil8fHUocik/aT1yOnM/aT1FLnNwaW5uZXIoKToodD0+dCBpbiBFKShvKSYmKGk9RVtvXShsKSkpLGl9KE0pLHAoaS5vbk9wZW4pJiYoTS5vbk9wZW49aS5vbk9wZW4pLHAoaS5vbkNsb3NlKSYmKE0ub25DbG9zZT1pLm9uQ2xvc2UpLE0uY2xvc2VCdXR0b249Yi5jbG9zZUJ1dHRvbiwhMT09PWkuY2xvc2VCdXR0b258fGYoaS5jbG9zZUJ1dHRvbik/TS5jbG9zZUJ1dHRvbj1pLmNsb3NlQnV0dG9uOiEwPT09aS5jbG9zZUJ1dHRvbiYmKE0uY2xvc2VCdXR0b249IWYoYi5jbG9zZUJ1dHRvbil8fGIuY2xvc2VCdXR0b24pO2xldCB4PXQ7ZSh0KSYmIWQodC50eXBlKT94PWEodCx7Y2xvc2VUb2FzdDpMLHRvYXN0UHJvcHM6TSxkYXRhOlR9KTpwKHQpJiYoeD10KHtjbG9zZVRvYXN0OkwsdG9hc3RQcm9wczpNLGRhdGE6VH0pKSxiLmxpbWl0JiZiLmxpbWl0PjAmJkMuY291bnQ+Yi5saW1pdCYmTj9DLnF1ZXVlLnB1c2goe3RvYXN0Q29udGVudDp4LHRvYXN0UHJvcHM6TSxzdGFsZUlkOnJ9KTp1KHMpP3NldFRpbWVvdXQoKCk9PntPKHgsTSxyKX0scyk6Tyh4LE0scil9ZnVuY3Rpb24gTyh0LGUsbil7Y29uc3R7dG9hc3RJZDpvfT1lO24mJmguZGVsZXRlKG4pO2NvbnN0IHM9e2NvbnRlbnQ6dCxwcm9wczplfTtoLnNldChvLHMpLGModD0+Wy4uLnQsb10uZmlsdGVyKHQ9PnQhPT1uKSksdi5lbWl0KDQseShzLG51bGw9PXMucHJvcHMudXBkYXRlSWQ/XCJhZGRlZFwiOlwidXBkYXRlZFwiKSl9cmV0dXJuIHMoKCk9PihDLmNvbnRhaW5lcklkPXQuY29udGFpbmVySWQsdi5jYW5jZWxFbWl0KDMpLm9uKDAsTCkub24oMSx0PT5nLmN1cnJlbnQmJkkodCkpLm9uKDUsYikuZW1pdCgyLEMpLCgpPT57aC5jbGVhcigpLHYuZW1pdCgzLEMpfSksW10pLHMoKCk9PntDLnByb3BzPXQsQy5pc1RvYXN0QWN0aXZlPVQsQy5kaXNwbGF5ZWRUb2FzdD1sLmxlbmd0aH0pLHtnZXRUb2FzdFRvUmVuZGVyOmZ1bmN0aW9uKGUpe2NvbnN0IG49bmV3IE1hcCxvPUFycmF5LmZyb20oaC52YWx1ZXMoKSk7cmV0dXJuIHQubmV3ZXN0T25Ub3AmJm8ucmV2ZXJzZSgpLG8uZm9yRWFjaCh0PT57Y29uc3R7cG9zaXRpb246ZX09dC5wcm9wcztuLmhhcyhlKXx8bi5zZXQoZSxbXSksbi5nZXQoZSkucHVzaCh0KX0pLEFycmF5LmZyb20obix0PT5lKHRbMF0sdFsxXSkpfSxjb250YWluZXJSZWY6Zyxpc1RvYXN0QWN0aXZlOlR9fWZ1bmN0aW9uIGIodCl7cmV0dXJuIHQudGFyZ2V0VG91Y2hlcyYmdC50YXJnZXRUb3VjaGVzLmxlbmd0aD49MT90LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WDp0LmNsaWVudFh9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gdC50YXJnZXRUb3VjaGVzJiZ0LnRhcmdldFRvdWNoZXMubGVuZ3RoPj0xP3QudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZOnQuY2xpZW50WX1mdW5jdGlvbiBfKHQpe2NvbnN0W28sYV09aSghMSksW3IsbF09aSghMSksYz1uKG51bGwpLHU9bih7c3RhcnQ6MCx4OjAseTowLGRlbHRhOjAscmVtb3ZhbERpc3RhbmNlOjAsY2FuQ2xvc2VPbkNsaWNrOiEwLGNhbkRyYWc6ITEsYm91bmRpbmdSZWN0Om51bGwsZGlkTW92ZTohMX0pLmN1cnJlbnQsZD1uKHQpLHthdXRvQ2xvc2U6bSxwYXVzZU9uSG92ZXI6ZixjbG9zZVRvYXN0Omcsb25DbGljazpoLGNsb3NlT25DbGljazp5fT10O2Z1bmN0aW9uIHYoZSl7aWYodC5kcmFnZ2FibGUpe1widG91Y2hzdGFydFwiPT09ZS5uYXRpdmVFdmVudC50eXBlJiZlLm5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCksdS5kaWRNb3ZlPSExLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixfKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLEwpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixfKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixMKTtjb25zdCBuPWMuY3VycmVudDt1LmNhbkNsb3NlT25DbGljaz0hMCx1LmNhbkRyYWc9ITAsdS5ib3VuZGluZ1JlY3Q9bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuLnN0eWxlLnRyYW5zaXRpb249XCJcIix1Lng9YihlLm5hdGl2ZUV2ZW50KSx1Lnk9SShlLm5hdGl2ZUV2ZW50KSxcInhcIj09PXQuZHJhZ2dhYmxlRGlyZWN0aW9uPyh1LnN0YXJ0PXUueCx1LnJlbW92YWxEaXN0YW5jZT1uLm9mZnNldFdpZHRoKih0LmRyYWdnYWJsZVBlcmNlbnQvMTAwKSk6KHUuc3RhcnQ9dS55LHUucmVtb3ZhbERpc3RhbmNlPW4ub2Zmc2V0SGVpZ2h0Kig4MD09PXQuZHJhZ2dhYmxlUGVyY2VudD8xLjUqdC5kcmFnZ2FibGVQZXJjZW50OnQuZHJhZ2dhYmxlUGVyY2VudC8xMDApKX19ZnVuY3Rpb24gVChlKXtpZih1LmJvdW5kaW5nUmVjdCl7Y29uc3R7dG9wOm4sYm90dG9tOm8sbGVmdDpzLHJpZ2h0OmF9PXUuYm91bmRpbmdSZWN0O1widG91Y2hlbmRcIiE9PWUubmF0aXZlRXZlbnQudHlwZSYmdC5wYXVzZU9uSG92ZXImJnUueD49cyYmdS54PD1hJiZ1Lnk+PW4mJnUueTw9bz9DKCk6RSgpfX1mdW5jdGlvbiBFKCl7YSghMCl9ZnVuY3Rpb24gQygpe2EoITEpfWZ1bmN0aW9uIF8oZSl7Y29uc3Qgbj1jLmN1cnJlbnQ7dS5jYW5EcmFnJiZuJiYodS5kaWRNb3ZlPSEwLG8mJkMoKSx1Lng9YihlKSx1Lnk9SShlKSx1LmRlbHRhPVwieFwiPT09dC5kcmFnZ2FibGVEaXJlY3Rpb24/dS54LXUuc3RhcnQ6dS55LXUuc3RhcnQsdS5zdGFydCE9PXUueCYmKHUuY2FuQ2xvc2VPbkNsaWNrPSExKSxuLnN0eWxlLnRyYW5zZm9ybT1gdHJhbnNsYXRlJHt0LmRyYWdnYWJsZURpcmVjdGlvbn0oJHt1LmRlbHRhfXB4KWAsbi5zdHlsZS5vcGFjaXR5PVwiXCIrKDEtTWF0aC5hYnModS5kZWx0YS91LnJlbW92YWxEaXN0YW5jZSkpKX1mdW5jdGlvbiBMKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLF8pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsTCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLF8pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLEwpO2NvbnN0IGU9Yy5jdXJyZW50O2lmKHUuY2FuRHJhZyYmdS5kaWRNb3ZlJiZlKXtpZih1LmNhbkRyYWc9ITEsTWF0aC5hYnModS5kZWx0YSk+dS5yZW1vdmFsRGlzdGFuY2UpcmV0dXJuIGwoITApLHZvaWQgdC5jbG9zZVRvYXN0KCk7ZS5zdHlsZS50cmFuc2l0aW9uPVwidHJhbnNmb3JtIDAuMnMsIG9wYWNpdHkgMC4yc1wiLGUuc3R5bGUudHJhbnNmb3JtPWB0cmFuc2xhdGUke3QuZHJhZ2dhYmxlRGlyZWN0aW9ufSgwKWAsZS5zdHlsZS5vcGFjaXR5PVwiMVwifX1zKCgpPT57ZC5jdXJyZW50PXR9KSxzKCgpPT4oYy5jdXJyZW50JiZjLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRcIixFLHtvbmNlOiEwfSkscCh0Lm9uT3BlbikmJnQub25PcGVuKGUodC5jaGlsZHJlbikmJnQuY2hpbGRyZW4ucHJvcHMpLCgpPT57Y29uc3QgdD1kLmN1cnJlbnQ7cCh0Lm9uQ2xvc2UpJiZ0Lm9uQ2xvc2UoZSh0LmNoaWxkcmVuKSYmdC5jaGlsZHJlbi5wcm9wcyl9KSxbXSkscygoKT0+KHQucGF1c2VPbkZvY3VzTG9zcyYmKGRvY3VtZW50Lmhhc0ZvY3VzKCl8fEMoKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsRSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsQykpLCgpPT57dC5wYXVzZU9uRm9jdXNMb3NzJiYod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLEUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLEMpKX0pLFt0LnBhdXNlT25Gb2N1c0xvc3NdKTtjb25zdCBPPXtvbk1vdXNlRG93bjp2LG9uVG91Y2hTdGFydDp2LG9uTW91c2VVcDpULG9uVG91Y2hFbmQ6VH07cmV0dXJuIG0mJmYmJihPLm9uTW91c2VFbnRlcj1DLE8ub25Nb3VzZUxlYXZlPUUpLHkmJihPLm9uQ2xpY2s9dD0+e2gmJmgodCksdS5jYW5DbG9zZU9uQ2xpY2smJmcoKX0pLHtwbGF5VG9hc3Q6RSxwYXVzZVRvYXN0OkMsaXNSdW5uaW5nOm8scHJldmVudEV4aXRUcmFuc2l0aW9uOnIsdG9hc3RSZWY6YyxldmVudEhhbmRsZXJzOk99fWZ1bmN0aW9uIEwoZSl7bGV0e2Nsb3NlVG9hc3Q6bix0aGVtZTpvLGFyaWFMYWJlbDpzPVwiY2xvc2VcIn09ZTtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse2NsYXNzTmFtZTpgVG9hc3RpZnlfX2Nsb3NlLWJ1dHRvbiBUb2FzdGlmeV9fY2xvc2UtYnV0dG9uLS0ke299YCx0eXBlOlwiYnV0dG9uXCIsb25DbGljazp0PT57dC5zdG9wUHJvcGFnYXRpb24oKSxuKHQpfSxcImFyaWEtbGFiZWxcIjpzfSx0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwiLHZpZXdCb3g6XCIwIDAgMTQgMTZcIn0sdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtmaWxsUnVsZTpcImV2ZW5vZGRcIixkOlwiTTcuNzEgOC4yM2wzLjc1IDMuNzUtMS40OCAxLjQ4LTMuNzUtMy43NS0zLjc1IDMuNzVMMSAxMS45OGwzLjc1LTMuNzVMMSA0LjQ4IDIuNDggM2wzLjc1IDMuNzVMOS45OCAzbDEuNDggMS40OC0zLjc1IDMuNzV6XCJ9KSkpfWZ1bmN0aW9uIE8oZSl7bGV0e2RlbGF5Om4saXNSdW5uaW5nOm8sY2xvc2VUb2FzdDpzLHR5cGU6YT1cImRlZmF1bHRcIixoaWRlOnIsY2xhc3NOYW1lOmksc3R5bGU6bCxjb250cm9sbGVkUHJvZ3Jlc3M6dSxwcm9ncmVzczpkLHJ0bDptLGlzSW46Zix0aGVtZTpnfT1lO2NvbnN0IGg9cnx8dSYmMD09PWQseT17Li4ubCxhbmltYXRpb25EdXJhdGlvbjpgJHtufW1zYCxhbmltYXRpb25QbGF5U3RhdGU6bz9cInJ1bm5pbmdcIjpcInBhdXNlZFwiLG9wYWNpdHk6aD8wOjF9O3UmJih5LnRyYW5zZm9ybT1gc2NhbGVYKCR7ZH0pYCk7Y29uc3Qgdj1jKFwiVG9hc3RpZnlfX3Byb2dyZXNzLWJhclwiLHU/XCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1jb250cm9sbGVkXCI6XCJUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLS1hbmltYXRlZFwiLGBUb2FzdGlmeV9fcHJvZ3Jlc3MtYmFyLXRoZW1lLS0ke2d9YCxgVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tJHthfWAse1wiVG9hc3RpZnlfX3Byb2dyZXNzLWJhci0tcnRsXCI6bX0pLFQ9cChpKT9pKHtydGw6bSx0eXBlOmEsZGVmYXVsdENsYXNzTmFtZTp2fSk6Yyh2LGkpO3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cm9sZTpcInByb2dyZXNzYmFyXCIsXCJhcmlhLWhpZGRlblwiOmg/XCJ0cnVlXCI6XCJmYWxzZVwiLFwiYXJpYS1sYWJlbFwiOlwibm90aWZpY2F0aW9uIHRpbWVyXCIsY2xhc3NOYW1lOlQsc3R5bGU6eSxbdSYmZD49MT9cIm9uVHJhbnNpdGlvbkVuZFwiOlwib25BbmltYXRpb25FbmRcIl06dSYmZDwxP251bGw6KCk9PntmJiZzKCl9fSl9Y29uc3QgTj1uPT57Y29uc3R7aXNSdW5uaW5nOm8scHJldmVudEV4aXRUcmFuc2l0aW9uOnMsdG9hc3RSZWY6cixldmVudEhhbmRsZXJzOml9PV8obikse2Nsb3NlQnV0dG9uOmwsY2hpbGRyZW46dSxhdXRvQ2xvc2U6ZCxvbkNsaWNrOm0sdHlwZTpmLGhpZGVQcm9ncmVzc0JhcjpnLGNsb3NlVG9hc3Q6aCx0cmFuc2l0aW9uOnkscG9zaXRpb246dixjbGFzc05hbWU6VCxzdHlsZTpFLGJvZHlDbGFzc05hbWU6Qyxib2R5U3R5bGU6Yixwcm9ncmVzc0NsYXNzTmFtZTpJLHByb2dyZXNzU3R5bGU6Tix1cGRhdGVJZDpNLHJvbGU6Uixwcm9ncmVzczp3LHJ0bDp4LHRvYXN0SWQ6JCxkZWxldGVUb2FzdDprLGlzSW46UCxpc0xvYWRpbmc6QixpY29uT3V0OkQsY2xvc2VPbkNsaWNrOkEsdGhlbWU6en09bixGPWMoXCJUb2FzdGlmeV9fdG9hc3RcIixgVG9hc3RpZnlfX3RvYXN0LXRoZW1lLS0ke3p9YCxgVG9hc3RpZnlfX3RvYXN0LS0ke2Z9YCx7XCJUb2FzdGlmeV9fdG9hc3QtLXJ0bFwiOnh9LHtcIlRvYXN0aWZ5X190b2FzdC0tY2xvc2Utb24tY2xpY2tcIjpBfSksSD1wKFQpP1Qoe3J0bDp4LHBvc2l0aW9uOnYsdHlwZTpmLGRlZmF1bHRDbGFzc05hbWU6Rn0pOmMoRixUKSxTPSEhd3x8IWQscT17Y2xvc2VUb2FzdDpoLHR5cGU6Zix0aGVtZTp6fTtsZXQgUT1udWxsO3JldHVybiExPT09bHx8KFE9cChsKT9sKHEpOmUobCk/YShsLHEpOkwocSkpLHQuY3JlYXRlRWxlbWVudCh5LHtpc0luOlAsZG9uZTprLHBvc2l0aW9uOnYscHJldmVudEV4aXRUcmFuc2l0aW9uOnMsbm9kZVJlZjpyfSx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7aWQ6JCxvbkNsaWNrOm0sY2xhc3NOYW1lOkgsLi4uaSxzdHlsZTpFLHJlZjpyfSx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7Li4uUCYme3JvbGU6Un0sY2xhc3NOYW1lOnAoQyk/Qyh7dHlwZTpmfSk6YyhcIlRvYXN0aWZ5X190b2FzdC1ib2R5XCIsQyksc3R5bGU6Yn0sbnVsbCE9RCYmdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpjKFwiVG9hc3RpZnlfX3RvYXN0LWljb25cIix7XCJUb2FzdGlmeS0tYW5pbWF0ZS1pY29uIFRvYXN0aWZ5X196b29tLWVudGVyXCI6IUJ9KX0sRCksdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbnVsbCx1KSksUSx0LmNyZWF0ZUVsZW1lbnQoTyx7Li4uTSYmIVM/e2tleTpgcGItJHtNfWB9Ont9LHJ0bDp4LHRoZW1lOnosZGVsYXk6ZCxpc1J1bm5pbmc6byxpc0luOlAsY2xvc2VUb2FzdDpoLGhpZGU6Zyx0eXBlOmYsc3R5bGU6TixjbGFzc05hbWU6SSxjb250cm9sbGVkUHJvZ3Jlc3M6Uyxwcm9ncmVzczp3fHwwfSkpKX0sTT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSkse2VudGVyOmBUb2FzdGlmeS0tYW5pbWF0ZSBUb2FzdGlmeV9fJHt0fS1lbnRlcmAsZXhpdDpgVG9hc3RpZnktLWFuaW1hdGUgVG9hc3RpZnlfXyR7dH0tZXhpdGAsYXBwZW5kUG9zaXRpb246ZX19LFI9aChNKFwiYm91bmNlXCIsITApKSx3PWgoTShcInNsaWRlXCIsITApKSx4PWgoTShcInpvb21cIikpLCQ9aChNKFwiZmxpcFwiKSksaz1sKChlLG4pPT57Y29uc3R7Z2V0VG9hc3RUb1JlbmRlcjpvLGNvbnRhaW5lclJlZjphLGlzVG9hc3RBY3RpdmU6cn09QyhlKSx7Y2xhc3NOYW1lOmksc3R5bGU6bCxydGw6dSxjb250YWluZXJJZDpkfT1lO2Z1bmN0aW9uIGYodCl7Y29uc3QgZT1jKFwiVG9hc3RpZnlfX3RvYXN0LWNvbnRhaW5lclwiLGBUb2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS0ke3R9YCx7XCJUb2FzdGlmeV9fdG9hc3QtY29udGFpbmVyLS1ydGxcIjp1fSk7cmV0dXJuIHAoaSk/aSh7cG9zaXRpb246dCxydGw6dSxkZWZhdWx0Q2xhc3NOYW1lOmV9KTpjKGUsbShpKSl9cmV0dXJuIHMoKCk9PntuJiYobi5jdXJyZW50PWEuY3VycmVudCl9LFtdKSx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOmEsY2xhc3NOYW1lOlwiVG9hc3RpZnlcIixpZDpkfSxvKChlLG4pPT57Y29uc3Qgbz1uLmxlbmd0aD97Li4ubH06ey4uLmwscG9pbnRlckV2ZW50czpcIm5vbmVcIn07cmV0dXJuIHQuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6ZihlKSxzdHlsZTpvLGtleTpgY29udGFpbmVyLSR7ZX1gfSxuLm1hcCgoZSxvKT0+e2xldHtjb250ZW50OnMscHJvcHM6YX09ZTtyZXR1cm4gdC5jcmVhdGVFbGVtZW50KE4sey4uLmEsaXNJbjpyKGEudG9hc3RJZCksc3R5bGU6ey4uLmEuc3R5bGUsXCItLW50aFwiOm8rMSxcIi0tbGVuXCI6bi5sZW5ndGh9LGtleTpgdG9hc3QtJHthLmtleX1gfSxzKX0pKX0pKX0pO2suZGlzcGxheU5hbWU9XCJUb2FzdENvbnRhaW5lclwiLGsuZGVmYXVsdFByb3BzPXtwb3NpdGlvbjpcInRvcC1yaWdodFwiLHRyYW5zaXRpb246UixhdXRvQ2xvc2U6NWUzLGNsb3NlQnV0dG9uOkwscGF1c2VPbkhvdmVyOiEwLHBhdXNlT25Gb2N1c0xvc3M6ITAsY2xvc2VPbkNsaWNrOiEwLGRyYWdnYWJsZTohMCxkcmFnZ2FibGVQZXJjZW50OjgwLGRyYWdnYWJsZURpcmVjdGlvbjpcInhcIixyb2xlOlwiYWxlcnRcIix0aGVtZTpcImxpZ2h0XCJ9O2xldCBQLEI9bmV3IE1hcCxEPVtdLEE9MTtmdW5jdGlvbiB6KCl7cmV0dXJuXCJcIitBKyt9ZnVuY3Rpb24gRih0KXtyZXR1cm4gdCYmKGQodC50b2FzdElkKXx8dSh0LnRvYXN0SWQpKT90LnRvYXN0SWQ6eigpfWZ1bmN0aW9uIEgodCxlKXtyZXR1cm4gQi5zaXplPjA/di5lbWl0KDAsdCxlKTpELnB1c2goe2NvbnRlbnQ6dCxvcHRpb25zOmV9KSxlLnRvYXN0SWR9ZnVuY3Rpb24gUyh0LGUpe3JldHVybnsuLi5lLHR5cGU6ZSYmZS50eXBlfHx0LHRvYXN0SWQ6RihlKX19ZnVuY3Rpb24gcSh0KXtyZXR1cm4oZSxuKT0+SChlLFModCxuKSl9ZnVuY3Rpb24gUSh0LGUpe3JldHVybiBIKHQsUyhcImRlZmF1bHRcIixlKSl9US5sb2FkaW5nPSh0LGUpPT5IKHQsUyhcImRlZmF1bHRcIix7aXNMb2FkaW5nOiEwLGF1dG9DbG9zZTohMSxjbG9zZU9uQ2xpY2s6ITEsY2xvc2VCdXR0b246ITEsZHJhZ2dhYmxlOiExLC4uLmV9KSksUS5wcm9taXNlPWZ1bmN0aW9uKHQsZSxuKXtsZXQgbyx7cGVuZGluZzpzLGVycm9yOmEsc3VjY2VzczpyfT1lO3MmJihvPWQocyk/US5sb2FkaW5nKHMsbik6US5sb2FkaW5nKHMucmVuZGVyLHsuLi5uLC4uLnN9KSk7Y29uc3QgaT17aXNMb2FkaW5nOm51bGwsYXV0b0Nsb3NlOm51bGwsY2xvc2VPbkNsaWNrOm51bGwsY2xvc2VCdXR0b246bnVsbCxkcmFnZ2FibGU6bnVsbH0sbD0odCxlLHMpPT57aWYobnVsbD09ZSlyZXR1cm4gdm9pZCBRLmRpc21pc3Mobyk7Y29uc3QgYT17dHlwZTp0LC4uLmksLi4ubixkYXRhOnN9LHI9ZChlKT97cmVuZGVyOmV9OmU7cmV0dXJuIG8/US51cGRhdGUobyx7Li4uYSwuLi5yfSk6UShyLnJlbmRlcix7Li4uYSwuLi5yfSksc30sYz1wKHQpP3QoKTp0O3JldHVybiBjLnRoZW4odD0+bChcInN1Y2Nlc3NcIixyLHQpKS5jYXRjaCh0PT5sKFwiZXJyb3JcIixhLHQpKSxjfSxRLnN1Y2Nlc3M9cShcInN1Y2Nlc3NcIiksUS5pbmZvPXEoXCJpbmZvXCIpLFEuZXJyb3I9cShcImVycm9yXCIpLFEud2FybmluZz1xKFwid2FybmluZ1wiKSxRLndhcm49US53YXJuaW5nLFEuZGFyaz0odCxlKT0+SCh0LFMoXCJkZWZhdWx0XCIse3RoZW1lOlwiZGFya1wiLC4uLmV9KSksUS5kaXNtaXNzPXQ9PntCLnNpemU+MD92LmVtaXQoMSx0KTpEPUQuZmlsdGVyKGU9Pm51bGwhPXQmJmUub3B0aW9ucy50b2FzdElkIT09dCl9LFEuY2xlYXJXYWl0aW5nUXVldWU9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSx2LmVtaXQoNSx0KX0sUS5pc0FjdGl2ZT10PT57bGV0IGU9ITE7cmV0dXJuIEIuZm9yRWFjaChuPT57bi5pc1RvYXN0QWN0aXZlJiZuLmlzVG9hc3RBY3RpdmUodCkmJihlPSEwKX0pLGV9LFEudXBkYXRlPWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9e30pLHNldFRpbWVvdXQoKCk9Pntjb25zdCBuPWZ1bmN0aW9uKHQsZSl7bGV0e2NvbnRhaW5lcklkOm59PWU7Y29uc3Qgbz1CLmdldChufHxQKTtyZXR1cm4gbyYmby5nZXRUb2FzdCh0KX0odCxlKTtpZihuKXtjb25zdHtwcm9wczpvLGNvbnRlbnQ6c309bixhPXtkZWxheToxMDAsLi4ubywuLi5lLHRvYXN0SWQ6ZS50b2FzdElkfHx0LHVwZGF0ZUlkOnooKX07YS50b2FzdElkIT09dCYmKGEuc3RhbGVJZD10KTtjb25zdCByPWEucmVuZGVyfHxzO2RlbGV0ZSBhLnJlbmRlcixIKHIsYSl9fSwwKX0sUS5kb25lPXQ9PntRLnVwZGF0ZSh0LHtwcm9ncmVzczoxfSl9LFEub25DaGFuZ2U9dD0+KHYub24oNCx0KSwoKT0+e3Yub2ZmKDQsdCl9KSxRLlBPU0lUSU9OPXtUT1BfTEVGVDpcInRvcC1sZWZ0XCIsVE9QX1JJR0hUOlwidG9wLXJpZ2h0XCIsVE9QX0NFTlRFUjpcInRvcC1jZW50ZXJcIixCT1RUT01fTEVGVDpcImJvdHRvbS1sZWZ0XCIsQk9UVE9NX1JJR0hUOlwiYm90dG9tLXJpZ2h0XCIsQk9UVE9NX0NFTlRFUjpcImJvdHRvbS1jZW50ZXJcIn0sUS5UWVBFPXtJTkZPOlwiaW5mb1wiLFNVQ0NFU1M6XCJzdWNjZXNzXCIsV0FSTklORzpcIndhcm5pbmdcIixFUlJPUjpcImVycm9yXCIsREVGQVVMVDpcImRlZmF1bHRcIn0sdi5vbigyLHQ9PntQPXQuY29udGFpbmVySWR8fHQsQi5zZXQoUCx0KSxELmZvckVhY2godD0+e3YuZW1pdCgwLHQuY29udGVudCx0Lm9wdGlvbnMpfSksRD1bXX0pLm9uKDMsdD0+e0IuZGVsZXRlKHQuY29udGFpbmVySWR8fHQpLDA9PT1CLnNpemUmJnYub2ZmKDApLm9mZigxKS5vZmYoNSl9KTtleHBvcnR7UiBhcyBCb3VuY2UsJCBhcyBGbGlwLEUgYXMgSWNvbnMsdyBhcyBTbGlkZSxrIGFzIFRvYXN0Q29udGFpbmVyLHggYXMgWm9vbSxnIGFzIGNvbGxhcHNlVG9hc3QsaCBhcyBjc3NUcmFuc2l0aW9uLFEgYXMgdG9hc3QsXyBhcyB1c2VUb2FzdCxDIGFzIHVzZVRvYXN0Q29udGFpbmVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXRvYXN0aWZ5LmVzbS5tanMubWFwXG4iXSwibmFtZXMiOlsidCIsImlzVmFsaWRFbGVtZW50IiwiZSIsInVzZVJlZiIsIm4iLCJ1c2VMYXlvdXRFZmZlY3QiLCJvIiwidXNlRWZmZWN0IiwicyIsImNsb25lRWxlbWVudCIsImEiLCJ1c2VSZWR1Y2VyIiwiciIsInVzZVN0YXRlIiwiaSIsImZvcndhcmRSZWYiLCJsIiwiYyIsInUiLCJpc05hTiIsImQiLCJwIiwibSIsImYiLCJnIiwic2Nyb2xsSGVpZ2h0Iiwic3R5bGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtaW5IZWlnaHQiLCJoZWlnaHQiLCJ0cmFuc2l0aW9uIiwicGFkZGluZyIsIm1hcmdpbiIsInNldFRpbWVvdXQiLCJoIiwiZW50ZXIiLCJleGl0IiwiYXBwZW5kUG9zaXRpb24iLCJjb2xsYXBzZSIsImNvbGxhcHNlRHVyYXRpb24iLCJjaGlsZHJlbiIsInBvc2l0aW9uIiwicHJldmVudEV4aXRUcmFuc2l0aW9uIiwiZG9uZSIsIm5vZGVSZWYiLCJpc0luIiwieSIsInYiLCJUIiwiY3VycmVudCIsInNwbGl0IiwidGFyZ2V0IiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInR5cGUiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJhZGQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiY29udGVudCIsImNvbnRhaW5lcklkIiwicHJvcHMiLCJpZCIsInRvYXN0SWQiLCJ0aGVtZSIsImRhdGEiLCJpc0xvYWRpbmciLCJpY29uIiwic3RhdHVzIiwibGlzdCIsIk1hcCIsImVtaXRRdWV1ZSIsIm9uIiwiaGFzIiwic2V0IiwiZ2V0IiwicHVzaCIsIm9mZiIsImZpbHRlciIsImRlbGV0ZSIsImNhbmNlbEVtaXQiLCJmb3JFYWNoIiwiY2xlYXJUaW1lb3V0IiwiZW1pdCIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsInZpZXdCb3giLCJ3aWR0aCIsImZpbGwiLCJFIiwiaW5mbyIsIndhcm5pbmciLCJzdWNjZXNzIiwiZXJyb3IiLCJzcGlubmVyIiwiQyIsImluZGV4T2YiLCJ0b2FzdEtleSIsImRpc3BsYXllZFRvYXN0IiwiY291bnQiLCJxdWV1ZSIsImlzVG9hc3RBY3RpdmUiLCJnZXRUb2FzdCIsImIiLCJsaW1pdCIsImxlbmd0aCIsIkkiLCJfIiwidG9hc3RDb250ZW50IiwidG9hc3RQcm9wcyIsInN0YWxlSWQiLCJzaGlmdCIsIk8iLCJMIiwiZGVsYXkiLCJlbmFibGVNdWx0aUNvbnRhaW5lciIsInVwZGF0ZUlkIiwiTiIsIk0iLCJ0b2FzdFN0eWxlIiwia2V5IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiY2xvc2VUb2FzdCIsInRvYXN0Q2xhc3NOYW1lIiwiYm9keUNsYXNzTmFtZSIsInByb2dyZXNzQ2xhc3NOYW1lIiwiYXV0b0Nsb3NlIiwiUiIsInciLCJkZWxldGVUb2FzdCIsImljb25PdXQiLCJvbk9wZW4iLCJvbkNsb3NlIiwiY2xvc2VCdXR0b24iLCJ4IiwiY2xlYXIiLCJnZXRUb2FzdFRvUmVuZGVyIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwibmV3ZXN0T25Ub3AiLCJyZXZlcnNlIiwiY29udGFpbmVyUmVmIiwidGFyZ2V0VG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwic3RhcnQiLCJkZWx0YSIsInJlbW92YWxEaXN0YW5jZSIsImNhbkNsb3NlT25DbGljayIsImNhbkRyYWciLCJib3VuZGluZ1JlY3QiLCJkaWRNb3ZlIiwicGF1c2VPbkhvdmVyIiwib25DbGljayIsImNsb3NlT25DbGljayIsImRyYWdnYWJsZSIsIm5hdGl2ZUV2ZW50IiwicHJldmVudERlZmF1bHQiLCJkb2N1bWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRyYWdnYWJsZURpcmVjdGlvbiIsIm9mZnNldFdpZHRoIiwiZHJhZ2dhYmxlUGVyY2VudCIsIm9mZnNldEhlaWdodCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInRyYW5zZm9ybSIsIm9wYWNpdHkiLCJNYXRoIiwiYWJzIiwib25jZSIsInBhdXNlT25Gb2N1c0xvc3MiLCJoYXNGb2N1cyIsIndpbmRvdyIsIm9uTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0Iiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsInBsYXlUb2FzdCIsInBhdXNlVG9hc3QiLCJpc1J1bm5pbmciLCJ0b2FzdFJlZiIsImV2ZW50SGFuZGxlcnMiLCJhcmlhTGFiZWwiLCJzdG9wUHJvcGFnYXRpb24iLCJmaWxsUnVsZSIsImhpZGUiLCJjb250cm9sbGVkUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInJ0bCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uUGxheVN0YXRlIiwiZGVmYXVsdENsYXNzTmFtZSIsInJvbGUiLCJoaWRlUHJvZ3Jlc3NCYXIiLCJib2R5U3R5bGUiLCJwcm9ncmVzc1N0eWxlIiwiJCIsImsiLCJQIiwiQiIsIkQiLCJBIiwieiIsIkYiLCJIIiwiUyIsInEiLCJRIiwicmVmIiwicG9pbnRlckV2ZW50cyIsIm1hcCIsImRpc3BsYXlOYW1lIiwiZGVmYXVsdFByb3BzIiwic2l6ZSIsIm9wdGlvbnMiLCJsb2FkaW5nIiwicHJvbWlzZSIsInBlbmRpbmciLCJyZW5kZXIiLCJkaXNtaXNzIiwidXBkYXRlIiwidGhlbiIsImNhdGNoIiwid2FybiIsImRhcmsiLCJjbGVhcldhaXRpbmdRdWV1ZSIsImlzQWN0aXZlIiwib25DaGFuZ2UiLCJQT1NJVElPTiIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiVE9QX0NFTlRFUiIsIkJPVFRPTV9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiQk9UVE9NX0NFTlRFUiIsIlRZUEUiLCJJTkZPIiwiU1VDQ0VTUyIsIldBUk5JTkciLCJFUlJPUiIsIkRFRkFVTFQiLCJCb3VuY2UiLCJGbGlwIiwiSWNvbnMiLCJTbGlkZSIsIlRvYXN0Q29udGFpbmVyIiwiWm9vbSIsImNvbGxhcHNlVG9hc3QiLCJjc3NUcmFuc2l0aW9uIiwidG9hc3QiLCJ1c2VUb2FzdCIsInVzZVRvYXN0Q29udGFpbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-toastify/dist/react-toastify.esm.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fnode_modules%2Freact-toastify%2Fdist%2Freact-toastify.esm.mjs&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fglobals.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fpublic%2Fassets%2Fscss%2Fstyle.scss&modules=%2FUsers%2Fmichelangelogelardi%2FDocuments%2FWork%2FDev%2Ftime-voyage%2Fsrc%2Fredux-toolkit%2Fprovider.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);