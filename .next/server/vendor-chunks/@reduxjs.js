/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var __generator = this && this.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = this && this.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _j = 0, _k = __getOwnPropSymbols(b); _j < _k.length; _j++){\n        var prop = _k[_j];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __markAsModule = function(target) {\n    return __defProp(target, \"__esModule\", {\n        value: true\n    });\n};\nvar __objRest = function(source, exclude) {\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for(var _j = 0, _k = __getOwnPropSymbols(source); _j < _k.length; _j++){\n        var prop = _k[_j];\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\nvar __export = function(target, all) {\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __reExport = function(target, module2, desc) {\n    if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n        var _loop_1 = function(key) {\n            if (!__hasOwnProp.call(target, key) && key !== \"default\") __defProp(target, key, {\n                get: function() {\n                    return module2[key];\n                },\n                enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n            });\n        };\n        for(var _j = 0, _k = __getOwnPropNames(module2); _j < _k.length; _j++){\n            var key = _k[_j];\n            _loop_1(key);\n        }\n    }\n    return target;\n};\nvar __toModule = function(module2) {\n    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {\n        get: function() {\n            return module2.default;\n        },\n        enumerable: true\n    } : {\n        value: module2,\n        enumerable: true\n    })), module2);\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/query/index.ts\n__markAsModule(exports);\n__export(exports, {\n    QueryStatus: function() {\n        return QueryStatus;\n    },\n    buildCreateApi: function() {\n        return buildCreateApi;\n    },\n    copyWithStructuralSharing: function() {\n        return copyWithStructuralSharing;\n    },\n    coreModule: function() {\n        return coreModule;\n    },\n    coreModuleName: function() {\n        return coreModuleName;\n    },\n    createApi: function() {\n        return createApi;\n    },\n    defaultSerializeQueryArgs: function() {\n        return defaultSerializeQueryArgs;\n    },\n    fakeBaseQuery: function() {\n        return fakeBaseQuery;\n    },\n    fetchBaseQuery: function() {\n        return fetchBaseQuery;\n    },\n    retry: function() {\n        return retry;\n    },\n    setupListeners: function() {\n        return setupListeners;\n    },\n    skipSelector: function() {\n        return skipSelector;\n    },\n    skipToken: function() {\n        return skipToken;\n    }\n});\n// src/query/core/apiState.ts\nvar QueryStatus;\n(function(QueryStatus2) {\n    QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n    QueryStatus2[\"pending\"] = \"pending\";\n    QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n    QueryStatus2[\"rejected\"] = \"rejected\";\n})(QueryStatus || (QueryStatus = {}));\nfunction getRequestStatusFlags(status) {\n    return {\n        status: status,\n        isUninitialized: status === QueryStatus.uninitialized,\n        isLoading: status === QueryStatus.pending,\n        isSuccess: status === QueryStatus.fulfilled,\n        isError: status === QueryStatus.rejected\n    };\n}\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n    return new RegExp(\"(^|:)//\").test(url);\n}\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = function(url) {\n    return url.replace(/\\/$/, \"\");\n};\nvar withoutLeadingSlash = function(url) {\n    return url.replace(/^\\//, \"\");\n};\nfunction joinUrls(base, url) {\n    if (!base) {\n        return url;\n    }\n    if (!url) {\n        return base;\n    }\n    if (isAbsoluteUrl(url)) {\n        return url;\n    }\n    var delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n    base = withoutTrailingSlash(base);\n    url = withoutLeadingSlash(url);\n    return \"\" + base + delimiter + url;\n}\n// src/query/utils/flatten.ts\nvar flatten = function(arr) {\n    return [].concat.apply([], arr);\n};\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n    return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    return document.visibilityState !== \"hidden\";\n}\n// src/query/utils/copyWithStructuralSharing.ts\nvar import_toolkit = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar isPlainObject = import_toolkit.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n    if (oldObj === newObj || !(isPlainObject(oldObj) && isPlainObject(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n        return newObj;\n    }\n    var newKeys = Object.keys(newObj);\n    var oldKeys = Object.keys(oldObj);\n    var isSameObject = newKeys.length === oldKeys.length;\n    var mergeObj = Array.isArray(newObj) ? [] : {};\n    for(var _j = 0, newKeys_1 = newKeys; _j < newKeys_1.length; _j++){\n        var key = newKeys_1[_j];\n        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n    }\n    return isSameObject ? oldObj : mergeObj;\n}\n// src/query/fetchBaseQuery.ts\nvar import_toolkit2 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar defaultFetchFn = function() {\n    var args = [];\n    for(var _j = 0; _j < arguments.length; _j++){\n        args[_j] = arguments[_j];\n    }\n    return fetch.apply(void 0, args);\n};\nvar defaultValidateStatus = function(response) {\n    return response.status >= 200 && response.status <= 299;\n};\nvar defaultIsJsonContentType = function(headers) {\n    return /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\");\n};\nfunction stripUndefined(obj) {\n    if (!(0, import_toolkit2.isPlainObject)(obj)) {\n        return obj;\n    }\n    var copy = __spreadValues({}, obj);\n    for(var _j = 0, _k = Object.entries(copy); _j < _k.length; _j++){\n        var _l = _k[_j], k = _l[0], v = _l[1];\n        if (v === void 0) delete copy[k];\n    }\n    return copy;\n}\nfunction fetchBaseQuery(_a) {\n    var _this = this;\n    if (_a === void 0) {\n        _a = {};\n    }\n    var _b = _a, baseUrl = _b.baseUrl, _j = _b.prepareHeaders, prepareHeaders = _j === void 0 ? function(x) {\n        return x;\n    } : _j, _k = _b.fetchFn, fetchFn = _k === void 0 ? defaultFetchFn : _k, paramsSerializer = _b.paramsSerializer, _l = _b.isJsonContentType, isJsonContentType = _l === void 0 ? defaultIsJsonContentType : _l, _m = _b.jsonContentType, jsonContentType = _m === void 0 ? \"application/json\" : _m, jsonReplacer = _b.jsonReplacer, defaultTimeout = _b.timeout, globalResponseHandler = _b.responseHandler, globalValidateStatus = _b.validateStatus, baseFetchOptions = __objRest(_b, [\n        \"baseUrl\",\n        \"prepareHeaders\",\n        \"fetchFn\",\n        \"paramsSerializer\",\n        \"isJsonContentType\",\n        \"jsonContentType\",\n        \"jsonReplacer\",\n        \"timeout\",\n        \"responseHandler\",\n        \"validateStatus\"\n    ]);\n    if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n        console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n    }\n    return function(arg, api) {\n        return __async(_this, null, function() {\n            var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _j, headers, _k, params, _l, responseHandler, _m, validateStatus, _o, timeout, rest, config, _p, isJsonifiable, divider, query, request, requestClone, response, timedOut, timeoutId, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;\n            return __generator(this, function(_q) {\n                switch(_q.label){\n                    case 0:\n                        signal = api.signal, getState = api.getState, extra = api.extra, endpoint = api.endpoint, forced = api.forced, type = api.type;\n                        _a2 = typeof arg == \"string\" ? {\n                            url: arg\n                        } : arg, url = _a2.url, _j = _a2.headers, headers = _j === void 0 ? new Headers(baseFetchOptions.headers) : _j, _k = _a2.params, params = _k === void 0 ? void 0 : _k, _l = _a2.responseHandler, responseHandler = _l === void 0 ? globalResponseHandler != null ? globalResponseHandler : \"json\" : _l, _m = _a2.validateStatus, validateStatus = _m === void 0 ? globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus : _m, _o = _a2.timeout, timeout = _o === void 0 ? defaultTimeout : _o, rest = __objRest(_a2, [\n                            \"url\",\n                            \"headers\",\n                            \"params\",\n                            \"responseHandler\",\n                            \"validateStatus\",\n                            \"timeout\"\n                        ]);\n                        config = __spreadValues(__spreadProps(__spreadValues({}, baseFetchOptions), {\n                            signal: signal\n                        }), rest);\n                        headers = new Headers(stripUndefined(headers));\n                        _p = config;\n                        return [\n                            4 /*yield*/ ,\n                            prepareHeaders(headers, {\n                                getState: getState,\n                                extra: extra,\n                                endpoint: endpoint,\n                                forced: forced,\n                                type: type\n                            })\n                        ];\n                    case 1:\n                        _p.headers = _q.sent() || headers;\n                        isJsonifiable = function(body) {\n                            return typeof body === \"object\" && ((0, import_toolkit2.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n                        };\n                        if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n                            config.headers.set(\"content-type\", jsonContentType);\n                        }\n                        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n                            config.body = JSON.stringify(config.body, jsonReplacer);\n                        }\n                        if (params) {\n                            divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n                            query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n                            url += divider + query;\n                        }\n                        url = joinUrls(baseUrl, url);\n                        request = new Request(url, config);\n                        requestClone = new Request(url, config);\n                        meta = {\n                            request: requestClone\n                        };\n                        timedOut = false, timeoutId = timeout && setTimeout(function() {\n                            timedOut = true;\n                            api.abort();\n                        }, timeout);\n                        _q.label = 2;\n                    case 2:\n                        _q.trys.push([\n                            2,\n                            4,\n                            5,\n                            6\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            fetchFn(request)\n                        ];\n                    case 3:\n                        response = _q.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        e_1 = _q.sent();\n                        return [\n                            2 /*return*/ ,\n                            {\n                                error: {\n                                    status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n                                    error: String(e_1)\n                                },\n                                meta: meta\n                            }\n                        ];\n                    case 5:\n                        if (timeoutId) clearTimeout(timeoutId);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        responseClone = response.clone();\n                        meta.response = responseClone;\n                        responseText = \"\";\n                        _q.label = 7;\n                    case 7:\n                        _q.trys.push([\n                            7,\n                            9,\n                            ,\n                            10\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.all([\n                                handleResponse(response, responseHandler).then(function(r) {\n                                    return resultData = r;\n                                }, function(e) {\n                                    return handleResponseError_1 = e;\n                                }),\n                                responseClone.text().then(function(r) {\n                                    return responseText = r;\n                                }, function() {})\n                            ])\n                        ];\n                    case 8:\n                        _q.sent();\n                        if (handleResponseError_1) throw handleResponseError_1;\n                        return [\n                            3 /*break*/ ,\n                            10\n                        ];\n                    case 9:\n                        e_2 = _q.sent();\n                        return [\n                            2 /*return*/ ,\n                            {\n                                error: {\n                                    status: \"PARSING_ERROR\",\n                                    originalStatus: response.status,\n                                    data: responseText,\n                                    error: String(e_2)\n                                },\n                                meta: meta\n                            }\n                        ];\n                    case 10:\n                        return [\n                            2 /*return*/ ,\n                            validateStatus(response, resultData) ? {\n                                data: resultData,\n                                meta: meta\n                            } : {\n                                error: {\n                                    status: response.status,\n                                    data: resultData\n                                },\n                                meta: meta\n                            }\n                        ];\n                }\n            });\n        });\n    };\n    function handleResponse(response, responseHandler) {\n        return __async(this, null, function() {\n            var text;\n            return __generator(this, function(_j) {\n                switch(_j.label){\n                    case 0:\n                        if (typeof responseHandler === \"function\") {\n                            return [\n                                2 /*return*/ ,\n                                responseHandler(response)\n                            ];\n                        }\n                        if (responseHandler === \"content-type\") {\n                            responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n                        }\n                        if (!(responseHandler === \"json\")) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            response.text()\n                        ];\n                    case 1:\n                        text = _j.sent();\n                        return [\n                            2 /*return*/ ,\n                            text.length ? JSON.parse(text) : null\n                        ];\n                    case 2:\n                        return [\n                            2 /*return*/ ,\n                            response.text()\n                        ];\n                }\n            });\n        });\n    }\n}\n// src/query/HandledError.ts\nvar HandledError = /** @class */ function() {\n    function HandledError(value, meta) {\n        if (meta === void 0) {\n            meta = void 0;\n        }\n        this.value = value;\n        this.meta = meta;\n    }\n    return HandledError;\n}();\n// src/query/retry.ts\nfunction defaultBackoff(attempt, maxRetries) {\n    if (attempt === void 0) {\n        attempt = 0;\n    }\n    if (maxRetries === void 0) {\n        maxRetries = 5;\n    }\n    return __async(this, null, function() {\n        var attempts, timeout;\n        return __generator(this, function(_j) {\n            switch(_j.label){\n                case 0:\n                    attempts = Math.min(attempt, maxRetries);\n                    timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n                    return [\n                        4 /*yield*/ ,\n                        new Promise(function(resolve) {\n                            return setTimeout(function(res) {\n                                return resolve(res);\n                            }, timeout);\n                        })\n                    ];\n                case 1:\n                    _j.sent();\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n}\nfunction fail(e) {\n    throw Object.assign(new HandledError({\n        error: e\n    }), {\n        throwImmediately: true\n    });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = function(baseQuery, defaultOptions) {\n    return function(args, api, extraOptions) {\n        return __async(void 0, null, function() {\n            var possibleMaxRetries, maxRetries, defaultRetryCondition, options, retry2, result, e_3;\n            return __generator(this, function(_j) {\n                switch(_j.label){\n                    case 0:\n                        possibleMaxRetries = [\n                            5,\n                            (defaultOptions || EMPTY_OPTIONS).maxRetries,\n                            (extraOptions || EMPTY_OPTIONS).maxRetries\n                        ].filter(function(x) {\n                            return x !== void 0;\n                        });\n                        maxRetries = possibleMaxRetries.slice(-1)[0];\n                        defaultRetryCondition = function(_, __, _j) {\n                            var attempt = _j.attempt;\n                            return attempt <= maxRetries;\n                        };\n                        options = __spreadValues(__spreadValues({\n                            maxRetries: maxRetries,\n                            backoff: defaultBackoff,\n                            retryCondition: defaultRetryCondition\n                        }, defaultOptions), extraOptions);\n                        retry2 = 0;\n                        _j.label = 1;\n                    case 1:\n                        if (false) {}\n                        _j.label = 2;\n                    case 2:\n                        _j.trys.push([\n                            2,\n                            4,\n                            ,\n                            6\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            baseQuery(args, api, extraOptions)\n                        ];\n                    case 3:\n                        result = _j.sent();\n                        if (result.error) {\n                            throw new HandledError(result);\n                        }\n                        return [\n                            2 /*return*/ ,\n                            result\n                        ];\n                    case 4:\n                        e_3 = _j.sent();\n                        retry2++;\n                        if (e_3.throwImmediately) {\n                            if (e_3 instanceof HandledError) {\n                                return [\n                                    2 /*return*/ ,\n                                    e_3.value\n                                ];\n                            }\n                            throw e_3;\n                        }\n                        if (e_3 instanceof HandledError && !options.retryCondition(e_3.value.error, args, {\n                            attempt: retry2,\n                            baseQueryApi: api,\n                            extraOptions: extraOptions\n                        })) {\n                            return [\n                                2 /*return*/ ,\n                                e_3.value\n                            ];\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            options.backoff(retry2, options.maxRetries)\n                        ];\n                    case 5:\n                        _j.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 6:\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n};\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n    fail: fail\n});\n// src/query/core/setupListeners.ts\nvar import_toolkit3 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar onFocus = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0, import_toolkit3.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n    function defaultHandler() {\n        var handleFocus = function() {\n            return dispatch(onFocus());\n        };\n        var handleFocusLost = function() {\n            return dispatch(onFocusLost());\n        };\n        var handleOnline = function() {\n            return dispatch(onOnline());\n        };\n        var handleOffline = function() {\n            return dispatch(onOffline());\n        };\n        var handleVisibilityChange = function() {\n            if (window.document.visibilityState === \"visible\") {\n                handleFocus();\n            } else {\n                handleFocusLost();\n            }\n        };\n        if (!initialized) {\n            if (false) {}\n        }\n        var unsubscribe = function() {\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n            initialized = false;\n        };\n        return unsubscribe;\n    }\n    return customHandler ? customHandler(dispatch, {\n        onFocus: onFocus,\n        onFocusLost: onFocusLost,\n        onOffline: onOffline,\n        onOnline: onOnline\n    }) : defaultHandler();\n}\n// src/query/core/buildSelectors.ts\nvar import_toolkit7 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/endpointDefinitions.ts\nvar DefinitionType;\n(function(DefinitionType2) {\n    DefinitionType2[\"query\"] = \"query\";\n    DefinitionType2[\"mutation\"] = \"mutation\";\n})(DefinitionType || (DefinitionType = {}));\nfunction isQueryDefinition(e) {\n    return e.type === DefinitionType.query;\n}\nfunction isMutationDefinition(e) {\n    return e.type === DefinitionType.mutation;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n    if (isFunction(description)) {\n        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n    }\n    if (Array.isArray(description)) {\n        return description.map(expandTagDescription).map(assertTagTypes);\n    }\n    return [];\n}\nfunction isFunction(t) {\n    return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n    return typeof description === \"string\" ? {\n        type: description\n    } : description;\n}\n// src/query/core/buildSlice.ts\nvar import_toolkit6 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n    return v != null;\n}\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = function(arg) {\n    return typeof arg[forceQueryFnSymbol] === \"function\";\n};\nfunction buildInitiate(_j) {\n    var serializeQueryArgs = _j.serializeQueryArgs, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, api = _j.api, context = _j.context;\n    var runningQueries = new Map();\n    var runningMutations = new Map();\n    var _k = api.internalActions, unsubscribeQueryResult = _k.unsubscribeQueryResult, removeMutationResult = _k.removeMutationResult, updateSubscriptionOptions = _k.updateSubscriptionOptions;\n    return {\n        buildInitiateQuery: buildInitiateQuery,\n        buildInitiateMutation: buildInitiateMutation,\n        getRunningQueryThunk: getRunningQueryThunk,\n        getRunningMutationThunk: getRunningMutationThunk,\n        getRunningQueriesThunk: getRunningQueriesThunk,\n        getRunningMutationsThunk: getRunningMutationsThunk,\n        getRunningOperationPromises: getRunningOperationPromises,\n        removalWarning: removalWarning\n    };\n    function removalWarning() {\n        throw new Error(\"This method had to be removed due to a conceptual bug in RTK.\\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.\");\n    }\n    function getRunningOperationPromises() {\n        if (typeof process !== \"undefined\" && true) {\n            removalWarning();\n        } else {\n            var extract = function(v) {\n                return Array.from(v.values()).flatMap(function(queriesForStore) {\n                    return queriesForStore ? Object.values(queriesForStore) : [];\n                });\n            };\n            return __spreadArray(__spreadArray([], extract(runningQueries)), extract(runningMutations)).filter(isNotNullish);\n        }\n    }\n    function getRunningQueryThunk(endpointName, queryArgs) {\n        return function(dispatch) {\n            var _a;\n            var endpointDefinition = context.endpointDefinitions[endpointName];\n            var queryCacheKey = serializeQueryArgs({\n                queryArgs: queryArgs,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n        };\n    }\n    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n        return function(dispatch) {\n            var _a;\n            return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];\n        };\n    }\n    function getRunningQueriesThunk() {\n        return function(dispatch) {\n            return Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n        };\n    }\n    function getRunningMutationsThunk() {\n        return function(dispatch) {\n            return Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n        };\n    }\n    function middlewareWarning(dispatch) {\n        if (true) {\n            if (middlewareWarning.triggered) return;\n            var registered = dispatch(api.internalActions.internal_probeSubscription({\n                queryCacheKey: \"DOES_NOT_EXIST\",\n                requestId: \"DUMMY_REQUEST_ID\"\n            }));\n            middlewareWarning.triggered = true;\n            if (typeof registered !== \"boolean\") {\n                throw new Error('Warning: Middleware for RTK-Query API at reducerPath \"' + api.reducerPath + '\" has not been added to the store.\\nYou must add the middleware for RTK-Query to function correctly!');\n            }\n        }\n    }\n    function buildInitiateQuery(endpointName, endpointDefinition) {\n        var queryAction = function(arg, _j) {\n            var _k = _j === void 0 ? {} : _j, _l = _k.subscribe, subscribe = _l === void 0 ? true : _l, forceRefetch = _k.forceRefetch, subscriptionOptions = _k.subscriptionOptions, _m = forceQueryFnSymbol, forceQueryFn = _k[_m];\n            return function(dispatch, getState) {\n                var _j;\n                var _a;\n                var queryCacheKey = serializeQueryArgs({\n                    queryArgs: arg,\n                    endpointDefinition: endpointDefinition,\n                    endpointName: endpointName\n                });\n                var thunk = queryThunk((_j = {\n                    type: \"query\",\n                    subscribe: subscribe,\n                    forceRefetch: forceRefetch,\n                    subscriptionOptions: subscriptionOptions,\n                    endpointName: endpointName,\n                    originalArgs: arg,\n                    queryCacheKey: queryCacheKey\n                }, _j[forceQueryFnSymbol] = forceQueryFn, _j));\n                var selector = api.endpoints[endpointName].select(arg);\n                var thunkResult = dispatch(thunk);\n                var stateAfter = selector(getState());\n                middlewareWarning(dispatch);\n                var requestId = thunkResult.requestId, abort = thunkResult.abort;\n                var skippedSynchronously = stateAfter.requestId !== requestId;\n                var runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n                var selectFromState = function() {\n                    return selector(getState());\n                };\n                var statePromise = Object.assign(forceQueryFn ? thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? Promise.resolve(stateAfter) : Promise.all([\n                    runningQuery,\n                    thunkResult\n                ]).then(selectFromState), {\n                    arg: arg,\n                    requestId: requestId,\n                    subscriptionOptions: subscriptionOptions,\n                    queryCacheKey: queryCacheKey,\n                    abort: abort,\n                    unwrap: function() {\n                        return __async(this, null, function() {\n                            var result;\n                            return __generator(this, function(_j) {\n                                switch(_j.label){\n                                    case 0:\n                                        return [\n                                            4 /*yield*/ ,\n                                            statePromise\n                                        ];\n                                    case 1:\n                                        result = _j.sent();\n                                        if (result.isError) {\n                                            throw result.error;\n                                        }\n                                        return [\n                                            2 /*return*/ ,\n                                            result.data\n                                        ];\n                                }\n                            });\n                        });\n                    },\n                    refetch: function() {\n                        return dispatch(queryAction(arg, {\n                            subscribe: false,\n                            forceRefetch: true\n                        }));\n                    },\n                    unsubscribe: function() {\n                        if (subscribe) dispatch(unsubscribeQueryResult({\n                            queryCacheKey: queryCacheKey,\n                            requestId: requestId\n                        }));\n                    },\n                    updateSubscriptionOptions: function(options) {\n                        statePromise.subscriptionOptions = options;\n                        dispatch(updateSubscriptionOptions({\n                            endpointName: endpointName,\n                            requestId: requestId,\n                            queryCacheKey: queryCacheKey,\n                            options: options\n                        }));\n                    }\n                });\n                if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n                    var running_1 = runningQueries.get(dispatch) || {};\n                    running_1[queryCacheKey] = statePromise;\n                    runningQueries.set(dispatch, running_1);\n                    statePromise.then(function() {\n                        delete running_1[queryCacheKey];\n                        if (!Object.keys(running_1).length) {\n                            runningQueries.delete(dispatch);\n                        }\n                    });\n                }\n                return statePromise;\n            };\n        };\n        return queryAction;\n    }\n    function buildInitiateMutation(endpointName) {\n        return function(arg, _j) {\n            var _k = _j === void 0 ? {} : _j, _l = _k.track, track = _l === void 0 ? true : _l, fixedCacheKey = _k.fixedCacheKey;\n            return function(dispatch, getState) {\n                var thunk = mutationThunk({\n                    type: \"mutation\",\n                    endpointName: endpointName,\n                    originalArgs: arg,\n                    track: track,\n                    fixedCacheKey: fixedCacheKey\n                });\n                var thunkResult = dispatch(thunk);\n                middlewareWarning(dispatch);\n                var requestId = thunkResult.requestId, abort = thunkResult.abort, unwrap = thunkResult.unwrap;\n                var returnValuePromise = thunkResult.unwrap().then(function(data) {\n                    return {\n                        data: data\n                    };\n                }).catch(function(error) {\n                    return {\n                        error: error\n                    };\n                });\n                var reset = function() {\n                    dispatch(removeMutationResult({\n                        requestId: requestId,\n                        fixedCacheKey: fixedCacheKey\n                    }));\n                };\n                var ret = Object.assign(returnValuePromise, {\n                    arg: thunkResult.arg,\n                    requestId: requestId,\n                    abort: abort,\n                    unwrap: unwrap,\n                    unsubscribe: reset,\n                    reset: reset\n                });\n                var running = runningMutations.get(dispatch) || {};\n                runningMutations.set(dispatch, running);\n                running[requestId] = ret;\n                ret.then(function() {\n                    delete running[requestId];\n                    if (!Object.keys(running).length) {\n                        runningMutations.delete(dispatch);\n                    }\n                });\n                if (fixedCacheKey) {\n                    running[fixedCacheKey] = ret;\n                    ret.then(function() {\n                        if (running[fixedCacheKey] === ret) {\n                            delete running[fixedCacheKey];\n                            if (!Object.keys(running).length) {\n                                runningMutations.delete(dispatch);\n                            }\n                        }\n                    });\n                }\n                return ret;\n            };\n        };\n    }\n}\n// src/query/core/buildThunks.ts\nvar import_toolkit4 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar import_immer = __toModule(__webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\"));\nvar import_toolkit5 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nfunction defaultTransformResponse(baseQueryReturnValue) {\n    return baseQueryReturnValue;\n}\nfunction buildThunks(_j) {\n    var _this = this;\n    var reducerPath = _j.reducerPath, baseQuery = _j.baseQuery, endpointDefinitions = _j.context.endpointDefinitions, serializeQueryArgs = _j.serializeQueryArgs, api = _j.api, assertTagType = _j.assertTagType;\n    var patchQueryData = function(endpointName, args, patches, updateProvided) {\n        return function(dispatch, getState) {\n            var endpointDefinition = endpointDefinitions[endpointName];\n            var queryCacheKey = serializeQueryArgs({\n                queryArgs: args,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            dispatch(api.internalActions.queryResultPatched({\n                queryCacheKey: queryCacheKey,\n                patches: patches\n            }));\n            if (!updateProvided) {\n                return;\n            }\n            var newValue = api.endpoints[endpointName].select(args)(getState());\n            var providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n            dispatch(api.internalActions.updateProvidedBy({\n                queryCacheKey: queryCacheKey,\n                providedTags: providedTags\n            }));\n        };\n    };\n    var updateQueryData = function(endpointName, args, updateRecipe, updateProvided) {\n        if (updateProvided === void 0) {\n            updateProvided = true;\n        }\n        return function(dispatch, getState) {\n            var _j, _k;\n            var endpointDefinition = api.endpoints[endpointName];\n            var currentState = endpointDefinition.select(args)(getState());\n            var ret = {\n                patches: [],\n                inversePatches: [],\n                undo: function() {\n                    return dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided));\n                }\n            };\n            if (currentState.status === QueryStatus.uninitialized) {\n                return ret;\n            }\n            var newValue;\n            if (\"data\" in currentState) {\n                if ((0, import_immer.isDraftable)(currentState.data)) {\n                    var _l = (0, import_immer.produceWithPatches)(currentState.data, updateRecipe), value = _l[0], patches = _l[1], inversePatches = _l[2];\n                    (_j = ret.patches).push.apply(_j, patches);\n                    (_k = ret.inversePatches).push.apply(_k, inversePatches);\n                    newValue = value;\n                } else {\n                    newValue = updateRecipe(currentState.data);\n                    ret.patches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: newValue\n                    });\n                    ret.inversePatches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: currentState.data\n                    });\n                }\n            }\n            dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n            return ret;\n        };\n    };\n    var upsertQueryData = function(endpointName, args, value) {\n        return function(dispatch) {\n            var _j;\n            return dispatch(api.endpoints[endpointName].initiate(args, (_j = {\n                subscribe: false,\n                forceRefetch: true\n            }, _j[forceQueryFnSymbol] = function() {\n                return {\n                    data: value\n                };\n            }, _j)));\n        };\n    };\n    var executeEndpoint = function(_0, _1) {\n        return __async(_this, [\n            _0,\n            _1\n        ], function(arg, _j) {\n            var endpointDefinition, transformResponse, result, baseQueryApi_1, forceQueryFn, what, err, _k, _l, key, _m, error_1, catchedError, transformErrorResponse, _o, e_4;\n            var _p, _q;\n            var signal = _j.signal, abort = _j.abort, rejectWithValue = _j.rejectWithValue, fulfillWithValue = _j.fulfillWithValue, dispatch = _j.dispatch, getState = _j.getState, extra = _j.extra;\n            return __generator(this, function(_r) {\n                switch(_r.label){\n                    case 0:\n                        endpointDefinition = endpointDefinitions[arg.endpointName];\n                        _r.label = 1;\n                    case 1:\n                        _r.trys.push([\n                            1,\n                            8,\n                            ,\n                            13\n                        ]);\n                        transformResponse = defaultTransformResponse;\n                        result = void 0;\n                        baseQueryApi_1 = {\n                            signal: signal,\n                            abort: abort,\n                            dispatch: dispatch,\n                            getState: getState,\n                            extra: extra,\n                            endpoint: arg.endpointName,\n                            type: arg.type,\n                            forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n                        };\n                        forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n                        if (!forceQueryFn) return [\n                            3 /*break*/ ,\n                            2\n                        ];\n                        result = forceQueryFn();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 2:\n                        if (!endpointDefinition.query) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)\n                        ];\n                    case 3:\n                        result = _r.sent();\n                        if (endpointDefinition.transformResponse) {\n                            transformResponse = endpointDefinition.transformResponse;\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function(arg2) {\n                                return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);\n                            })\n                        ];\n                    case 5:\n                        result = _r.sent();\n                        _r.label = 6;\n                    case 6:\n                        if (typeof process !== \"undefined\" && true) {\n                            what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n                            err = void 0;\n                            if (!result) {\n                                err = what + \" did not return anything.\";\n                            } else if (typeof result !== \"object\") {\n                                err = what + \" did not return an object.\";\n                            } else if (result.error && result.data) {\n                                err = what + \" returned an object containing both `error` and `result`.\";\n                            } else if (result.error === void 0 && result.data === void 0) {\n                                err = what + \" returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`\";\n                            } else {\n                                for(_k = 0, _l = Object.keys(result); _k < _l.length; _k++){\n                                    key = _l[_k];\n                                    if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                                        err = \"The object returned by \" + what + \" has the unknown property \" + key + \".\";\n                                        break;\n                                    }\n                                }\n                            }\n                            if (err) {\n                                console.error(\"Error encountered handling the endpoint \" + arg.endpointName + \".\\n              \" + err + \"\\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\\n              Object returned was:\", result);\n                            }\n                        }\n                        if (result.error) throw new HandledError(result.error, result.meta);\n                        _m = fulfillWithValue;\n                        return [\n                            4 /*yield*/ ,\n                            transformResponse(result.data, result.meta, arg.originalArgs)\n                        ];\n                    case 7:\n                        return [\n                            2 /*return*/ ,\n                            _m.apply(void 0, [\n                                _r.sent(),\n                                (_p = {\n                                    fulfilledTimeStamp: Date.now(),\n                                    baseQueryMeta: result.meta\n                                }, _p[import_toolkit5.SHOULD_AUTOBATCH] = true, _p)\n                            ])\n                        ];\n                    case 8:\n                        error_1 = _r.sent();\n                        catchedError = error_1;\n                        if (!(catchedError instanceof HandledError)) return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                        transformErrorResponse = defaultTransformResponse;\n                        if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n                            transformErrorResponse = endpointDefinition.transformErrorResponse;\n                        }\n                        _r.label = 9;\n                    case 9:\n                        _r.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        _o = rejectWithValue;\n                        return [\n                            4 /*yield*/ ,\n                            transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs)\n                        ];\n                    case 10:\n                        return [\n                            2 /*return*/ ,\n                            _o.apply(void 0, [\n                                _r.sent(),\n                                (_q = {\n                                    baseQueryMeta: catchedError.meta\n                                }, _q[import_toolkit5.SHOULD_AUTOBATCH] = true, _q)\n                            ])\n                        ];\n                    case 11:\n                        e_4 = _r.sent();\n                        catchedError = e_4;\n                        return [\n                            3 /*break*/ ,\n                            12\n                        ];\n                    case 12:\n                        if (typeof process !== \"undefined\" && true) {\n                            console.error('An unhandled error occurred processing a request for the endpoint \"' + arg.endpointName + '\".\\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".', catchedError);\n                        } else {\n                            console.error(catchedError);\n                        }\n                        throw catchedError;\n                    case 13:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    function isForcedQuery(arg, state) {\n        var _a, _b, _c, _d;\n        var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];\n        var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;\n        var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n        var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;\n        if (refetchVal) {\n            return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n        }\n        return false;\n    }\n    var queryThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + \"/executeQuery\", executeEndpoint, {\n        getPendingMeta: function() {\n            var _j;\n            return _j = {\n                startedTimeStamp: Date.now()\n            }, _j[import_toolkit5.SHOULD_AUTOBATCH] = true, _j;\n        },\n        condition: function(queryThunkArgs, _j) {\n            var getState = _j.getState;\n            var _a, _b, _c;\n            var state = getState();\n            var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[queryThunkArgs.queryCacheKey];\n            var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n            var currentArg = queryThunkArgs.originalArgs;\n            var previousArg = requestState == null ? void 0 : requestState.originalArgs;\n            var endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n            if (isUpsertQuery(queryThunkArgs)) {\n                return true;\n            }\n            if ((requestState == null ? void 0 : requestState.status) === \"pending\") {\n                return false;\n            }\n            if (isForcedQuery(queryThunkArgs, state)) {\n                return true;\n            }\n            if (isQueryDefinition(endpointDefinition) && ((_c = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _c.call(endpointDefinition, {\n                currentArg: currentArg,\n                previousArg: previousArg,\n                endpointState: requestState,\n                state: state\n            }))) {\n                return true;\n            }\n            if (fulfilledVal) {\n                return false;\n            }\n            return true;\n        },\n        dispatchConditionRejection: true\n    });\n    var mutationThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + \"/executeMutation\", executeEndpoint, {\n        getPendingMeta: function() {\n            var _j;\n            return _j = {\n                startedTimeStamp: Date.now()\n            }, _j[import_toolkit5.SHOULD_AUTOBATCH] = true, _j;\n        }\n    });\n    var hasTheForce = function(options) {\n        return \"force\" in options;\n    };\n    var hasMaxAge = function(options) {\n        return \"ifOlderThan\" in options;\n    };\n    var prefetch = function(endpointName, arg, options) {\n        return function(dispatch, getState) {\n            var force = hasTheForce(options) && options.force;\n            var maxAge = hasMaxAge(options) && options.ifOlderThan;\n            var queryAction = function(force2) {\n                if (force2 === void 0) {\n                    force2 = true;\n                }\n                return api.endpoints[endpointName].initiate(arg, {\n                    forceRefetch: force2\n                });\n            };\n            var latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n            if (force) {\n                dispatch(queryAction());\n            } else if (maxAge) {\n                var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;\n                if (!lastFulfilledTs) {\n                    dispatch(queryAction());\n                    return;\n                }\n                var shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n                if (shouldRetrigger) {\n                    dispatch(queryAction());\n                }\n            } else {\n                dispatch(queryAction(false));\n            }\n        };\n    };\n    function matchesEndpoint(endpointName) {\n        return function(action) {\n            var _a, _b;\n            return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;\n        };\n    }\n    function buildMatchThunkActions(thunk, endpointName) {\n        return {\n            matchPending: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isPending)(thunk), matchesEndpoint(endpointName)),\n            matchFulfilled: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n            matchRejected: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isRejected)(thunk), matchesEndpoint(endpointName))\n        };\n    }\n    return {\n        queryThunk: queryThunk,\n        mutationThunk: mutationThunk,\n        prefetch: prefetch,\n        updateQueryData: updateQueryData,\n        upsertQueryData: upsertQueryData,\n        patchQueryData: patchQueryData,\n        buildMatchThunkActions: buildMatchThunkActions\n    };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0, import_toolkit4.isFulfilled)(action) ? action.payload : void 0, (0, import_toolkit4.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n// src/query/core/buildSlice.ts\nvar import_immer2 = __toModule(__webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\"));\nvar import_immer3 = __toModule(__webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\"));\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n    var substate = state[queryCacheKey];\n    if (substate) {\n        update(substate);\n    }\n}\nfunction getMutationCacheKey(id) {\n    var _a;\n    return (_a = \"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) != null ? _a : id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n    var substate = state[getMutationCacheKey(id)];\n    if (substate) {\n        update(substate);\n    }\n}\nvar initialState = {};\nfunction buildSlice(_j) {\n    var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, _k = _j.context, definitions = _k.endpointDefinitions, apiUid = _k.apiUid, extractRehydrationInfo = _k.extractRehydrationInfo, hasRehydrationInfo = _k.hasRehydrationInfo, assertTagType = _j.assertTagType, config = _j.config;\n    var resetApiState = (0, import_toolkit6.createAction)(reducerPath + \"/resetApiState\");\n    var querySlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/queries\",\n        initialState: initialState,\n        reducers: {\n            removeQueryResult: {\n                reducer: function(draft, _j) {\n                    var queryCacheKey = _j.payload.queryCacheKey;\n                    delete draft[queryCacheKey];\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            },\n            queryResultPatched: {\n                reducer: function(draft, _j) {\n                    var _k = _j.payload, queryCacheKey = _k.queryCacheKey, patches = _k.patches;\n                    updateQuerySubstateIfExists(draft, queryCacheKey, function(substate) {\n                        substate.data = (0, import_immer3.applyPatches)(substate.data, patches.concat());\n                    });\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(queryThunk.pending, function(draft, _j) {\n                var meta = _j.meta, arg = _j.meta.arg;\n                var _a, _b;\n                var upserting = isUpsertQuery(arg);\n                if (arg.subscribe || upserting) {\n                    (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {\n                        status: QueryStatus.uninitialized,\n                        endpointName: arg.endpointName\n                    };\n                }\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {\n                    substate.status = QueryStatus.pending;\n                    substate.requestId = upserting && substate.requestId ? substate.requestId : meta.requestId;\n                    if (arg.originalArgs !== void 0) {\n                        substate.originalArgs = arg.originalArgs;\n                    }\n                    substate.startedTimeStamp = meta.startedTimeStamp;\n                });\n            }).addCase(queryThunk.fulfilled, function(draft, _j) {\n                var meta = _j.meta, payload = _j.payload;\n                updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function(substate) {\n                    var _a;\n                    if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n                    var merge = definitions[meta.arg.endpointName].merge;\n                    substate.status = QueryStatus.fulfilled;\n                    if (merge) {\n                        if (substate.data !== void 0) {\n                            var fulfilledTimeStamp_1 = meta.fulfilledTimeStamp, arg_1 = meta.arg, baseQueryMeta_1 = meta.baseQueryMeta, requestId_1 = meta.requestId;\n                            var newData = (0, import_toolkit6.createNextState)(substate.data, function(draftSubstateData) {\n                                return merge(draftSubstateData, payload, {\n                                    arg: arg_1.originalArgs,\n                                    baseQueryMeta: baseQueryMeta_1,\n                                    fulfilledTimeStamp: fulfilledTimeStamp_1,\n                                    requestId: requestId_1\n                                });\n                            });\n                            substate.data = newData;\n                        } else {\n                            substate.data = payload;\n                        }\n                    } else {\n                        substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing((0, import_immer2.isDraft)(substate.data) ? (0, import_immer3.original)(substate.data) : substate.data, payload) : payload;\n                    }\n                    delete substate.error;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(queryThunk.rejected, function(draft, _j) {\n                var _k = _j.meta, condition = _k.condition, arg = _k.arg, requestId = _k.requestId, error = _j.error, payload = _j.payload;\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {\n                    if (condition) {} else {\n                        if (substate.requestId !== requestId) return;\n                        substate.status = QueryStatus.rejected;\n                        substate.error = payload != null ? payload : error;\n                    }\n                });\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var queries = extractRehydrationInfo(action).queries;\n                for(var _j = 0, _k = Object.entries(queries); _j < _k.length; _j++){\n                    var _l = _k[_j], key = _l[0], entry = _l[1];\n                    if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    var mutationSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/mutations\",\n        initialState: initialState,\n        reducers: {\n            removeMutationResult: {\n                reducer: function(draft, _j) {\n                    var payload = _j.payload;\n                    var cacheKey = getMutationCacheKey(payload);\n                    if (cacheKey in draft) {\n                        delete draft[cacheKey];\n                    }\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(mutationThunk.pending, function(draft, _j) {\n                var meta = _j.meta, _k = _j.meta, requestId = _k.requestId, arg = _k.arg, startedTimeStamp = _k.startedTimeStamp;\n                if (!arg.track) return;\n                draft[getMutationCacheKey(meta)] = {\n                    requestId: requestId,\n                    status: QueryStatus.pending,\n                    endpointName: arg.endpointName,\n                    startedTimeStamp: startedTimeStamp\n                };\n            }).addCase(mutationThunk.fulfilled, function(draft, _j) {\n                var payload = _j.payload, meta = _j.meta;\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, function(substate) {\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = QueryStatus.fulfilled;\n                    substate.data = payload;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(mutationThunk.rejected, function(draft, _j) {\n                var payload = _j.payload, error = _j.error, meta = _j.meta;\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, function(substate) {\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = QueryStatus.rejected;\n                    substate.error = payload != null ? payload : error;\n                });\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var mutations = extractRehydrationInfo(action).mutations;\n                for(var _j = 0, _k = Object.entries(mutations); _j < _k.length; _j++){\n                    var _l = _k[_j], key = _l[0], entry = _l[1];\n                    if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    var invalidationSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/invalidation\",\n        initialState: initialState,\n        reducers: {\n            updateProvidedBy: {\n                reducer: function(draft, action) {\n                    var _a, _b, _c, _d;\n                    var _j = action.payload, queryCacheKey = _j.queryCacheKey, providedTags = _j.providedTags;\n                    for(var _k = 0, _l = Object.values(draft); _k < _l.length; _k++){\n                        var tagTypeSubscriptions = _l[_k];\n                        for(var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++){\n                            var idSubscriptions = _o[_m];\n                            var foundAt = idSubscriptions.indexOf(queryCacheKey);\n                            if (foundAt !== -1) {\n                                idSubscriptions.splice(foundAt, 1);\n                            }\n                        }\n                    }\n                    for(var _p = 0, providedTags_1 = providedTags; _p < providedTags_1.length; _p++){\n                        var _q = providedTags_1[_p], type = _q.type, id = _q.id;\n                        var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n                        var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                        if (!alreadySubscribed) {\n                            subscribedQueries.push(queryCacheKey);\n                        }\n                    }\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(querySlice.actions.removeQueryResult, function(draft, _j) {\n                var queryCacheKey = _j.payload.queryCacheKey;\n                for(var _k = 0, _l = Object.values(draft); _k < _l.length; _k++){\n                    var tagTypeSubscriptions = _l[_k];\n                    for(var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++){\n                        var idSubscriptions = _o[_m];\n                        var foundAt = idSubscriptions.indexOf(queryCacheKey);\n                        if (foundAt !== -1) {\n                            idSubscriptions.splice(foundAt, 1);\n                        }\n                    }\n                }\n            }).addMatcher(hasRehydrationInfo, function(draft, action) {\n                var _a, _b, _c, _d;\n                var provided = extractRehydrationInfo(action).provided;\n                for(var _j = 0, _k = Object.entries(provided); _j < _k.length; _j++){\n                    var _l = _k[_j], type = _l[0], incomingTags = _l[1];\n                    for(var _m = 0, _o = Object.entries(incomingTags); _m < _o.length; _m++){\n                        var _p = _o[_m], id = _p[0], cacheKeys = _p[1];\n                        var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n                        for(var _q = 0, cacheKeys_1 = cacheKeys; _q < cacheKeys_1.length; _q++){\n                            var queryCacheKey = cacheKeys_1[_q];\n                            var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                            if (!alreadySubscribed) {\n                                subscribedQueries.push(queryCacheKey);\n                            }\n                        }\n                    }\n                }\n            }).addMatcher((0, import_toolkit6.isAnyOf)((0, import_toolkit6.isFulfilled)(queryThunk), (0, import_toolkit6.isRejectedWithValue)(queryThunk)), function(draft, action) {\n                var providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n                var queryCacheKey = action.meta.arg.queryCacheKey;\n                invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n                    queryCacheKey: queryCacheKey,\n                    providedTags: providedTags\n                }));\n            });\n        }\n    });\n    var subscriptionSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/subscriptions\",\n        initialState: initialState,\n        reducers: {\n            updateSubscriptionOptions: function(d, a) {},\n            unsubscribeQueryResult: function(d, a) {},\n            internal_probeSubscription: function(d, a) {}\n        }\n    });\n    var internalSubscriptionsSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/internalSubscriptions\",\n        initialState: initialState,\n        reducers: {\n            subscriptionsUpdated: {\n                reducer: function(state, action) {\n                    return (0, import_immer3.applyPatches)(state, action.payload);\n                },\n                prepare: (0, import_toolkit6.prepareAutoBatched)()\n            }\n        }\n    });\n    var configSlice = (0, import_toolkit6.createSlice)({\n        name: reducerPath + \"/config\",\n        initialState: __spreadValues({\n            online: isOnline(),\n            focused: isDocumentVisible(),\n            middlewareRegistered: false\n        }, config),\n        reducers: {\n            middlewareRegistered: function(state, _j) {\n                var payload = _j.payload;\n                state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n            }\n        },\n        extraReducers: function(builder) {\n            builder.addCase(onOnline, function(state) {\n                state.online = true;\n            }).addCase(onOffline, function(state) {\n                state.online = false;\n            }).addCase(onFocus, function(state) {\n                state.focused = true;\n            }).addCase(onFocusLost, function(state) {\n                state.focused = false;\n            }).addMatcher(hasRehydrationInfo, function(draft) {\n                return __spreadValues({}, draft);\n            });\n        }\n    });\n    var combinedReducer = (0, import_toolkit6.combineReducers)({\n        queries: querySlice.reducer,\n        mutations: mutationSlice.reducer,\n        provided: invalidationSlice.reducer,\n        subscriptions: internalSubscriptionsSlice.reducer,\n        config: configSlice.reducer\n    });\n    var reducer = function(state, action) {\n        return combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n    };\n    var actions = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), internalSubscriptionsSlice.actions), mutationSlice.actions), invalidationSlice.actions), {\n        unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,\n        resetApiState: resetApiState\n    });\n    return {\n        reducer: reducer,\n        actions: actions\n    };\n}\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar skipSelector = skipToken;\nvar initialSubState = {\n    status: QueryStatus.uninitialized\n};\nvar defaultQuerySubState = /* @__PURE__ */ (0, import_toolkit7.createNextState)(initialSubState, function() {});\nvar defaultMutationSubState = /* @__PURE__ */ (0, import_toolkit7.createNextState)(initialSubState, function() {});\nfunction buildSelectors(_j) {\n    var serializeQueryArgs = _j.serializeQueryArgs, reducerPath = _j.reducerPath;\n    var selectSkippedQuery = function(state) {\n        return defaultQuerySubState;\n    };\n    var selectSkippedMutation = function(state) {\n        return defaultMutationSubState;\n    };\n    return {\n        buildQuerySelector: buildQuerySelector,\n        buildMutationSelector: buildMutationSelector,\n        selectInvalidatedBy: selectInvalidatedBy\n    };\n    function withRequestFlags(substate) {\n        return __spreadValues(__spreadValues({}, substate), getRequestStatusFlags(substate.status));\n    }\n    function selectInternalState(rootState) {\n        var state = rootState[reducerPath];\n        if (true) {\n            if (!state) {\n                if (selectInternalState.triggered) return state;\n                selectInternalState.triggered = true;\n                console.error(\"Error: No data found at `state.\" + reducerPath + \"`. Did you forget to add the reducer to the store?\");\n            }\n        }\n        return state;\n    }\n    function buildQuerySelector(endpointName, endpointDefinition) {\n        return function(queryArgs) {\n            var serializedArgs = serializeQueryArgs({\n                queryArgs: queryArgs,\n                endpointDefinition: endpointDefinition,\n                endpointName: endpointName\n            });\n            var selectQuerySubstate = function(state) {\n                var _a, _b, _c;\n                return (_c = (_b = (_a = selectInternalState(state)) == null ? void 0 : _a.queries) == null ? void 0 : _b[serializedArgs]) != null ? _c : defaultQuerySubState;\n            };\n            var finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n            return (0, import_toolkit7.createSelector)(finalSelectQuerySubState, withRequestFlags);\n        };\n    }\n    function buildMutationSelector() {\n        return function(id) {\n            var _a;\n            var mutationId;\n            if (typeof id === \"object\") {\n                mutationId = (_a = getMutationCacheKey(id)) != null ? _a : skipToken;\n            } else {\n                mutationId = id;\n            }\n            var selectMutationSubstate = function(state) {\n                var _a2, _b, _c;\n                return (_c = (_b = (_a2 = selectInternalState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;\n            };\n            var finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n            return (0, import_toolkit7.createSelector)(finalSelectMutationSubstate, withRequestFlags);\n        };\n    }\n    function selectInvalidatedBy(state, tags) {\n        var _a;\n        var apiState = state[reducerPath];\n        var toInvalidate = new Set();\n        for(var _j = 0, _k = tags.map(expandTagDescription); _j < _k.length; _j++){\n            var tag = _k[_j];\n            var provided = apiState.provided[tag.type];\n            if (!provided) {\n                continue;\n            }\n            var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];\n            for(var _l = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _l < invalidateSubscriptions_1.length; _l++){\n                var invalidate = invalidateSubscriptions_1[_l];\n                toInvalidate.add(invalidate);\n            }\n        }\n        return flatten(Array.from(toInvalidate.values()).map(function(queryCacheKey) {\n            var querySubState = apiState.queries[queryCacheKey];\n            return querySubState ? [\n                {\n                    queryCacheKey: queryCacheKey,\n                    endpointName: querySubState.endpointName,\n                    originalArgs: querySubState.originalArgs\n                }\n            ] : [];\n        }));\n    }\n}\n// src/query/defaultSerializeQueryArgs.ts\nvar import_toolkit8 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar cache = WeakMap ? new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = function(_j) {\n    var endpointName = _j.endpointName, queryArgs = _j.queryArgs;\n    var serialized = \"\";\n    var cached = cache == null ? void 0 : cache.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        var stringified = JSON.stringify(queryArgs, function(key, value) {\n            return (0, import_toolkit8.isPlainObject)(value) ? Object.keys(value).sort().reduce(function(acc, key2) {\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value;\n        });\n        if ((0, import_toolkit8.isPlainObject)(queryArgs)) {\n            cache == null ? void 0 : cache.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return endpointName + \"(\" + serialized + \")\";\n};\n// src/query/createApi.ts\nvar import_toolkit9 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar import_reselect = __toModule(__webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/es/index.js\"));\nfunction buildCreateApi() {\n    var modules = [];\n    for(var _j = 0; _j < arguments.length; _j++){\n        modules[_j] = arguments[_j];\n    }\n    return function baseCreateApi(options) {\n        var extractRehydrationInfo = (0, import_reselect.defaultMemoize)(function(action) {\n            var _a, _b;\n            return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {\n                reducerPath: (_a = options.reducerPath) != null ? _a : \"api\"\n            });\n        });\n        var optionsWithDefaults = __spreadProps(__spreadValues({\n            reducerPath: \"api\",\n            keepUnusedDataFor: 60,\n            refetchOnMountOrArgChange: false,\n            refetchOnFocus: false,\n            refetchOnReconnect: false\n        }, options), {\n            extractRehydrationInfo: extractRehydrationInfo,\n            serializeQueryArgs: function(queryArgsApi) {\n                var finalSerializeQueryArgs = defaultSerializeQueryArgs;\n                if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n                    var endpointSQA_1 = queryArgsApi.endpointDefinition.serializeQueryArgs;\n                    finalSerializeQueryArgs = function(queryArgsApi2) {\n                        var initialResult = endpointSQA_1(queryArgsApi2);\n                        if (typeof initialResult === \"string\") {\n                            return initialResult;\n                        } else {\n                            return defaultSerializeQueryArgs(__spreadProps(__spreadValues({}, queryArgsApi2), {\n                                queryArgs: initialResult\n                            }));\n                        }\n                    };\n                } else if (options.serializeQueryArgs) {\n                    finalSerializeQueryArgs = options.serializeQueryArgs;\n                }\n                return finalSerializeQueryArgs(queryArgsApi);\n            },\n            tagTypes: __spreadArray([], options.tagTypes || [])\n        });\n        var context = {\n            endpointDefinitions: {},\n            batch: function(fn) {\n                fn();\n            },\n            apiUid: (0, import_toolkit9.nanoid)(),\n            extractRehydrationInfo: extractRehydrationInfo,\n            hasRehydrationInfo: (0, import_reselect.defaultMemoize)(function(action) {\n                return extractRehydrationInfo(action) != null;\n            })\n        };\n        var api = {\n            injectEndpoints: injectEndpoints,\n            enhanceEndpoints: function(_j) {\n                var addTagTypes = _j.addTagTypes, endpoints = _j.endpoints;\n                if (addTagTypes) {\n                    for(var _k = 0, addTagTypes_1 = addTagTypes; _k < addTagTypes_1.length; _k++){\n                        var eT = addTagTypes_1[_k];\n                        if (!optionsWithDefaults.tagTypes.includes(eT)) {\n                            ;\n                            optionsWithDefaults.tagTypes.push(eT);\n                        }\n                    }\n                }\n                if (endpoints) {\n                    for(var _l = 0, _m = Object.entries(endpoints); _l < _m.length; _l++){\n                        var _o = _m[_l], endpointName = _o[0], partialDefinition = _o[1];\n                        if (typeof partialDefinition === \"function\") {\n                            partialDefinition(context.endpointDefinitions[endpointName]);\n                        } else {\n                            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n                        }\n                    }\n                }\n                return api;\n            }\n        };\n        var initializedModules = modules.map(function(m) {\n            return m.init(api, optionsWithDefaults, context);\n        });\n        function injectEndpoints(inject) {\n            var evaluatedEndpoints = inject.endpoints({\n                query: function(x) {\n                    return __spreadProps(__spreadValues({}, x), {\n                        type: DefinitionType.query\n                    });\n                },\n                mutation: function(x) {\n                    return __spreadProps(__spreadValues({}, x), {\n                        type: DefinitionType.mutation\n                    });\n                }\n            });\n            for(var _j = 0, _k = Object.entries(evaluatedEndpoints); _j < _k.length; _j++){\n                var _l = _k[_j], endpointName = _l[0], definition = _l[1];\n                if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {\n                    if (typeof process !== \"undefined\" && true) {\n                        console.error(\"called `injectEndpoints` to override already-existing endpointName \" + endpointName + \" without specifying `overrideExisting: true`\");\n                    }\n                    continue;\n                }\n                context.endpointDefinitions[endpointName] = definition;\n                for(var _m = 0, initializedModules_1 = initializedModules; _m < initializedModules_1.length; _m++){\n                    var m = initializedModules_1[_m];\n                    m.injectEndpoint(endpointName, definition);\n                }\n            }\n            return api;\n        }\n        return api.injectEndpoints({\n            endpoints: options.endpoints\n        });\n    };\n}\n// src/query/fakeBaseQuery.ts\nfunction fakeBaseQuery() {\n    return function() {\n        throw new Error(\"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n    };\n}\n// src/query/core/buildMiddleware/index.ts\nvar import_toolkit13 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n    for(var k in obj){\n        return false;\n    }\n    return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = function(_j) {\n    var reducerPath = _j.reducerPath, api = _j.api, context = _j.context, internalState = _j.internalState;\n    var _k = api.internalActions, removeQueryResult = _k.removeQueryResult, unsubscribeQueryResult = _k.unsubscribeQueryResult;\n    function anySubscriptionsRemainingForKey(queryCacheKey) {\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        return !!subscriptions && !isObjectEmpty(subscriptions);\n    }\n    var currentRemovalTimeouts = {};\n    var handler = function(action, mwApi, internalState2) {\n        var _a;\n        if (unsubscribeQueryResult.match(action)) {\n            var state = mwApi.getState()[reducerPath];\n            var queryCacheKey = action.payload.queryCacheKey;\n            handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);\n        }\n        if (api.util.resetApiState.match(action)) {\n            for(var _j = 0, _k = Object.entries(currentRemovalTimeouts); _j < _k.length; _j++){\n                var _l = _k[_j], key = _l[0], timeout = _l[1];\n                if (timeout) clearTimeout(timeout);\n                delete currentRemovalTimeouts[key];\n            }\n        }\n        if (context.hasRehydrationInfo(action)) {\n            var state = mwApi.getState()[reducerPath];\n            var queries = context.extractRehydrationInfo(action).queries;\n            for(var _m = 0, _o = Object.entries(queries); _m < _o.length; _m++){\n                var _p = _o[_m], queryCacheKey = _p[0], queryState = _p[1];\n                handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);\n            }\n        }\n    };\n    function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n        var _a;\n        var endpointDefinition = context.endpointDefinitions[endpointName];\n        var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config.keepUnusedDataFor;\n        if (keepUnusedDataFor === Infinity) {\n            return;\n        }\n        var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n            var currentTimeout = currentRemovalTimeouts[queryCacheKey];\n            if (currentTimeout) {\n                clearTimeout(currentTimeout);\n            }\n            currentRemovalTimeouts[queryCacheKey] = setTimeout(function() {\n                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n                    api2.dispatch(removeQueryResult({\n                        queryCacheKey: queryCacheKey\n                    }));\n                }\n                delete currentRemovalTimeouts[queryCacheKey];\n            }, finalKeepUnusedDataFor * 1e3);\n        }\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar import_toolkit10 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar buildInvalidationByTagsHandler = function(_j) {\n    var reducerPath = _j.reducerPath, context = _j.context, endpointDefinitions = _j.context.endpointDefinitions, mutationThunk = _j.mutationThunk, api = _j.api, assertTagType = _j.assertTagType, refetchQuery = _j.refetchQuery;\n    var removeQueryResult = api.internalActions.removeQueryResult;\n    var isThunkActionWithTags = (0, import_toolkit10.isAnyOf)((0, import_toolkit10.isFulfilled)(mutationThunk), (0, import_toolkit10.isRejectedWithValue)(mutationThunk));\n    var handler = function(action, mwApi) {\n        if (isThunkActionWithTags(action)) {\n            invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n        }\n        if (api.util.invalidateTags.match(action)) {\n            invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n        }\n    };\n    function invalidateTags(tags, mwApi) {\n        var rootState = mwApi.getState();\n        var state = rootState[reducerPath];\n        var toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n        context.batch(function() {\n            var _a;\n            var valuesArray = Array.from(toInvalidate.values());\n            for(var _j = 0, valuesArray_1 = valuesArray; _j < valuesArray_1.length; _j++){\n                var queryCacheKey = valuesArray_1[_j].queryCacheKey;\n                var querySubState = state.queries[queryCacheKey];\n                var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};\n                if (querySubState) {\n                    if (Object.keys(subscriptionSubState).length === 0) {\n                        mwApi.dispatch(removeQueryResult({\n                            queryCacheKey: queryCacheKey\n                        }));\n                    } else if (querySubState.status !== QueryStatus.uninitialized) {\n                        mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = function(_j) {\n    var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, api = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;\n    var currentPolls = {};\n    var handler = function(action, mwApi) {\n        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n            updatePollingInterval(action.payload, mwApi);\n        }\n        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n            updatePollingInterval(action.meta.arg, mwApi);\n        }\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n            startNextPoll(action.meta.arg, mwApi);\n        }\n        if (api.util.resetApiState.match(action)) {\n            clearPolls();\n        }\n    };\n    function startNextPoll(_j, api2) {\n        var queryCacheKey = _j.queryCacheKey;\n        var state = api2.getState()[reducerPath];\n        var querySubState = state.queries[queryCacheKey];\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === QueryStatus.uninitialized) return;\n        var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) return;\n        var currentPoll = currentPolls[queryCacheKey];\n        if (currentPoll == null ? void 0 : currentPoll.timeout) {\n            clearTimeout(currentPoll.timeout);\n            currentPoll.timeout = void 0;\n        }\n        var nextPollTimestamp = Date.now() + lowestPollingInterval;\n        var currentInterval = currentPolls[queryCacheKey] = {\n            nextPollTimestamp: nextPollTimestamp,\n            pollingInterval: lowestPollingInterval,\n            timeout: setTimeout(function() {\n                currentInterval.timeout = void 0;\n                api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n            }, lowestPollingInterval)\n        };\n    }\n    function updatePollingInterval(_j, api2) {\n        var queryCacheKey = _j.queryCacheKey;\n        var state = api2.getState()[reducerPath];\n        var querySubState = state.queries[queryCacheKey];\n        var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === QueryStatus.uninitialized) {\n            return;\n        }\n        var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) {\n            cleanupPollForKey(queryCacheKey);\n            return;\n        }\n        var currentPoll = currentPolls[queryCacheKey];\n        var nextPollTimestamp = Date.now() + lowestPollingInterval;\n        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n            startNextPoll({\n                queryCacheKey: queryCacheKey\n            }, api2);\n        }\n    }\n    function cleanupPollForKey(key) {\n        var existingPoll = currentPolls[key];\n        if (existingPoll == null ? void 0 : existingPoll.timeout) {\n            clearTimeout(existingPoll.timeout);\n        }\n        delete currentPolls[key];\n    }\n    function clearPolls() {\n        for(var _j = 0, _k = Object.keys(currentPolls); _j < _k.length; _j++){\n            var key = _k[_j];\n            cleanupPollForKey(key);\n        }\n    }\n    function findLowestPollingInterval(subscribers) {\n        if (subscribers === void 0) {\n            subscribers = {};\n        }\n        var lowestPollingInterval = Number.POSITIVE_INFINITY;\n        for(var key in subscribers){\n            if (!!subscribers[key].pollingInterval) {\n                lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n            }\n        }\n        return lowestPollingInterval;\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = function(_j) {\n    var reducerPath = _j.reducerPath, context = _j.context, api = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;\n    var removeQueryResult = api.internalActions.removeQueryResult;\n    var handler = function(action, mwApi) {\n        if (onFocus.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnFocus\");\n        }\n        if (onOnline.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnReconnect\");\n        }\n    };\n    function refetchValidQueries(api2, type) {\n        var state = api2.getState()[reducerPath];\n        var queries = state.queries;\n        var subscriptions = internalState.currentSubscriptions;\n        context.batch(function() {\n            for(var _j = 0, _k = Object.keys(subscriptions); _j < _k.length; _j++){\n                var queryCacheKey = _k[_j];\n                var querySubState = queries[queryCacheKey];\n                var subscriptionSubState = subscriptions[queryCacheKey];\n                if (!subscriptionSubState || !querySubState) continue;\n                var shouldRefetch = Object.values(subscriptionSubState).some(function(sub) {\n                    return sub[type] === true;\n                }) || Object.values(subscriptionSubState).every(function(sub) {\n                    return sub[type] === void 0;\n                }) && state.config[type];\n                if (shouldRefetch) {\n                    if (Object.keys(subscriptionSubState).length === 0) {\n                        api2.dispatch(removeQueryResult({\n                            queryCacheKey: queryCacheKey\n                        }));\n                    } else if (querySubState.status !== QueryStatus.uninitialized) {\n                        api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar import_toolkit11 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = function(_j) {\n    var api = _j.api, reducerPath = _j.reducerPath, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, internalState = _j.internalState;\n    var isQueryThunk = (0, import_toolkit11.isAsyncThunkAction)(queryThunk);\n    var isMutationThunk = (0, import_toolkit11.isAsyncThunkAction)(mutationThunk);\n    var isFulfilledThunk = (0, import_toolkit11.isFulfilled)(queryThunk, mutationThunk);\n    var lifecycleMap = {};\n    var handler = function(action, mwApi, stateBefore) {\n        var cacheKey = getCacheKey(action);\n        if (queryThunk.pending.match(action)) {\n            var oldState = stateBefore[reducerPath].queries[cacheKey];\n            var state = mwApi.getState()[reducerPath].queries[cacheKey];\n            if (!oldState && state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (mutationThunk.pending.match(action)) {\n            var state = mwApi.getState()[reducerPath].mutations[cacheKey];\n            if (state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (isFulfilledThunk(action)) {\n            var lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle == null ? void 0 : lifecycle.valueResolved) {\n                lifecycle.valueResolved({\n                    data: action.payload,\n                    meta: action.meta.baseQueryMeta\n                });\n                delete lifecycle.valueResolved;\n            }\n        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n            var lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle) {\n                delete lifecycleMap[cacheKey];\n                lifecycle.cacheEntryRemoved();\n            }\n        } else if (api.util.resetApiState.match(action)) {\n            for(var _j = 0, _k = Object.entries(lifecycleMap); _j < _k.length; _j++){\n                var _l = _k[_j], cacheKey2 = _l[0], lifecycle = _l[1];\n                delete lifecycleMap[cacheKey2];\n                lifecycle.cacheEntryRemoved();\n            }\n        }\n    };\n    function getCacheKey(action) {\n        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n        if (isMutationThunk(action)) return action.meta.requestId;\n        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n        return \"\";\n    }\n    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n        var endpointDefinition = context.endpointDefinitions[endpointName];\n        var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;\n        if (!onCacheEntryAdded) return;\n        var lifecycle = {};\n        var cacheEntryRemoved = new Promise(function(resolve) {\n            lifecycle.cacheEntryRemoved = resolve;\n        });\n        var cacheDataLoaded = Promise.race([\n            new Promise(function(resolve) {\n                lifecycle.valueResolved = resolve;\n            }),\n            cacheEntryRemoved.then(function() {\n                throw neverResolvedError;\n            })\n        ]);\n        cacheDataLoaded.catch(function() {});\n        lifecycleMap[queryCacheKey] = lifecycle;\n        var selector = api.endpoints[endpointName].select(endpointDefinition.type === DefinitionType.query ? originalArgs : queryCacheKey);\n        var extra = mwApi.dispatch(function(_, __, extra2) {\n            return extra2;\n        });\n        var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n            getCacheEntry: function() {\n                return selector(mwApi.getState());\n            },\n            requestId: requestId,\n            extra: extra,\n            updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {\n                return mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe));\n            } : void 0,\n            cacheDataLoaded: cacheDataLoaded,\n            cacheEntryRemoved: cacheEntryRemoved\n        });\n        var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n        Promise.resolve(runningHandler).catch(function(e) {\n            if (e === neverResolvedError) return;\n            throw e;\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar import_toolkit12 = __toModule(__webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\"));\nvar buildQueryLifecycleHandler = function(_j) {\n    var api = _j.api, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;\n    var isPendingThunk = (0, import_toolkit12.isPending)(queryThunk, mutationThunk);\n    var isRejectedThunk = (0, import_toolkit12.isRejected)(queryThunk, mutationThunk);\n    var isFullfilledThunk = (0, import_toolkit12.isFulfilled)(queryThunk, mutationThunk);\n    var lifecycleMap = {};\n    var handler = function(action, mwApi) {\n        var _a, _b, _c;\n        if (isPendingThunk(action)) {\n            var _j = action.meta, requestId = _j.requestId, _k = _j.arg, endpointName_1 = _k.endpointName, originalArgs_1 = _k.originalArgs;\n            var endpointDefinition = context.endpointDefinitions[endpointName_1];\n            var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;\n            if (onQueryStarted) {\n                var lifecycle_1 = {};\n                var queryFulfilled = new Promise(function(resolve, reject) {\n                    lifecycle_1.resolve = resolve;\n                    lifecycle_1.reject = reject;\n                });\n                queryFulfilled.catch(function() {});\n                lifecycleMap[requestId] = lifecycle_1;\n                var selector_1 = api.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType.query ? originalArgs_1 : requestId);\n                var extra = mwApi.dispatch(function(_, __, extra2) {\n                    return extra2;\n                });\n                var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n                    getCacheEntry: function() {\n                        return selector_1(mwApi.getState());\n                    },\n                    requestId: requestId,\n                    extra: extra,\n                    updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {\n                        return mwApi.dispatch(api.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));\n                    } : void 0,\n                    queryFulfilled: queryFulfilled\n                });\n                onQueryStarted(originalArgs_1, lifecycleApi);\n            }\n        } else if (isFullfilledThunk(action)) {\n            var _l = action.meta, requestId = _l.requestId, baseQueryMeta = _l.baseQueryMeta;\n            (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({\n                data: action.payload,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        } else if (isRejectedThunk(action)) {\n            var _m = action.meta, requestId = _m.requestId, rejectedWithValue = _m.rejectedWithValue, baseQueryMeta = _m.baseQueryMeta;\n            (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({\n                error: (_b = action.payload) != null ? _b : action.error,\n                isUnhandledError: !rejectedWithValue,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        }\n    };\n    return handler;\n};\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = function(_j) {\n    var api = _j.api, apiUid = _j.context.apiUid, reducerPath = _j.reducerPath;\n    return function(action, mwApi) {\n        var _a, _b;\n        if (api.util.resetApiState.match(action)) {\n            mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        if (typeof process !== \"undefined\" && true) {\n            if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === \"conflict\") {\n                console.warn('There is a mismatch between slice and middleware for the reducerPath \"' + reducerPath + '\".\\nYou can only have one api per reducer path, this will lead to crashes in various situations!' + (reducerPath === \"api\" ? \"\\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!\" : \"\"));\n            }\n        }\n    };\n};\n// src/query/core/buildMiddleware/batchActions.ts\nvar import_immer4 = __toModule(__webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\"));\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( false ? 0 : typeof global !== \"undefined\" ? global : globalThis) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar buildBatchedActionsHandler = function(_j) {\n    var api = _j.api, queryThunk = _j.queryThunk, internalState = _j.internalState;\n    var subscriptionsPrefix = api.reducerPath + \"/subscriptions\";\n    var previousSubscriptions = null;\n    var dispatchQueued = false;\n    var _k = api.internalActions, updateSubscriptionOptions = _k.updateSubscriptionOptions, unsubscribeQueryResult = _k.unsubscribeQueryResult;\n    var actuallyMutateSubscriptions = function(mutableState, action) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n        if (updateSubscriptionOptions.match(action)) {\n            var _j = action.payload, queryCacheKey = _j.queryCacheKey, requestId = _j.requestId, options = _j.options;\n            if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {\n                mutableState[queryCacheKey][requestId] = options;\n            }\n            return true;\n        }\n        if (unsubscribeQueryResult.match(action)) {\n            var _k = action.payload, queryCacheKey = _k.queryCacheKey, requestId = _k.requestId;\n            if (mutableState[queryCacheKey]) {\n                delete mutableState[queryCacheKey][requestId];\n            }\n            return true;\n        }\n        if (api.internalActions.removeQueryResult.match(action)) {\n            delete mutableState[action.payload.queryCacheKey];\n            return true;\n        }\n        if (queryThunk.pending.match(action)) {\n            var _l = action.meta, arg = _l.arg, requestId = _l.requestId;\n            if (arg.subscribe) {\n                var substate = (_c = mutableState[_b = arg.queryCacheKey]) != null ? _c : mutableState[_b] = {};\n                substate[requestId] = (_e = (_d = arg.subscriptionOptions) != null ? _d : substate[requestId]) != null ? _e : {};\n                return true;\n            }\n        }\n        if (queryThunk.rejected.match(action)) {\n            var _m = action.meta, condition = _m.condition, arg = _m.arg, requestId = _m.requestId;\n            if (condition && arg.subscribe) {\n                var substate = (_g = mutableState[_f = arg.queryCacheKey]) != null ? _g : mutableState[_f] = {};\n                substate[requestId] = (_i = (_h = arg.subscriptionOptions) != null ? _h : substate[requestId]) != null ? _i : {};\n                return true;\n            }\n        }\n        return false;\n    };\n    return function(action, mwApi) {\n        var _a, _b;\n        if (!previousSubscriptions) {\n            previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n        }\n        if (api.util.resetApiState.match(action)) {\n            previousSubscriptions = internalState.currentSubscriptions = {};\n            return [\n                true,\n                false\n            ];\n        }\n        if (api.internalActions.internal_probeSubscription.match(action)) {\n            var _j = action.payload, queryCacheKey = _j.queryCacheKey, requestId = _j.requestId;\n            var hasSubscription = !!((_a = internalState.currentSubscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);\n            return [\n                false,\n                hasSubscription\n            ];\n        }\n        var didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n        if (didMutate) {\n            if (!dispatchQueued) {\n                queueMicrotaskShim(function() {\n                    var newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n                    var _j = (0, import_immer4.produceWithPatches)(previousSubscriptions, function() {\n                        return newSubscriptions;\n                    }), patches = _j[1];\n                    mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n                    previousSubscriptions = newSubscriptions;\n                    dispatchQueued = false;\n                });\n                dispatchQueued = true;\n            }\n            var isSubscriptionSliceAction = !!((_b = action.type) == null ? void 0 : _b.startsWith(subscriptionsPrefix));\n            var isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n            var actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n            return [\n                actionShouldContinue,\n                false\n            ];\n        }\n        return [\n            true,\n            false\n        ];\n    };\n};\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n    var reducerPath = input.reducerPath, queryThunk = input.queryThunk, api = input.api, context = input.context;\n    var apiUid = context.apiUid;\n    var actions = {\n        invalidateTags: (0, import_toolkit13.createAction)(reducerPath + \"/invalidateTags\")\n    };\n    var isThisApiSliceAction = function(action) {\n        return !!action && typeof action.type === \"string\" && action.type.startsWith(reducerPath + \"/\");\n    };\n    var handlerBuilders = [\n        buildDevCheckHandler,\n        buildCacheCollectionHandler,\n        buildInvalidationByTagsHandler,\n        buildPollingHandler,\n        buildCacheLifecycleHandler,\n        buildQueryLifecycleHandler\n    ];\n    var middleware = function(mwApi) {\n        var initialized2 = false;\n        var internalState = {\n            currentSubscriptions: {}\n        };\n        var builderArgs = __spreadProps(__spreadValues({}, input), {\n            internalState: internalState,\n            refetchQuery: refetchQuery\n        });\n        var handlers = handlerBuilders.map(function(build) {\n            return build(builderArgs);\n        });\n        var batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n        var windowEventsHandler = buildWindowEventHandler(builderArgs);\n        return function(next) {\n            return function(action) {\n                if (!initialized2) {\n                    initialized2 = true;\n                    mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n                }\n                var mwApiWithNext = __spreadProps(__spreadValues({}, mwApi), {\n                    next: next\n                });\n                var stateBefore = mwApi.getState();\n                var _j = batchedActionsHandler(action, mwApiWithNext, stateBefore), actionShouldContinue = _j[0], hasSubscription = _j[1];\n                var res;\n                if (actionShouldContinue) {\n                    res = next(action);\n                } else {\n                    res = hasSubscription;\n                }\n                if (!!mwApi.getState()[reducerPath]) {\n                    windowEventsHandler(action, mwApiWithNext, stateBefore);\n                    if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n                        for(var _k = 0, handlers_1 = handlers; _k < handlers_1.length; _k++){\n                            var handler = handlers_1[_k];\n                            handler(action, mwApiWithNext, stateBefore);\n                        }\n                    }\n                }\n                return res;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        actions: actions\n    };\n    function refetchQuery(querySubState, queryCacheKey, override) {\n        if (override === void 0) {\n            override = {};\n        }\n        return queryThunk(__spreadValues({\n            type: \"query\",\n            endpointName: querySubState.endpointName,\n            originalArgs: querySubState.originalArgs,\n            subscribe: false,\n            forceRefetch: true,\n            queryCacheKey: queryCacheKey\n        }, override));\n    }\n}\n// src/query/tsHelpers.ts\nfunction assertCast(v) {}\nfunction safeAssign(target) {\n    var args = [];\n    for(var _j = 1; _j < arguments.length; _j++){\n        args[_j - 1] = arguments[_j];\n    }\n    Object.assign.apply(Object, __spreadArray([\n        target\n    ], args));\n}\n// src/query/core/module.ts\nvar import_immer5 = __toModule(__webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/index.js\"));\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = function() {\n    return {\n        name: coreModuleName,\n        init: function(api, _j, context) {\n            var baseQuery = _j.baseQuery, tagTypes = _j.tagTypes, reducerPath = _j.reducerPath, serializeQueryArgs = _j.serializeQueryArgs, keepUnusedDataFor = _j.keepUnusedDataFor, refetchOnMountOrArgChange = _j.refetchOnMountOrArgChange, refetchOnFocus = _j.refetchOnFocus, refetchOnReconnect = _j.refetchOnReconnect;\n            (0, import_immer5.enablePatches)();\n            assertCast(serializeQueryArgs);\n            var assertTagType = function(tag) {\n                if (typeof process !== \"undefined\" && true) {\n                    if (!tagTypes.includes(tag.type)) {\n                        console.error(\"Tag type '\" + tag.type + \"' was used, but not specified in `tagTypes`!\");\n                    }\n                }\n                return tag;\n            };\n            Object.assign(api, {\n                reducerPath: reducerPath,\n                endpoints: {},\n                internalActions: {\n                    onOnline: onOnline,\n                    onOffline: onOffline,\n                    onFocus: onFocus,\n                    onFocusLost: onFocusLost\n                },\n                util: {}\n            });\n            var _k = buildThunks({\n                baseQuery: baseQuery,\n                reducerPath: reducerPath,\n                context: context,\n                api: api,\n                serializeQueryArgs: serializeQueryArgs,\n                assertTagType: assertTagType\n            }), queryThunk = _k.queryThunk, mutationThunk = _k.mutationThunk, patchQueryData = _k.patchQueryData, updateQueryData = _k.updateQueryData, upsertQueryData = _k.upsertQueryData, prefetch = _k.prefetch, buildMatchThunkActions = _k.buildMatchThunkActions;\n            var _l = buildSlice({\n                context: context,\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                reducerPath: reducerPath,\n                assertTagType: assertTagType,\n                config: {\n                    refetchOnFocus: refetchOnFocus,\n                    refetchOnReconnect: refetchOnReconnect,\n                    refetchOnMountOrArgChange: refetchOnMountOrArgChange,\n                    keepUnusedDataFor: keepUnusedDataFor,\n                    reducerPath: reducerPath\n                }\n            }), reducer = _l.reducer, sliceActions = _l.actions;\n            safeAssign(api.util, {\n                patchQueryData: patchQueryData,\n                updateQueryData: updateQueryData,\n                upsertQueryData: upsertQueryData,\n                prefetch: prefetch,\n                resetApiState: sliceActions.resetApiState\n            });\n            safeAssign(api.internalActions, sliceActions);\n            var _m = buildMiddleware({\n                reducerPath: reducerPath,\n                context: context,\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                api: api,\n                assertTagType: assertTagType\n            }), middleware = _m.middleware, middlewareActions = _m.actions;\n            safeAssign(api.util, middlewareActions);\n            safeAssign(api, {\n                reducer: reducer,\n                middleware: middleware\n            });\n            var _o = buildSelectors({\n                serializeQueryArgs: serializeQueryArgs,\n                reducerPath: reducerPath\n            }), buildQuerySelector = _o.buildQuerySelector, buildMutationSelector = _o.buildMutationSelector, selectInvalidatedBy = _o.selectInvalidatedBy;\n            safeAssign(api.util, {\n                selectInvalidatedBy: selectInvalidatedBy\n            });\n            var _p = buildInitiate({\n                queryThunk: queryThunk,\n                mutationThunk: mutationThunk,\n                api: api,\n                serializeQueryArgs: serializeQueryArgs,\n                context: context\n            }), buildInitiateQuery = _p.buildInitiateQuery, buildInitiateMutation = _p.buildInitiateMutation, getRunningMutationThunk = _p.getRunningMutationThunk, getRunningMutationsThunk = _p.getRunningMutationsThunk, getRunningQueriesThunk = _p.getRunningQueriesThunk, getRunningQueryThunk = _p.getRunningQueryThunk, getRunningOperationPromises = _p.getRunningOperationPromises, removalWarning = _p.removalWarning;\n            safeAssign(api.util, {\n                getRunningOperationPromises: getRunningOperationPromises,\n                getRunningOperationPromise: removalWarning,\n                getRunningMutationThunk: getRunningMutationThunk,\n                getRunningMutationsThunk: getRunningMutationsThunk,\n                getRunningQueryThunk: getRunningQueryThunk,\n                getRunningQueriesThunk: getRunningQueriesThunk\n            });\n            return {\n                name: coreModuleName,\n                injectEndpoint: function(endpointName, definition) {\n                    var _a, _b;\n                    var anyApi = api;\n                    (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};\n                    if (isQueryDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildQuerySelector(endpointName, definition),\n                            initiate: buildInitiateQuery(endpointName, definition)\n                        }, buildMatchThunkActions(queryThunk, endpointName));\n                    } else if (isMutationDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildMutationSelector(),\n                            initiate: buildInitiateMutation(endpointName)\n                        }, buildMatchThunkActions(mutationThunk, endpointName));\n                    }\n                }\n            };\n        }\n    };\n};\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule()); //# sourceMappingURL=rtk-query.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsY0FBYyxJQUFLLElBQUksSUFBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMsT0FBTyxFQUFFQyxJQUFJO0lBQ25FLElBQUlDLElBQUk7UUFBRUMsT0FBTztRQUFHQyxNQUFNO1lBQWEsSUFBSUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU1BLENBQUMsQ0FBQyxFQUFFO1lBQUUsT0FBT0EsQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUFHQyxNQUFNLEVBQUU7UUFBRUMsS0FBSyxFQUFFO0lBQUMsR0FBR0MsR0FBR0MsR0FBR0osR0FBR0s7SUFDL0csT0FBT0EsSUFBSTtRQUFFQyxNQUFNQyxLQUFLO1FBQUksU0FBU0EsS0FBSztRQUFJLFVBQVVBLEtBQUs7SUFBRyxHQUFHLE9BQU9DLFdBQVcsY0FBZUgsQ0FBQUEsQ0FBQyxDQUFDRyxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUFhLE9BQU8sSUFBSTtJQUFFLElBQUlKO0lBQ3ZKLFNBQVNFLEtBQUtHLENBQUM7UUFBSSxPQUFPLFNBQVVDLENBQUM7WUFBSSxPQUFPQyxLQUFLO2dCQUFDRjtnQkFBR0M7YUFBRTtRQUFHO0lBQUc7SUFDakUsU0FBU0MsS0FBS0MsRUFBRTtRQUNaLElBQUlWLEdBQUcsTUFBTSxJQUFJVyxVQUFVO1FBQzNCLE1BQU9qQixFQUFHLElBQUk7WUFDVixJQUFJTSxJQUFJLEdBQUdDLEtBQU1KLENBQUFBLElBQUlhLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSVQsQ0FBQyxDQUFDLFNBQVMsR0FBR1MsRUFBRSxDQUFDLEVBQUUsR0FBR1QsQ0FBQyxDQUFDLFFBQVEsSUFBSyxFQUFDSixJQUFJSSxDQUFDLENBQUMsU0FBUyxLQUFLSixFQUFFZSxJQUFJLENBQUNYLElBQUksS0FBS0EsRUFBRUUsSUFBSSxLQUFLLENB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QUFBQSxLQUFLLENBQUNGLEtBQUt3akIsT0FBT25ZLFNBQVMsQ0FBQyxDQUFDckIsYUFBYSxLQUFLLE9BQU85SixLQUFLRixFQUFFLENBQUNnSyxhQUFhLEdBQUcsQ0FBQztvQkFDaEYsSUFBSXhDLGtCQUFrQndULGFBQWE7d0JBQy9Ca0ksV0FBV00sT0FBT25ZLFNBQVMsQ0FBQ3JCLGFBQWEsRUFBRTs0QkFDdkM3UCxNQUFNNlA7NEJBQ05zQixRQUFRNEwsbUJBQW1CbE4sY0FBY2dSOzRCQUN6Qy9NLFVBQVUvRSxtQkFBbUJjLGNBQWNnUjt3QkFDL0MsR0FBR3pKLHVCQUF1Qi9JLFlBQVl3QjtvQkFDMUMsT0FDSyxJQUFJdkMscUJBQXFCdVQsYUFBYTt3QkFDdkNrSSxXQUFXTSxPQUFPblksU0FBUyxDQUFDckIsYUFBYSxFQUFFOzRCQUN2QzdQLE1BQU02UDs0QkFDTnNCLFFBQVE2TDs0QkFDUmxKLFVBQVU5RSxzQkFBc0JhO3dCQUNwQyxHQUFHdUgsdUJBQXVCOUksZUFBZXVCO29CQUM3QztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtBQUFJO0FBQ0osMEJBQTBCO0FBQzFCLElBQUlqTyxZQUFZLGFBQWEsR0FBR0osZUFBZUUsZUFDL0MscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJpZW5kYm9vay8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcnRrLXF1ZXJ5LmNqcy5kZXZlbG9wbWVudC5qcz9mZjE5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59O1xyXG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xyXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xyXG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xyXG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XHJcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xyXG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcclxudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xyXG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XHJcbnZhciBfX2RlZk5vcm1hbFByb3AgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7IH07XHJcbnZhciBfX3NwcmVhZFZhbHVlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXHJcbiAgICAgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxyXG4gICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gX19nZXRPd25Qcm9wU3ltYm9scyhiKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBfa1tfal07XHJcbiAgICAgICAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxudmFyIF9fc3ByZWFkUHJvcHMgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7IH07XHJcbnZhciBfX21hcmtBc01vZHVsZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pOyB9O1xyXG52YXIgX19vYmpSZXN0ID0gZnVuY3Rpb24gKHNvdXJjZSwgZXhjbHVkZSkge1xyXG4gICAgdmFyIHRhcmdldCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXHJcbiAgICAgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xyXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBfa1tfal07XHJcbiAgICAgICAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxudmFyIF9fZXhwb3J0ID0gZnVuY3Rpb24gKHRhcmdldCwgYWxsKSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcclxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG59O1xyXG52YXIgX19yZUV4cG9ydCA9IGZ1bmN0aW9uICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpIHtcclxuICAgIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcclxuICAgICAgICAgICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHVsZTJba2V5XTsgfSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMik7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBfa1tfal07XHJcbiAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG52YXIgX190b01vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUyKSB7XHJcbiAgICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUyLmRlZmF1bHQ7IH0sIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcclxufTtcclxudmFyIF9fYXN5bmMgPSBmdW5jdGlvbiAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBmdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9O1xyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvaW5kZXgudHNcclxuX19tYXJrQXNNb2R1bGUoZXhwb3J0cyk7XHJcbl9fZXhwb3J0KGV4cG9ydHMsIHtcclxuICAgIFF1ZXJ5U3RhdHVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBRdWVyeVN0YXR1czsgfSxcclxuICAgIGJ1aWxkQ3JlYXRlQXBpOiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZENyZWF0ZUFwaTsgfSxcclxuICAgIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmc7IH0sXHJcbiAgICBjb3JlTW9kdWxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlTW9kdWxlOyB9LFxyXG4gICAgY29yZU1vZHVsZU5hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVNb2R1bGVOYW1lOyB9LFxyXG4gICAgY3JlYXRlQXBpOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVBcGk7IH0sXHJcbiAgICBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzOyB9LFxyXG4gICAgZmFrZUJhc2VRdWVyeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFrZUJhc2VRdWVyeTsgfSxcclxuICAgIGZldGNoQmFzZVF1ZXJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmZXRjaEJhc2VRdWVyeTsgfSxcclxuICAgIHJldHJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXRyeTsgfSxcclxuICAgIHNldHVwTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXR1cExpc3RlbmVyczsgfSxcclxuICAgIHNraXBTZWxlY3RvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2tpcFNlbGVjdG9yOyB9LFxyXG4gICAgc2tpcFRva2VuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwVG9rZW47IH1cclxufSk7XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2FwaVN0YXRlLnRzXHJcbnZhciBRdWVyeVN0YXR1cztcclxuKGZ1bmN0aW9uIChRdWVyeVN0YXR1czIpIHtcclxuICAgIFF1ZXJ5U3RhdHVzMltcInVuaW5pdGlhbGl6ZWRcIl0gPSBcInVuaW5pdGlhbGl6ZWRcIjtcclxuICAgIFF1ZXJ5U3RhdHVzMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcclxuICAgIFF1ZXJ5U3RhdHVzMltcImZ1bGZpbGxlZFwiXSA9IFwiZnVsZmlsbGVkXCI7XHJcbiAgICBRdWVyeVN0YXR1czJbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcclxufSkoUXVlcnlTdGF0dXMgfHwgKFF1ZXJ5U3RhdHVzID0ge30pKTtcclxuZnVuY3Rpb24gZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN0YXR1cykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICBpc1VuaW5pdGlhbGl6ZWQ6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCxcclxuICAgICAgICBpc0xvYWRpbmc6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMucGVuZGluZyxcclxuICAgICAgICBpc1N1Y2Nlc3M6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkLFxyXG4gICAgICAgIGlzRXJyb3I6IHN0YXR1cyA9PT0gUXVlcnlTdGF0dXMucmVqZWN0ZWRcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2lzQWJzb2x1dGVVcmwudHNcclxuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKF58OikvL1wiKS50ZXN0KHVybCk7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2pvaW5VcmxzLnRzXHJcbnZhciB3aXRob3V0VHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7IH07XHJcbnZhciB3aXRob3V0TGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdXJsLnJlcGxhY2UoL15cXC8vLCBcIlwiKTsgfTtcclxuZnVuY3Rpb24gam9pblVybHMoYmFzZSwgdXJsKSB7XHJcbiAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgICByZXR1cm4gYmFzZTtcclxuICAgIH1cclxuICAgIGlmIChpc0Fic29sdXRlVXJsKHVybCkpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlbGltaXRlciA9IGJhc2UuZW5kc1dpdGgoXCIvXCIpIHx8ICF1cmwuc3RhcnRzV2l0aChcIj9cIikgPyBcIi9cIiA6IFwiXCI7XHJcbiAgICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XHJcbiAgICB1cmwgPSB3aXRob3V0TGVhZGluZ1NsYXNoKHVybCk7XHJcbiAgICByZXR1cm4gXCJcIiArIGJhc2UgKyBkZWxpbWl0ZXIgKyB1cmw7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2ZsYXR0ZW4udHNcclxudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGFycik7IH07XHJcbi8vIHNyYy9xdWVyeS91dGlscy9pc09ubGluZS50c1xyXG5mdW5jdGlvbiBpc09ubGluZSgpIHtcclxuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG5hdmlnYXRvci5vbkxpbmUgPT09IHZvaWQgMCA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lO1xyXG59XHJcbi8vIHNyYy9xdWVyeS91dGlscy9pc0RvY3VtZW50VmlzaWJsZS50c1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcudHNcclxudmFyIGltcG9ydF90b29sa2l0ID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBpc1BsYWluT2JqZWN0ID0gaW1wb3J0X3Rvb2xraXQuaXNQbGFpbk9iamVjdDtcclxuZnVuY3Rpb24gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmosIG5ld09iaikge1xyXG4gICAgaWYgKG9sZE9iaiA9PT0gbmV3T2JqIHx8ICEoaXNQbGFpbk9iamVjdChvbGRPYmopICYmIGlzUGxhaW5PYmplY3QobmV3T2JqKSB8fCBBcnJheS5pc0FycmF5KG9sZE9iaikgJiYgQXJyYXkuaXNBcnJheShuZXdPYmopKSkge1xyXG4gICAgICAgIHJldHVybiBuZXdPYmo7XHJcbiAgICB9XHJcbiAgICB2YXIgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld09iaik7XHJcbiAgICB2YXIgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XHJcbiAgICB2YXIgaXNTYW1lT2JqZWN0ID0gbmV3S2V5cy5sZW5ndGggPT09IG9sZEtleXMubGVuZ3RoO1xyXG4gICAgdmFyIG1lcmdlT2JqID0gQXJyYXkuaXNBcnJheShuZXdPYmopID8gW10gOiB7fTtcclxuICAgIGZvciAodmFyIF9qID0gMCwgbmV3S2V5c18xID0gbmV3S2V5czsgX2ogPCBuZXdLZXlzXzEubGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNfMVtfal07XHJcbiAgICAgICAgbWVyZ2VPYmpba2V5XSA9IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqW2tleV0sIG5ld09ialtrZXldKTtcclxuICAgICAgICBpZiAoaXNTYW1lT2JqZWN0KVxyXG4gICAgICAgICAgICBpc1NhbWVPYmplY3QgPSBvbGRPYmpba2V5XSA9PT0gbWVyZ2VPYmpba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1NhbWVPYmplY3QgPyBvbGRPYmogOiBtZXJnZU9iajtcclxufVxyXG4vLyBzcmMvcXVlcnkvZmV0Y2hCYXNlUXVlcnkudHNcclxudmFyIGltcG9ydF90b29sa2l0MiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG52YXIgZGVmYXVsdEZldGNoRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGFyZ3VtZW50cy5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICBhcmdzW19qXSA9IGFyZ3VtZW50c1tfal07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmV0Y2guYXBwbHkodm9pZCAwLCBhcmdzKTtcclxufTtcclxudmFyIGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPD0gMjk5OyB9O1xyXG52YXIgZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlID0gZnVuY3Rpb24gKGhlYWRlcnMpIHsgcmV0dXJuIC9pb25cXC8odm5kXFwuYXBpXFwrKT9qc29uLy50ZXN0KGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpOyB9O1xyXG5mdW5jdGlvbiBzdHJpcFVuZGVmaW5lZChvYmopIHtcclxuICAgIGlmICghKDAsIGltcG9ydF90b29sa2l0Mi5pc1BsYWluT2JqZWN0KShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHZhciBjb3B5ID0gX19zcHJlYWRWYWx1ZXMoe30sIG9iaik7XHJcbiAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMoY29weSk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrID0gX2xbMF0sIHYgPSBfbFsxXTtcclxuICAgICAgICBpZiAodiA9PT0gdm9pZCAwKVxyXG4gICAgICAgICAgICBkZWxldGUgY29weVtrXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3B5O1xyXG59XHJcbmZ1bmN0aW9uIGZldGNoQmFzZVF1ZXJ5KF9hKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgaWYgKF9hID09PSB2b2lkIDApIHsgX2EgPSB7fTsgfVxyXG4gICAgdmFyIF9iID0gX2EsIGJhc2VVcmwgPSBfYi5iYXNlVXJsLCBfaiA9IF9iLnByZXBhcmVIZWFkZXJzLCBwcmVwYXJlSGVhZGVycyA9IF9qID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9qLCBfayA9IF9iLmZldGNoRm4sIGZldGNoRm4gPSBfayA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoRm4gOiBfaywgcGFyYW1zU2VyaWFsaXplciA9IF9iLnBhcmFtc1NlcmlhbGl6ZXIsIF9sID0gX2IuaXNKc29uQ29udGVudFR5cGUsIGlzSnNvbkNvbnRlbnRUeXBlID0gX2wgPT09IHZvaWQgMCA/IGRlZmF1bHRJc0pzb25Db250ZW50VHlwZSA6IF9sLCBfbSA9IF9iLmpzb25Db250ZW50VHlwZSwganNvbkNvbnRlbnRUeXBlID0gX20gPT09IHZvaWQgMCA/IFwiYXBwbGljYXRpb24vanNvblwiIDogX20sIGpzb25SZXBsYWNlciA9IF9iLmpzb25SZXBsYWNlciwgZGVmYXVsdFRpbWVvdXQgPSBfYi50aW1lb3V0LCBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPSBfYi5yZXNwb25zZUhhbmRsZXIsIGdsb2JhbFZhbGlkYXRlU3RhdHVzID0gX2IudmFsaWRhdGVTdGF0dXMsIGJhc2VGZXRjaE9wdGlvbnMgPSBfX29ialJlc3QoX2IsIFtcclxuICAgICAgICBcImJhc2VVcmxcIixcclxuICAgICAgICBcInByZXBhcmVIZWFkZXJzXCIsXHJcbiAgICAgICAgXCJmZXRjaEZuXCIsXHJcbiAgICAgICAgXCJwYXJhbXNTZXJpYWxpemVyXCIsXHJcbiAgICAgICAgXCJpc0pzb25Db250ZW50VHlwZVwiLFxyXG4gICAgICAgIFwianNvbkNvbnRlbnRUeXBlXCIsXHJcbiAgICAgICAgXCJqc29uUmVwbGFjZXJcIixcclxuICAgICAgICBcInRpbWVvdXRcIixcclxuICAgICAgICBcInJlc3BvbnNlSGFuZGxlclwiLFxyXG4gICAgICAgIFwidmFsaWRhdGVTdGF0dXNcIlxyXG4gICAgXSk7XHJcbiAgICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiICYmIGZldGNoRm4gPT09IGRlZmF1bHRGZXRjaEZuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogYGZldGNoYCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2Ugc3VwcGx5IGEgY3VzdG9tIGBmZXRjaEZuYCBwcm9wZXJ0eSB0byB1c2UgYGZldGNoQmFzZVF1ZXJ5YCBvbiBTU1IgZW52aXJvbm1lbnRzLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnLCBhcGkpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2lnbmFsLCBnZXRTdGF0ZSwgZXh0cmEsIGVuZHBvaW50LCBmb3JjZWQsIHR5cGUsIG1ldGEsIF9hMiwgdXJsLCBfaiwgaGVhZGVycywgX2ssIHBhcmFtcywgX2wsIHJlc3BvbnNlSGFuZGxlciwgX20sIHZhbGlkYXRlU3RhdHVzLCBfbywgdGltZW91dCwgcmVzdCwgY29uZmlnLCBfcCwgaXNKc29uaWZpYWJsZSwgZGl2aWRlciwgcXVlcnksIHJlcXVlc3QsIHJlcXVlc3RDbG9uZSwgcmVzcG9uc2UsIHRpbWVkT3V0LCB0aW1lb3V0SWQsIGVfMSwgcmVzcG9uc2VDbG9uZSwgcmVzdWx0RGF0YSwgcmVzcG9uc2VUZXh0LCBoYW5kbGVSZXNwb25zZUVycm9yXzEsIGVfMjtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9xKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX3EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBhcGkuc2lnbmFsLCBnZXRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSwgZXh0cmEgPSBhcGkuZXh0cmEsIGVuZHBvaW50ID0gYXBpLmVuZHBvaW50LCBmb3JjZWQgPSBhcGkuZm9yY2VkLCB0eXBlID0gYXBpLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EyID0gdHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiID8geyB1cmw6IGFyZyB9IDogYXJnLCB1cmwgPSBfYTIudXJsLCBfaiA9IF9hMi5oZWFkZXJzLCBoZWFkZXJzID0gX2ogPT09IHZvaWQgMCA/IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycykgOiBfaiwgX2sgPSBfYTIucGFyYW1zLCBwYXJhbXMgPSBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ssIF9sID0gX2EyLnJlc3BvbnNlSGFuZGxlciwgcmVzcG9uc2VIYW5kbGVyID0gX2wgPT09IHZvaWQgMCA/IGdsb2JhbFJlc3BvbnNlSGFuZGxlciAhPSBudWxsID8gZ2xvYmFsUmVzcG9uc2VIYW5kbGVyIDogXCJqc29uXCIgOiBfbCwgX20gPSBfYTIudmFsaWRhdGVTdGF0dXMsIHZhbGlkYXRlU3RhdHVzID0gX20gPT09IHZvaWQgMCA/IGdsb2JhbFZhbGlkYXRlU3RhdHVzICE9IG51bGwgPyBnbG9iYWxWYWxpZGF0ZVN0YXR1cyA6IGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyA6IF9tLCBfbyA9IF9hMi50aW1lb3V0LCB0aW1lb3V0ID0gX28gPT09IHZvaWQgMCA/IGRlZmF1bHRUaW1lb3V0IDogX28sIHJlc3QgPSBfX29ialJlc3QoX2EyLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidXJsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVhZGVyc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhcmFtc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlSGFuZGxlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbGlkYXRlU3RhdHVzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGltZW91dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUZldGNoT3B0aW9ucyksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWxcclxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmlwVW5kZWZpbmVkKGhlYWRlcnMpKTtcclxuICAgICAgICAgICAgICAgICAgICBfcCA9IGNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWQ6IGZvcmNlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9wLmhlYWRlcnMgPSAoX3Euc2VudCgpKSB8fCBoZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzSnNvbmlmaWFibGUgPSBmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgKCgwLCBpbXBvcnRfdG9vbGtpdDIuaXNQbGFpbk9iamVjdCkoYm9keSkgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCB0eXBlb2YgYm9keS50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIGpzb25Db250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0pzb25pZmlhYmxlKGNvbmZpZy5ib2R5KSAmJiBpc0pzb25Db250ZW50VHlwZShjb25maWcuaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJvZHkgPSBKU09OLnN0cmluZ2lmeShjb25maWcuYm9keSwganNvblJlcGxhY2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gfnVybC5pbmRleE9mKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyYW1zU2VyaWFsaXplciA/IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKSA6IG5ldyBVUkxTZWFyY2hQYXJhbXMoc3RyaXBVbmRlZmluZWQocGFyYW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBkaXZpZGVyICsgcXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGpvaW5VcmxzKGJhc2VVcmwsIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q2xvbmUgPSBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YSA9IHsgcmVxdWVzdDogcmVxdWVzdENsb25lIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQgPSBmYWxzZSwgdGltZW91dElkID0gdGltZW91dCAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBfcS5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX3EudHJ5cy5wdXNoKFsyLCA0LCA1LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2hGbihyZXF1ZXN0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZV8xID0gX3Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogdGltZWRPdXQgPyBcIlRJTUVPVVRfRVJST1JcIiA6IFwiRkVUQ0hfRVJST1JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogU3RyaW5nKGVfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YS5yZXNwb25zZSA9IHJlc3BvbnNlQ2xvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBfcS5sYWJlbCA9IDc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgX3EudHJ5cy5wdXNoKFs3LCA5LCAsIDEwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIHJlc3BvbnNlSGFuZGxlcikudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0RGF0YSA9IHI7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVSZXNwb25zZUVycm9yXzEgPSBlOyB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2xvbmUudGV4dCgpLnRoZW4oZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc3BvbnNlVGV4dCA9IHI7IH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZVJlc3BvbnNlRXJyb3JfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlUmVzcG9uc2VFcnJvcl8xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICBlXzIgPSBfcS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIlBBUlNJTkdfRVJST1JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogU3RyaW5nKGVfMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLCByZXN1bHREYXRhKSA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0RGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdERhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9qKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJjb250ZW50LXR5cGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyID0gaXNKc29uQ29udGVudFR5cGUocmVzcG9uc2UuaGVhZGVycykgPyBcImpzb25cIiA6IFwidGV4dFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJqc29uXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBfai5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZXh0Lmxlbmd0aCA/IEpTT04ucGFyc2UodGV4dCkgOiBudWxsXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZS50ZXh0KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vLyBzcmMvcXVlcnkvSGFuZGxlZEVycm9yLnRzXHJcbnZhciBIYW5kbGVkRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGVkRXJyb3IodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7IG1ldGEgPSB2b2lkIDA7IH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBIYW5kbGVkRXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9xdWVyeS9yZXRyeS50c1xyXG5mdW5jdGlvbiBkZWZhdWx0QmFja29mZihhdHRlbXB0LCBtYXhSZXRyaWVzKSB7XHJcbiAgICBpZiAoYXR0ZW1wdCA9PT0gdm9pZCAwKSB7IGF0dGVtcHQgPSAwOyB9XHJcbiAgICBpZiAobWF4UmV0cmllcyA9PT0gdm9pZCAwKSB7IG1heFJldHJpZXMgPSA1OyB9XHJcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGF0dGVtcHRzLCB0aW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfai5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzID0gTWF0aC5taW4oYXR0ZW1wdCwgbWF4UmV0cmllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC40KSAqICgzMDAgPDwgYXR0ZW1wdHMpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXNvbHZlKHJlcyk7IH0sIHRpbWVvdXQpOyB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZmFpbChlKSB7XHJcbiAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBIYW5kbGVkRXJyb3IoeyBlcnJvcjogZSB9KSwge1xyXG4gICAgICAgIHRocm93SW1tZWRpYXRlbHk6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbnZhciBFTVBUWV9PUFRJT05TID0ge307XHJcbnZhciByZXRyeVdpdGhCYWNrb2ZmID0gZnVuY3Rpb24gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpIHsgcmV0dXJuIGZ1bmN0aW9uIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3NzaWJsZU1heFJldHJpZXMsIG1heFJldHJpZXMsIGRlZmF1bHRSZXRyeUNvbmRpdGlvbiwgb3B0aW9ucywgcmV0cnkyLCByZXN1bHQsIGVfMztcclxuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHBvc3NpYmxlTWF4UmV0cmllcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICA1LFxyXG4gICAgICAgICAgICAgICAgICAgIChkZWZhdWx0T3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzLFxyXG4gICAgICAgICAgICAgICAgICAgIChleHRyYU9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUykubWF4UmV0cmllc1xyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHZvaWQgMDsgfSk7XHJcbiAgICAgICAgICAgICAgICBtYXhSZXRyaWVzID0gcG9zc2libGVNYXhSZXRyaWVzLnNsaWNlKC0xKVswXTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXRyeUNvbmRpdGlvbiA9IGZ1bmN0aW9uIChfLCBfXywgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ZW1wdCA9IF9qLmF0dGVtcHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQgPD0gbWF4UmV0cmllcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja29mZjogZGVmYXVsdEJhY2tvZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb25kaXRpb246IGRlZmF1bHRSZXRyeUNvbmRpdGlvblxyXG4gICAgICAgICAgICAgICAgfSwgZGVmYXVsdE9wdGlvbnMpLCBleHRyYU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0cnkyID0gMDtcclxuICAgICAgICAgICAgICAgIF9qLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcclxuICAgICAgICAgICAgICAgIF9qLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgX2oudHJ5cy5wdXNoKFsyLCA0LCAsIDZdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VRdWVyeShhcmdzLCBhcGksIGV4dHJhT3B0aW9ucyldO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfai5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhhbmRsZWRFcnJvcihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGVfMyA9IF9qLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHJ5MisrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVfMy50aHJvd0ltbWVkaWF0ZWx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMyBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZV8zLnZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVfMyBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvciAmJiAhb3B0aW9ucy5yZXRyeUNvbmRpdGlvbihlXzMudmFsdWUuZXJyb3IsIGFyZ3MsIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiByZXRyeTIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVF1ZXJ5QXBpOiBhcGksXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRpb25zOiBleHRyYU9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGVfMy52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvcHRpb25zLmJhY2tvZmYocmV0cnkyLCBvcHRpb25zLm1heFJldHJpZXMpXTtcclxuICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTsgfTsgfTtcclxudmFyIHJldHJ5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24ocmV0cnlXaXRoQmFja29mZiwgeyBmYWlsOiBmYWlsIH0pO1xyXG4vLyBzcmMvcXVlcnkvY29yZS9zZXR1cExpc3RlbmVycy50c1xyXG52YXIgaW1wb3J0X3Rvb2xraXQzID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBvbkZvY3VzID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDMuY3JlYXRlQWN0aW9uKShcIl9fcnRrcS9mb2N1c2VkXCIpO1xyXG52YXIgb25Gb2N1c0xvc3QgPSAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF90b29sa2l0My5jcmVhdGVBY3Rpb24pKFwiX19ydGtxL3VuZm9jdXNlZFwiKTtcclxudmFyIG9uT25saW5lID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDMuY3JlYXRlQWN0aW9uKShcIl9fcnRrcS9vbmxpbmVcIik7XHJcbnZhciBvbk9mZmxpbmUgPSAvKiBAX19QVVJFX18gKi8gKDAsIGltcG9ydF90b29sa2l0My5jcmVhdGVBY3Rpb24pKFwiX19ydGtxL29mZmxpbmVcIik7XHJcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyhkaXNwYXRjaCwgY3VzdG9tSGFuZGxlcikge1xyXG4gICAgZnVuY3Rpb24gZGVmYXVsdEhhbmRsZXIoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25Gb2N1cygpKTsgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRm9jdXNMb3N0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25Gb2N1c0xvc3QoKSk7IH07XHJcbiAgICAgICAgdmFyIGhhbmRsZU9ubGluZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BhdGNoKG9uT25saW5lKCkpOyB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVPZmZsaW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2gob25PZmZsaW5lKCkpOyB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVPZmZsaW5lKTtcclxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXN0b21IYW5kbGVyID8gY3VzdG9tSGFuZGxlcihkaXNwYXRjaCwgeyBvbkZvY3VzOiBvbkZvY3VzLCBvbkZvY3VzTG9zdDogb25Gb2N1c0xvc3QsIG9uT2ZmbGluZTogb25PZmZsaW5lLCBvbk9ubGluZTogb25PbmxpbmUgfSkgOiBkZWZhdWx0SGFuZGxlcigpO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2VsZWN0b3JzLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDcgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcclxudmFyIERlZmluaXRpb25UeXBlO1xyXG4oZnVuY3Rpb24gKERlZmluaXRpb25UeXBlMikge1xyXG4gICAgRGVmaW5pdGlvblR5cGUyW1wicXVlcnlcIl0gPSBcInF1ZXJ5XCI7XHJcbiAgICBEZWZpbml0aW9uVHlwZTJbXCJtdXRhdGlvblwiXSA9IFwibXV0YXRpb25cIjtcclxufSkoRGVmaW5pdGlvblR5cGUgfHwgKERlZmluaXRpb25UeXBlID0ge30pKTtcclxuZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZSkge1xyXG4gICAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUucXVlcnk7XHJcbn1cclxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xyXG4gICAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUubXV0YXRpb247XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeShkZXNjcmlwdGlvbiwgcmVzdWx0LCBlcnJvciwgcXVlcnlBcmcsIG1ldGEsIGFzc2VydFRhZ1R5cGVzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihkZXNjcmlwdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24ocmVzdWx0LCBlcnJvciwgcXVlcnlBcmcsIG1ldGEpLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHQgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogZGVzY3JpcHRpb24gfSA6IGRlc2NyaXB0aW9uO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2xpY2UudHNcclxudmFyIGltcG9ydF90b29sa2l0NiA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNOb3ROdWxsaXNoLnRzXHJcbmZ1bmN0aW9uIGlzTm90TnVsbGlzaCh2KSB7XHJcbiAgICByZXR1cm4gdiAhPSBudWxsO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkSW5pdGlhdGUudHNcclxudmFyIGZvcmNlUXVlcnlGblN5bWJvbCA9IFN5bWJvbChcImZvcmNlUXVlcnlGblwiKTtcclxudmFyIGlzVXBzZXJ0UXVlcnkgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjsgfTtcclxuZnVuY3Rpb24gYnVpbGRJbml0aWF0ZShfaikge1xyXG4gICAgdmFyIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfai5tdXRhdGlvblRodW5rLCBhcGkgPSBfai5hcGksIGNvbnRleHQgPSBfai5jb250ZXh0O1xyXG4gICAgdmFyIHJ1bm5pbmdRdWVyaWVzID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHJ1bm5pbmdNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgX2sgPSBhcGkuaW50ZXJuYWxBY3Rpb25zLCB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0ID0gX2sudW5zdWJzY3JpYmVRdWVyeVJlc3VsdCwgcmVtb3ZlTXV0YXRpb25SZXN1bHQgPSBfay5yZW1vdmVNdXRhdGlvblJlc3VsdCwgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IF9rLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnM7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJ1aWxkSW5pdGlhdGVRdWVyeTogYnVpbGRJbml0aWF0ZVF1ZXJ5LFxyXG4gICAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbjogYnVpbGRJbml0aWF0ZU11dGF0aW9uLFxyXG4gICAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rOiBnZXRSdW5uaW5nUXVlcnlUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuazogZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXHJcbiAgICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuazogZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bms6IGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuayxcclxuICAgICAgICBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXM6IGdldFJ1bm5pbmdPcGVyYXRpb25Qcm9taXNlcyxcclxuICAgICAgICByZW1vdmFsV2FybmluZzogcmVtb3ZhbFdhcm5pbmdcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiByZW1vdmFsV2FybmluZygpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYWQgdG8gYmUgcmVtb3ZlZCBkdWUgdG8gYSBjb25jZXB0dWFsIGJ1ZyBpbiBSVEsuXFxuICAgICAgIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgtdG9vbGtpdC9wdWxsLzI0ODEgZm9yIGRldGFpbHMuXFxuICAgICAgIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3J0ay1xdWVyeS91c2FnZS9zZXJ2ZXItc2lkZS1yZW5kZXJpbmcgZm9yIG5ldyBndWlkYW5jZSBvbiBTU1IuXCIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0UnVubmluZ09wZXJhdGlvblByb21pc2VzKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJlbW92YWxXYXJuaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmFjdCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBBcnJheS5mcm9tKHYudmFsdWVzKCkpLmZsYXRNYXAoZnVuY3Rpb24gKHF1ZXJpZXNGb3JTdG9yZSkgeyByZXR1cm4gcXVlcmllc0ZvclN0b3JlID8gT2JqZWN0LnZhbHVlcyhxdWVyaWVzRm9yU3RvcmUpIDogW107IH0pOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBleHRyYWN0KHJ1bm5pbmdRdWVyaWVzKSksIGV4dHJhY3QocnVubmluZ011dGF0aW9ucykpLmZpbHRlcihpc05vdE51bGxpc2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyeVRodW5rKGVuZHBvaW50TmFtZSwgcXVlcnlBcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHZhciBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xyXG4gICAgICAgICAgICAgICAgcXVlcnlBcmdzOiBxdWVyeUFyZ3MsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludERlZmluaXRpb246IGVuZHBvaW50RGVmaW5pdGlvbixcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayhfZW5kcG9pbnROYW1lLCBmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2ZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZF07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkgeyByZXR1cm4gT2JqZWN0LnZhbHVlcyhydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9KS5maWx0ZXIoaXNOb3ROdWxsaXNoKTsgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuaygpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7IHJldHVybiBPYmplY3QudmFsdWVzKHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7IH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCkge1xyXG4gICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlV2FybmluZy50cmlnZ2VyZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9wcm9iZVN1YnNjcmlwdGlvbih7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBcIkRPRVNfTk9UX0VYSVNUXCIsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IFwiRFVNTVlfUkVRVUVTVF9JRFwiXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbWlkZGxld2FyZVdhcm5pbmcudHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWdpc3RlcmVkICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcXFwiXCIgKyBhcGkucmVkdWNlclBhdGggKyBcIlxcXCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cXG5Zb3UgbXVzdCBhZGQgdGhlIG1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSB0byBmdW5jdGlvbiBjb3JyZWN0bHkhXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5QWN0aW9uID0gZnVuY3Rpb24gKGFyZywgX2opIHtcclxuICAgICAgICAgICAgdmFyIF9rID0gX2ogPT09IHZvaWQgMCA/IHt9IDogX2osIF9sID0gX2suc3Vic2NyaWJlLCBzdWJzY3JpYmUgPSBfbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9sLCBmb3JjZVJlZmV0Y2ggPSBfay5mb3JjZVJlZmV0Y2gsIHN1YnNjcmlwdGlvbk9wdGlvbnMgPSBfay5zdWJzY3JpcHRpb25PcHRpb25zLCBfbSA9IGZvcmNlUXVlcnlGblN5bWJvbCwgZm9yY2VRdWVyeUZuID0gX2tbX21dO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9qO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbjogZW5kcG9pbnREZWZpbml0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciB0aHVuayA9IHF1ZXJ5VGh1bmsoKF9qID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInF1ZXJ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IGZvcmNlUmVmZXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnROYW1lOiBlbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBfaltmb3JjZVF1ZXJ5Rm5TeW1ib2xdID0gZm9yY2VRdWVyeUZuLFxyXG4gICAgICAgICAgICAgICAgICAgIF9qKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVBZnRlciA9IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IHRodW5rUmVzdWx0LnJlcXVlc3RJZCwgYWJvcnQgPSB0aHVua1Jlc3VsdC5hYm9ydDtcclxuICAgICAgICAgICAgICAgIHZhciBza2lwcGVkU3luY2hyb25vdXNseSA9IHN0YXRlQWZ0ZXIucmVxdWVzdElkICE9PSByZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVubmluZ1F1ZXJ5ID0gKF9hID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEZyb21TdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdG9yKGdldFN0YXRlKCkpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlUHJvbWlzZSA9IE9iamVjdC5hc3NpZ24oZm9yY2VRdWVyeUZuID8gdGh1bmtSZXN1bHQudGhlbihzZWxlY3RGcm9tU3RhdGUpIDogc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIXJ1bm5pbmdRdWVyeSA/IFByb21pc2UucmVzb2x2ZShzdGF0ZUFmdGVyKSA6IFByb21pc2UuYWxsKFtydW5uaW5nUXVlcnksIHRodW5rUmVzdWx0XSkudGhlbihzZWxlY3RGcm9tU3RhdGUpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9qLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhdGVQcm9taXNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2ouc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5kYXRhXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWZldGNoOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwYXRjaChxdWVyeUFjdGlvbihhcmcsIHsgc3Vic2NyaWJlOiBmYWxzZSwgZm9yY2VSZWZldGNoOiB0cnVlIH0pKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godW5zdWJzY3JpYmVRdWVyeVJlc3VsdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQcm9taXNlLnN1YnNjcmlwdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmdRdWVyeSAmJiAhc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIWZvcmNlUXVlcnlGbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydW5uaW5nXzEgPSBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfMVtxdWVyeUNhY2hlS2V5XSA9IHN0YXRlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nUXVlcmllcy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmdfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVubmluZ18xW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJ1bm5pbmdfMSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nUXVlcmllcy5kZWxldGUoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVQcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnLCBfaikge1xyXG4gICAgICAgICAgICB2YXIgX2sgPSBfaiA9PT0gdm9pZCAwID8ge30gOiBfaiwgX2wgPSBfay50cmFjaywgdHJhY2sgPSBfbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9sLCBmaXhlZENhY2hlS2V5ID0gX2suZml4ZWRDYWNoZUtleTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aHVuayA9IG11dGF0aW9uVGh1bmsoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibXV0YXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGVuZHBvaW50TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcclxuICAgICAgICAgICAgICAgICAgICB0cmFjazogdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRDYWNoZUtleTogZml4ZWRDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XHJcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gdGh1bmtSZXN1bHQucmVxdWVzdElkLCBhYm9ydCA9IHRodW5rUmVzdWx0LmFib3J0LCB1bndyYXAgPSB0aHVua1Jlc3VsdC51bndyYXA7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWVQcm9taXNlID0gdGh1bmtSZXN1bHQudW53cmFwKCkudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHsgZGF0YTogZGF0YSB9KTsgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoeyBlcnJvcjogZXJyb3IgfSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHJlbW92ZU11dGF0aW9uUmVzdWx0KHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGZpeGVkQ2FjaGVLZXk6IGZpeGVkQ2FjaGVLZXkgfSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBPYmplY3QuYXNzaWduKHJldHVyblZhbHVlUHJvbWlzZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogdGh1bmtSZXN1bHQuYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICB1bndyYXA6IHVud3JhcCxcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogcmVzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IHJlc2V0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBydW5uaW5nID0gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xyXG4gICAgICAgICAgICAgICAgcnVubmluZ1tyZXF1ZXN0SWRdID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgcmV0LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW3JlcXVlc3RJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhydW5uaW5nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5kZWxldGUoZGlzcGF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdbZml4ZWRDYWNoZUtleV0gPT09IHJldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbZml4ZWRDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJ1bm5pbmcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuZGVsZXRlKGRpc3BhdGNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkVGh1bmtzLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDQgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIGltcG9ydF9pbW1lciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIGltcG9ydF90b29sa2l0NSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2UoYmFzZVF1ZXJ5UmV0dXJuVmFsdWUpIHtcclxuICAgIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFRodW5rcyhfaikge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBiYXNlUXVlcnkgPSBfai5iYXNlUXVlcnksIGVuZHBvaW50RGVmaW5pdGlvbnMgPSBfai5jb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMsIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgYXBpID0gX2ouYXBpLCBhc3NlcnRUYWdUeXBlID0gX2ouYXNzZXJ0VGFnVHlwZTtcclxuICAgIHZhciBwYXRjaFF1ZXJ5RGF0YSA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZ3MsIHBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSB7IHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcclxuICAgICAgICB2YXIgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XHJcbiAgICAgICAgICAgIHF1ZXJ5QXJnczogYXJncyxcclxuICAgICAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uOiBlbmRwb2ludERlZmluaXRpb24sXHJcbiAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5xdWVyeVJlc3VsdFBhdGNoZWQoeyBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LCBwYXRjaGVzOiBwYXRjaGVzIH0pKTtcclxuICAgICAgICBpZiAoIXVwZGF0ZVByb3ZpZGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmdzKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICB2YXIgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB2b2lkIDAsIGFyZ3MsIHt9LCBhc3NlcnRUYWdUeXBlKTtcclxuICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoeyBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LCBwcm92aWRlZFRhZ3M6IHByb3ZpZGVkVGFncyB9KSk7XHJcbiAgICB9OyB9O1xyXG4gICAgdmFyIHVwZGF0ZVF1ZXJ5RGF0YSA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZ3MsIHVwZGF0ZVJlY2lwZSwgdXBkYXRlUHJvdmlkZWQpIHtcclxuICAgICAgICBpZiAodXBkYXRlUHJvdmlkZWQgPT09IHZvaWQgMCkgeyB1cGRhdGVQcm92aWRlZCA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2osIF9rO1xyXG4gICAgICAgICAgICB2YXIgZW5kcG9pbnREZWZpbml0aW9uID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gZW5kcG9pbnREZWZpbml0aW9uLnNlbGVjdChhcmdzKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICAgICAgdmFyIHJldCA9IHtcclxuICAgICAgICAgICAgICAgIHBhdGNoZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaW52ZXJzZVBhdGNoZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdW5kbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGF0Y2goYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBhcmdzLCByZXQuaW52ZXJzZVBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSk7IH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGltcG9ydF9pbW1lci5pc0RyYWZ0YWJsZSkoY3VycmVudFN0YXRlLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gKDAsIGltcG9ydF9pbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMpKGN1cnJlbnRTdGF0ZS5kYXRhLCB1cGRhdGVSZWNpcGUpLCB2YWx1ZSA9IF9sWzBdLCBwYXRjaGVzID0gX2xbMV0sIGludmVyc2VQYXRjaGVzID0gX2xbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgKF9qID0gcmV0LnBhdGNoZXMpLnB1c2guYXBwbHkoX2osIHBhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIChfayA9IHJldC5pbnZlcnNlUGF0Y2hlcykucHVzaC5hcHBseShfaywgaW52ZXJzZVBhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHVwZGF0ZVJlY2lwZShjdXJyZW50U3RhdGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LnBhdGNoZXMucHVzaCh7IG9wOiBcInJlcGxhY2VcIiwgcGF0aDogW10sIHZhbHVlOiBuZXdWYWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50U3RhdGUuZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BhdGNoKGFwaS51dGlsLnBhdGNoUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgYXJncywgcmV0LnBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgdXBzZXJ0UXVlcnlEYXRhID0gZnVuY3Rpb24gKGVuZHBvaW50TmFtZSwgYXJncywgdmFsdWUpIHsgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xyXG4gICAgICAgIHZhciBfajtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2goYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZ3MsIChfaiA9IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2pbZm9yY2VRdWVyeUZuU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTsgfSxcclxuICAgICAgICAgICAgX2opKSk7XHJcbiAgICB9OyB9O1xyXG4gICAgdmFyIGV4ZWN1dGVFbmRwb2ludCA9IGZ1bmN0aW9uIChfMCwgXzEpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIFtfMCwgXzFdLCBmdW5jdGlvbiAoYXJnLCBfaikge1xyXG4gICAgICAgIHZhciBlbmRwb2ludERlZmluaXRpb24sIHRyYW5zZm9ybVJlc3BvbnNlLCByZXN1bHQsIGJhc2VRdWVyeUFwaV8xLCBmb3JjZVF1ZXJ5Rm4sIHdoYXQsIGVyciwgX2ssIF9sLCBrZXksIF9tLCBlcnJvcl8xLCBjYXRjaGVkRXJyb3IsIHRyYW5zZm9ybUVycm9yUmVzcG9uc2UsIF9vLCBlXzQ7XHJcbiAgICAgICAgdmFyIF9wLCBfcTtcclxuICAgICAgICB2YXIgc2lnbmFsID0gX2ouc2lnbmFsLCBhYm9ydCA9IF9qLmFib3J0LCByZWplY3RXaXRoVmFsdWUgPSBfai5yZWplY3RXaXRoVmFsdWUsIGZ1bGZpbGxXaXRoVmFsdWUgPSBfai5mdWxmaWxsV2l0aFZhbHVlLCBkaXNwYXRjaCA9IF9qLmRpc3BhdGNoLCBnZXRTdGF0ZSA9IF9qLmdldFN0YXRlLCBleHRyYSA9IF9qLmV4dHJhO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX3IpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfci5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbYXJnLmVuZHBvaW50TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgX3IubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9yLnRyeXMucHVzaChbMSwgOCwgLCAxM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlID0gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlUXVlcnlBcGlfMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGFyZy5lbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFyZy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWQ6IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgOiB2b2lkIDBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUXVlcnlGbiA9IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBhcmdbZm9yY2VRdWVyeUZuU3ltYm9sXSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUXVlcnlGbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRwb2ludERlZmluaXRpb24ucXVlcnkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VRdWVyeShlbmRwb2ludERlZmluaXRpb24ucXVlcnkoYXJnLm9yaWdpbmFsQXJncyksIGJhc2VRdWVyeUFwaV8xLCBlbmRwb2ludERlZmluaXRpb24uZXh0cmFPcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UgPSBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBlbmRwb2ludERlZmluaXRpb24ucXVlcnlGbihhcmcub3JpZ2luYWxBcmdzLCBiYXNlUXVlcnlBcGlfMSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucywgZnVuY3Rpb24gKGFyZzIpIHsgcmV0dXJuIGJhc2VRdWVyeShhcmcyLCBiYXNlUXVlcnlBcGlfMSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucyk7IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfci5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3IubGFiZWwgPSA2O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoYXQgPSBlbmRwb2ludERlZmluaXRpb24ucXVlcnkgPyBcImBiYXNlUXVlcnlgXCIgOiBcImBxdWVyeUZuYFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSB3aGF0ICsgXCIgZGlkIG5vdCByZXR1cm4gYW55dGhpbmcuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gd2hhdCArIFwiIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IHdoYXQgKyBcIiByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBib3RoIGBlcnJvcmAgYW5kIGByZXN1bHRgLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5lcnJvciA9PT0gdm9pZCAwICYmIHJlc3VsdC5kYXRhID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IHdoYXQgKyBcIiByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBuZWl0aGVyIGEgdmFsaWQgYGVycm9yYCBhbmQgYHJlc3VsdGAuIEF0IGxlYXN0IG9uZSBvZiB0aGVtIHNob3VsZCBub3QgYmUgYHVuZGVmaW5lZGBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbCA9IE9iamVjdC5rZXlzKHJlc3VsdCk7IF9rIDwgX2wubGVuZ3RoOyBfaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gX2xbX2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZXJyb3JcIiAmJiBrZXkgIT09IFwiZGF0YVwiICYmIGtleSAhPT0gXCJtZXRhXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJUaGUgb2JqZWN0IHJldHVybmVkIGJ5IFwiICsgd2hhdCArIFwiIGhhcyB0aGUgdW5rbm93biBwcm9wZXJ0eSBcIiArIGtleSArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGVuY291bnRlcmVkIGhhbmRsaW5nIHRoZSBlbmRwb2ludCBcIiArIGFyZy5lbmRwb2ludE5hbWUgKyBcIi5cXG4gICAgICAgICAgICAgIFwiICsgZXJyICsgXCJcXG4gICAgICAgICAgICAgIEl0IG5lZWRzIHRvIHJldHVybiBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHNoYXBlIGB7IGRhdGE6IDx2YWx1ZT4gfWAgb3IgYHsgZXJyb3I6IDx2YWx1ZT4gfWAgdGhhdCBtYXkgY29udGFpbiBhbiBvcHRpb25hbCBgbWV0YWAgcHJvcGVydHkuXFxuICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOlwiLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX20gPSBmdWxmaWxsV2l0aFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3VsdC5kYXRhLCByZXN1bHQubWV0YSwgYXJnLm9yaWdpbmFsQXJncyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX20uYXBwbHkodm9pZCAwLCBbX3Iuc2VudCgpLCAoX3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VRdWVyeU1ldGE6IHJlc3VsdC5tZXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BbaW1wb3J0X3Rvb2xraXQ1LlNIT1VMRF9BVVRPQkFUQ0hdID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wKV0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZWRFcnJvciA9IGVycm9yXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2F0Y2hlZEVycm9yIGluc3RhbmNlb2YgSGFuZGxlZEVycm9yKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSAmJiBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtRXJyb3JSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlID0gZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9yLmxhYmVsID0gOTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgICAgICBfci50cnlzLnB1c2goWzksIDExLCAsIDEyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX28gPSByZWplY3RXaXRoVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNmb3JtRXJyb3JSZXNwb25zZShjYXRjaGVkRXJyb3IudmFsdWUsIGNhdGNoZWRFcnJvci5tZXRhLCBhcmcub3JpZ2luYWxBcmdzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX28uYXBwbHkodm9pZCAwLCBbX3Iuc2VudCgpLCAoX3EgPSB7IGJhc2VRdWVyeU1ldGE6IGNhdGNoZWRFcnJvci5tZXRhIH0sIF9xW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9xKV0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgICAgICAgICAgZV80ID0gX3Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoZWRFcnJvciA9IGVfNDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbiB1bmhhbmRsZWQgZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBhIHJlcXVlc3QgZm9yIHRoZSBlbmRwb2ludCBcXFwiXCIgKyBhcmcuZW5kcG9pbnROYW1lICsgXCJcXFwiLlxcbkluIHRoZSBjYXNlIG9mIGFuIHVuaGFuZGxlZCBlcnJvciwgbm8gdGFncyB3aWxsIGJlIFxcXCJwcm92aWRlZFxcXCIgb3IgXFxcImludmFsaWRhdGVkXFxcIi5cIiwgY2F0Y2hlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY2F0Y2hlZEVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY2F0Y2hlZEVycm9yO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTsgfTtcclxuICAgIGZ1bmN0aW9uIGlzRm9yY2VkUXVlcnkoYXJnLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB2YXIgcmVxdWVzdFN0YXRlID0gKF9iID0gKF9hID0gc3RhdGVbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcmllcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2FyZy5xdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlID0gKF9jID0gc3RhdGVbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY29uZmlnLnJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICB2YXIgcmVmZXRjaFZhbCA9IChfZCA9IGFyZy5mb3JjZVJlZmV0Y2gpICE9IG51bGwgPyBfZCA6IGFyZy5zdWJzY3JpYmUgJiYgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlO1xyXG4gICAgICAgIGlmIChyZWZldGNoVmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWZldGNoVmFsID09PSB0cnVlIHx8IChOdW1iZXIobmV3IERhdGUoKSkgLSBOdW1iZXIoZnVsZmlsbGVkVmFsKSkgLyAxZTMgPj0gcmVmZXRjaFZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIHF1ZXJ5VGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQ1LmNyZWF0ZUFzeW5jVGh1bmspKHJlZHVjZXJQYXRoICsgXCIvZXhlY3V0ZVF1ZXJ5XCIsIGV4ZWN1dGVFbmRwb2ludCwge1xyXG4gICAgICAgIGdldFBlbmRpbmdNZXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfajtcclxuICAgICAgICAgICAgcmV0dXJuIF9qID0geyBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpIH0sIF9qW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9qO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocXVlcnlUaHVua0FyZ3MsIF9qKSB7XHJcbiAgICAgICAgICAgIHZhciBnZXRTdGF0ZSA9IF9qLmdldFN0YXRlO1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RTdGF0ZSA9IChfYiA9IChfYSA9IHN0YXRlW3JlZHVjZXJQYXRoXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYltxdWVyeVRodW5rQXJncy5xdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBxdWVyeVRodW5rQXJncy5vcmlnaW5hbEFyZ3M7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0FyZyA9IHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLm9yaWdpbmFsQXJncztcclxuICAgICAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbcXVlcnlUaHVua0FyZ3MuZW5kcG9pbnROYW1lXTtcclxuICAgICAgICAgICAgaWYgKGlzVXBzZXJ0UXVlcnkocXVlcnlUaHVua0FyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHJlcXVlc3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdFN0YXRlLnN0YXR1cykgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRm9yY2VkUXVlcnkocXVlcnlUaHVua0FyZ3MsIHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgJiYgKChfYyA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLmZvcmNlUmVmZXRjaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoZW5kcG9pbnREZWZpbml0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXJnOiBjdXJyZW50QXJnLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNBcmc6IHByZXZpb3VzQXJnLFxyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnRTdGF0ZTogcmVxdWVzdFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlXHJcbiAgICAgICAgICAgIH0pKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZ1bGZpbGxlZFZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb246IHRydWVcclxuICAgIH0pO1xyXG4gICAgdmFyIG11dGF0aW9uVGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQ1LmNyZWF0ZUFzeW5jVGh1bmspKHJlZHVjZXJQYXRoICsgXCIvZXhlY3V0ZU11dGF0aW9uXCIsIGV4ZWN1dGVFbmRwb2ludCwge1xyXG4gICAgICAgIGdldFBlbmRpbmdNZXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfajtcclxuICAgICAgICAgICAgcmV0dXJuIF9qID0geyBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpIH0sIF9qW2ltcG9ydF90b29sa2l0NS5TSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9qO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGhhc1RoZUZvcmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIFwiZm9yY2VcIiBpbiBvcHRpb25zOyB9O1xyXG4gICAgdmFyIGhhc01heEFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBcImlmT2xkZXJUaGFuXCIgaW4gb3B0aW9uczsgfTtcclxuICAgIHZhciBwcmVmZXRjaCA9IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucykgeyByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBnZXRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBmb3JjZSA9IGhhc1RoZUZvcmNlKG9wdGlvbnMpICYmIG9wdGlvbnMuZm9yY2U7XHJcbiAgICAgICAgdmFyIG1heEFnZSA9IGhhc01heEFnZShvcHRpb25zKSAmJiBvcHRpb25zLmlmT2xkZXJUaGFuO1xyXG4gICAgICAgIHZhciBxdWVyeUFjdGlvbiA9IGZ1bmN0aW9uIChmb3JjZTIpIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlMiA9PT0gdm9pZCAwKSB7IGZvcmNlMiA9IHRydWU7IH1cclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIHsgZm9yY2VSZWZldGNoOiBmb3JjZTIgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbGF0ZXN0U3RhdGVWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShnZXRTdGF0ZSgpKTtcclxuICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1heEFnZSkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEZ1bGZpbGxlZFRzID0gbGF0ZXN0U3RhdGVWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0U3RhdGVWYWx1ZS5mdWxmaWxsZWRUaW1lU3RhbXA7XHJcbiAgICAgICAgICAgIGlmICghbGFzdEZ1bGZpbGxlZFRzKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2hvdWxkUmV0cmlnZ2VyID0gKE51bWJlcihuZXcgRGF0ZSgpKSAtIE51bWJlcihuZXcgRGF0ZShsYXN0RnVsZmlsbGVkVHMpKSkgLyAxZTMgPj0gbWF4QWdlO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICB9OyB9O1xyXG4gICAgZnVuY3Rpb24gbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gYWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBhY3Rpb24ubWV0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFyZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmVuZHBvaW50TmFtZSkgPT09IGVuZHBvaW50TmFtZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRNYXRjaFRodW5rQWN0aW9ucyh0aHVuaywgZW5kcG9pbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWF0Y2hQZW5kaW5nOiAoMCwgaW1wb3J0X3Rvb2xraXQ0LmlzQWxsT2YpKCgwLCBpbXBvcnRfdG9vbGtpdDQuaXNQZW5kaW5nKSh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcclxuICAgICAgICAgICAgbWF0Y2hGdWxmaWxsZWQ6ICgwLCBpbXBvcnRfdG9vbGtpdDQuaXNBbGxPZikoKDAsIGltcG9ydF90b29sa2l0NC5pc0Z1bGZpbGxlZCkodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXHJcbiAgICAgICAgICAgIG1hdGNoUmVqZWN0ZWQ6ICgwLCBpbXBvcnRfdG9vbGtpdDQuaXNBbGxPZikoKDAsIGltcG9ydF90b29sa2l0NC5pc1JlamVjdGVkKSh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5VGh1bms6IHF1ZXJ5VGh1bmssXHJcbiAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICBwcmVmZXRjaDogcHJlZmV0Y2gsXHJcbiAgICAgICAgdXBkYXRlUXVlcnlEYXRhOiB1cGRhdGVRdWVyeURhdGEsXHJcbiAgICAgICAgdXBzZXJ0UXVlcnlEYXRhOiB1cHNlcnRRdWVyeURhdGEsXHJcbiAgICAgICAgcGF0Y2hRdWVyeURhdGE6IHBhdGNoUXVlcnlEYXRhLFxyXG4gICAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnM6IGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgdHlwZSwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSkge1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZVByb3ZpZGVkQnkoZW5kcG9pbnREZWZpbml0aW9uc1thY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lXVt0eXBlXSwgKDAsIGltcG9ydF90b29sa2l0NC5pc0Z1bGZpbGxlZCkoYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogdm9pZCAwLCAoMCwgaW1wb3J0X3Rvb2xraXQ0LmlzUmVqZWN0ZWRXaXRoVmFsdWUpKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHZvaWQgMCwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgXCJiYXNlUXVlcnlNZXRhXCIgaW4gYWN0aW9uLm1ldGEgPyBhY3Rpb24ubWV0YS5iYXNlUXVlcnlNZXRhIDogdm9pZCAwLCBhc3NlcnRUYWdUeXBlKTtcclxufVxyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFNsaWNlLnRzXHJcbnZhciBpbXBvcnRfaW1tZXIyID0gX190b01vZHVsZShyZXF1aXJlKFwiaW1tZXJcIikpO1xyXG52YXIgaW1wb3J0X2ltbWVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxuZnVuY3Rpb24gdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKHN0YXRlLCBxdWVyeUNhY2hlS2V5LCB1cGRhdGUpIHtcclxuICAgIHZhciBzdWJzdGF0ZSA9IHN0YXRlW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgaWYgKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgdXBkYXRlKHN1YnN0YXRlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gXCJhcmdcIiBpbiBpZCA/IGlkLmFyZy5maXhlZENhY2hlS2V5IDogaWQuZml4ZWRDYWNoZUtleSkgIT0gbnVsbCA/IF9hIDogaWQucmVxdWVzdElkO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhzdGF0ZSwgaWQsIHVwZGF0ZSkge1xyXG4gICAgdmFyIHN1YnN0YXRlID0gc3RhdGVbZ2V0TXV0YXRpb25DYWNoZUtleShpZCldO1xyXG4gICAgaWYgKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgdXBkYXRlKHN1YnN0YXRlKTtcclxuICAgIH1cclxufVxyXG52YXIgaW5pdGlhbFN0YXRlID0ge307XHJcbmZ1bmN0aW9uIGJ1aWxkU2xpY2UoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBxdWVyeVRodW5rID0gX2oucXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayA9IF9qLm11dGF0aW9uVGh1bmssIF9rID0gX2ouY29udGV4dCwgZGVmaW5pdGlvbnMgPSBfay5lbmRwb2ludERlZmluaXRpb25zLCBhcGlVaWQgPSBfay5hcGlVaWQsIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSBfay5leHRyYWN0UmVoeWRyYXRpb25JbmZvLCBoYXNSZWh5ZHJhdGlvbkluZm8gPSBfay5oYXNSZWh5ZHJhdGlvbkluZm8sIGFzc2VydFRhZ1R5cGUgPSBfai5hc3NlcnRUYWdUeXBlLCBjb25maWcgPSBfai5jb25maWc7XHJcbiAgICB2YXIgcmVzZXRBcGlTdGF0ZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlQWN0aW9uKShyZWR1Y2VyUGF0aCArIFwiL3Jlc2V0QXBpU3RhdGVcIik7XHJcbiAgICB2YXIgcXVlcnlTbGljZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlU2xpY2UpKHtcclxuICAgICAgICBuYW1lOiByZWR1Y2VyUGF0aCArIFwiL3F1ZXJpZXNcIixcclxuICAgICAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSxcclxuICAgICAgICByZWR1Y2Vyczoge1xyXG4gICAgICAgICAgICByZW1vdmVRdWVyeVJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFtxdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmVwYXJlOiAoMCwgaW1wb3J0X3Rvb2xraXQ2LnByZXBhcmVBdXRvQmF0Y2hlZCkoKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBxdWVyeVJlc3VsdFBhdGNoZWQ6IHtcclxuICAgICAgICAgICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2sgPSBfai5wYXlsb2FkLCBxdWVyeUNhY2hlS2V5ID0gX2sucXVlcnlDYWNoZUtleSwgcGF0Y2hlcyA9IF9rLnBhdGNoZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5LCBmdW5jdGlvbiAoc3Vic3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9ICgwLCBpbXBvcnRfaW1tZXIzLmFwcGx5UGF0Y2hlcykoc3Vic3RhdGUuZGF0YSwgcGF0Y2hlcy5jb25jYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJlcGFyZTogKDAsIGltcG9ydF90b29sa2l0Ni5wcmVwYXJlQXV0b0JhdGNoZWQpKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFSZWR1Y2VyczogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5VGh1bmsucGVuZGluZywgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfai5tZXRhLCBhcmcgPSBfai5tZXRhLmFyZztcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXBzZXJ0aW5nID0gaXNVcHNlcnRRdWVyeShhcmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5zdWJzY3JpYmUgfHwgdXBzZXJ0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gZHJhZnRbX2EgPSBhcmcucXVlcnlDYWNoZUtleV0pICE9IG51bGwgPyBfYiA6IGRyYWZ0W19hXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgZnVuY3Rpb24gKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gUXVlcnlTdGF0dXMucGVuZGluZztcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgPSB1cHNlcnRpbmcgJiYgc3Vic3RhdGUucmVxdWVzdElkID8gc3Vic3RhdGUucmVxdWVzdElkIDogbWV0YS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5vcmlnaW5hbEFyZ3MgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5vcmlnaW5hbEFyZ3MgPSBhcmcub3JpZ2luYWxBcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5zdGFydGVkVGltZVN0YW1wID0gbWV0YS5zdGFydGVkVGltZVN0YW1wO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLmFkZENhc2UocXVlcnlUaHVuay5mdWxmaWxsZWQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gX2oubWV0YSwgcGF5bG9hZCA9IF9qLnBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIG1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXksIGZ1bmN0aW9uIChzdWJzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCAmJiAhaXNVcHNlcnRRdWVyeShtZXRhLmFyZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2UgPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdLm1lcmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRpbWVTdGFtcF8xID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXAsIGFyZ18xID0gbWV0YS5hcmcsIGJhc2VRdWVyeU1ldGFfMSA9IG1ldGEuYmFzZVF1ZXJ5TWV0YSwgcmVxdWVzdElkXzEgPSBtZXRhLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVOZXh0U3RhdGUpKHN1YnN0YXRlLmRhdGEsIGZ1bmN0aW9uIChkcmFmdFN1YnN0YXRlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZShkcmFmdFN1YnN0YXRlRGF0YSwgcGF5bG9hZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmc6IGFyZ18xLm9yaWdpbmFsQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YTogYmFzZVF1ZXJ5TWV0YV8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IGZ1bGZpbGxlZFRpbWVTdGFtcF8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZF8xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBuZXdEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSAoKF9hID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXS5zdHJ1Y3R1cmFsU2hhcmluZykgIT0gbnVsbCA/IF9hIDogdHJ1ZSkgPyBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKCgwLCBpbXBvcnRfaW1tZXIyLmlzRHJhZnQpKHN1YnN0YXRlLmRhdGEpID8gKDAsIGltcG9ydF9pbW1lcjMub3JpZ2luYWwpKHN1YnN0YXRlLmRhdGEpIDogc3Vic3RhdGUuZGF0YSwgcGF5bG9hZCkgOiBwYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3Vic3RhdGUuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuZnVsZmlsbGVkVGltZVN0YW1wID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShxdWVyeVRodW5rLnJlamVjdGVkLCBmdW5jdGlvbiAoZHJhZnQsIF9qKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2sgPSBfai5tZXRhLCBjb25kaXRpb24gPSBfay5jb25kaXRpb24sIGFyZyA9IF9rLmFyZywgcmVxdWVzdElkID0gX2sucmVxdWVzdElkLCBlcnJvciA9IF9qLmVycm9yLCBwYXlsb2FkID0gX2oucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIGZ1bmN0aW9uIChzdWJzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCAhPSBudWxsID8gcGF5bG9hZCA6IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyaWVzID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pLnF1ZXJpZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMocXVlcmllcyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrZXkgPSBfbFswXSwgZW50cnkgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5zdGF0dXMpID09PSBRdWVyeVN0YXR1cy5mdWxmaWxsZWQgfHwgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5zdGF0dXMpID09PSBRdWVyeVN0YXR1cy5yZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBtdXRhdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvbXV0YXRpb25zXCIsXHJcbiAgICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHJlZHVjZXI6IGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IF9qLnBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gZ2V0TXV0YXRpb25DYWNoZUtleShwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkgaW4gZHJhZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRyYWZ0W2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJlcGFyZTogKDAsIGltcG9ydF90b29sa2l0Ni5wcmVwYXJlQXV0b0JhdGNoZWQpKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFSZWR1Y2VyczogZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgYnVpbGRlci5hZGRDYXNlKG11dGF0aW9uVGh1bmsucGVuZGluZywgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfai5tZXRhLCBfayA9IF9qLm1ldGEsIHJlcXVlc3RJZCA9IF9rLnJlcXVlc3RJZCwgYXJnID0gX2suYXJnLCBzdGFydGVkVGltZVN0YW1wID0gX2suc3RhcnRlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIGlmICghYXJnLnRyYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGRyYWZ0W2dldE11dGF0aW9uQ2FjaGVLZXkobWV0YSldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcDogc3RhcnRlZFRpbWVTdGFtcFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShtdXRhdGlvblRodW5rLmZ1bGZpbGxlZCwgZnVuY3Rpb24gKGRyYWZ0LCBfaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBfai5wYXlsb2FkLCBtZXRhID0gX2oubWV0YTtcclxuICAgICAgICAgICAgICAgIGlmICghbWV0YS5hcmcudHJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCBmdW5jdGlvbiAoc3Vic3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsucmVqZWN0ZWQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gX2oucGF5bG9hZCwgZXJyb3IgPSBfai5lcnJvciwgbWV0YSA9IF9qLm1ldGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgZnVuY3Rpb24gKHN1YnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBRdWVyeVN0YXR1cy5yZWplY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzdGF0ZS5lcnJvciA9IHBheWxvYWQgIT0gbnVsbCA/IHBheWxvYWQgOiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbnMgPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikubXV0YXRpb25zO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5lbnRyaWVzKG11dGF0aW9ucyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBrZXkgPSBfbFswXSwgZW50cnkgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuc3RhdHVzKSA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkIHx8IChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuc3RhdHVzKSA9PT0gUXVlcnlTdGF0dXMucmVqZWN0ZWQpICYmIGtleSAhPT0gKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWZ0W2tleV0gPSBlbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGludmFsaWRhdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvaW52YWxpZGF0aW9uXCIsXHJcbiAgICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgdXBkYXRlUHJvdmlkZWRCeToge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKGRyYWZ0LCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5LCBwcm92aWRlZFRhZ3MgPSBfai5wcm92aWRlZFRhZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBfbCA9IE9iamVjdC52YWx1ZXMoZHJhZnQpOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnVHlwZVN1YnNjcmlwdGlvbnMgPSBfbFtfa107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9tID0gMCwgX28gPSBPYmplY3QudmFsdWVzKHRhZ1R5cGVTdWJzY3JpcHRpb25zKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZFN1YnNjcmlwdGlvbnMgPSBfb1tfbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRBdCA9IGlkU3Vic2NyaXB0aW9ucy5pbmRleE9mKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQXQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcCA9IDAsIHByb3ZpZGVkVGFnc18xID0gcHJvdmlkZWRUYWdzOyBfcCA8IHByb3ZpZGVkVGFnc18xLmxlbmd0aDsgX3ArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3EgPSBwcm92aWRlZFRhZ3NfMVtfcF0sIHR5cGUgPSBfcS50eXBlLCBpZCA9IF9xLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoX2QgPSAoX2IgPSAoX2EgPSBkcmFmdFt0eXBlXSkgIT0gbnVsbCA/IF9hIDogZHJhZnRbdHlwZV0gPSB7fSlbX2MgPSBpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSkgIT0gbnVsbCA/IF9kIDogX2JbX2NdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5U3Vic2NyaWJlZCA9IHN1YnNjcmliZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlTdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByZXBhcmU6ICgwLCBpbXBvcnRfdG9vbGtpdDYucHJlcGFyZUF1dG9CYXRjaGVkKSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4dHJhUmVkdWNlcnM6IGZ1bmN0aW9uIChidWlsZGVyKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVNsaWNlLmFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQsIGZ1bmN0aW9uIChkcmFmdCwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBfbCA9IE9iamVjdC52YWx1ZXMoZHJhZnQpOyBfayA8IF9sLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdUeXBlU3Vic2NyaXB0aW9ucyA9IF9sW19rXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gT2JqZWN0LnZhbHVlcyh0YWdUeXBlU3Vic2NyaXB0aW9ucyk7IF9tIDwgX28ubGVuZ3RoOyBfbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZFN1YnNjcmlwdGlvbnMgPSBfb1tfbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEF0ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIGZ1bmN0aW9uIChkcmFmdCwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZWQgPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikucHJvdmlkZWQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMocHJvdmlkZWQpOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfbCA9IF9rW19qXSwgdHlwZSA9IF9sWzBdLCBpbmNvbWluZ1RhZ3MgPSBfbFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdUYWdzKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wID0gX29bX21dLCBpZCA9IF9wWzBdLCBjYWNoZUtleXMgPSBfcFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZWRRdWVyaWVzID0gKF9kID0gKF9iID0gKF9hID0gZHJhZnRbdHlwZV0pICE9IG51bGwgPyBfYSA6IGRyYWZ0W3R5cGVdID0ge30pW19jID0gaWQgfHwgXCJfX2ludGVybmFsX3dpdGhvdXRfaWRcIl0pICE9IG51bGwgPyBfZCA6IF9iW19jXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcSA9IDAsIGNhY2hlS2V5c18xID0gY2FjaGVLZXlzOyBfcSA8IGNhY2hlS2V5c18xLmxlbmd0aDsgX3ErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBjYWNoZUtleXNfMVtfcV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5hZGRNYXRjaGVyKCgwLCBpbXBvcnRfdG9vbGtpdDYuaXNBbnlPZikoKDAsIGltcG9ydF90b29sa2l0Ni5pc0Z1bGZpbGxlZCkocXVlcnlUaHVuayksICgwLCBpbXBvcnRfdG9vbGtpdDYuaXNSZWplY3RlZFdpdGhWYWx1ZSkocXVlcnlUaHVuaykpLCBmdW5jdGlvbiAoZHJhZnQsIGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVkVGFncyA9IGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIFwicHJvdmlkZXNUYWdzXCIsIGRlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKTtcclxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gYWN0aW9uLm1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRpb25TbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUHJvdmlkZWRCeShkcmFmdCwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucy51cGRhdGVQcm92aWRlZEJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkVGFnczogcHJvdmlkZWRUYWdzXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvblNsaWNlID0gKDAsIGltcG9ydF90b29sa2l0Ni5jcmVhdGVTbGljZSkoe1xyXG4gICAgICAgIG5hbWU6IHJlZHVjZXJQYXRoICsgXCIvc3Vic2NyaXB0aW9uc1wiLFxyXG4gICAgICAgIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlLFxyXG4gICAgICAgIHJlZHVjZXJzOiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnM6IGZ1bmN0aW9uIChkLCBhKSB7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQ6IGZ1bmN0aW9uIChkLCBhKSB7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVybmFsX3Byb2JlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbiAoZCwgYSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UgPSAoMCwgaW1wb3J0X3Rvb2xraXQ2LmNyZWF0ZVNsaWNlKSh7XHJcbiAgICAgICAgbmFtZTogcmVkdWNlclBhdGggKyBcIi9pbnRlcm5hbFN1YnNjcmlwdGlvbnNcIixcclxuICAgICAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSxcclxuICAgICAgICByZWR1Y2Vyczoge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zVXBkYXRlZDoge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9pbW1lcjMuYXBwbHlQYXRjaGVzKShzdGF0ZSwgYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByZXBhcmU6ICgwLCBpbXBvcnRfdG9vbGtpdDYucHJlcGFyZUF1dG9CYXRjaGVkKSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBjb25maWdTbGljZSA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY3JlYXRlU2xpY2UpKHtcclxuICAgICAgICBuYW1lOiByZWR1Y2VyUGF0aCArIFwiL2NvbmZpZ1wiLFxyXG4gICAgICAgIGluaXRpYWxTdGF0ZTogX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICBvbmxpbmU6IGlzT25saW5lKCksXHJcbiAgICAgICAgICAgIGZvY3VzZWQ6IGlzRG9jdW1lbnRWaXNpYmxlKCksXHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVSZWdpc3RlcmVkOiBmYWxzZVxyXG4gICAgICAgIH0sIGNvbmZpZyksXHJcbiAgICAgICAgcmVkdWNlcnM6IHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZVJlZ2lzdGVyZWQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2opIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gX2oucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09IFwiY29uZmxpY3RcIiB8fCBhcGlVaWQgIT09IHBheWxvYWQgPyBcImNvbmZsaWN0XCIgOiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHRyYVJlZHVjZXJzOiBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBidWlsZGVyLmFkZENhc2Uob25PbmxpbmUsIGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUub25saW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShvbk9mZmxpbmUsIGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUub25saW5lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmFkZENhc2Uob25Gb2N1cywgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzTG9zdCwgZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCBmdW5jdGlvbiAoZHJhZnQpIHsgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKHt9LCBkcmFmdCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIGNvbWJpbmVkUmVkdWNlciA9ICgwLCBpbXBvcnRfdG9vbGtpdDYuY29tYmluZVJlZHVjZXJzKSh7XHJcbiAgICAgICAgcXVlcmllczogcXVlcnlTbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIG11dGF0aW9uczogbXV0YXRpb25TbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIHByb3ZpZGVkOiBpbnZhbGlkYXRpb25TbGljZS5yZWR1Y2VyLFxyXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IGludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlLnJlZHVjZXIsXHJcbiAgICAgICAgY29uZmlnOiBjb25maWdTbGljZS5yZWR1Y2VyXHJcbiAgICB9KTtcclxuICAgIHZhciByZWR1Y2VyID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHsgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcihyZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikgPyB2b2lkIDAgOiBzdGF0ZSwgYWN0aW9uKTsgfTtcclxuICAgIHZhciBhY3Rpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29uZmlnU2xpY2UuYWN0aW9ucyksIHF1ZXJ5U2xpY2UuYWN0aW9ucyksIHN1YnNjcmlwdGlvblNsaWNlLmFjdGlvbnMpLCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zKSwgbXV0YXRpb25TbGljZS5hY3Rpb25zKSwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucyksIHtcclxuICAgICAgICB1bnN1YnNjcmliZU11dGF0aW9uUmVzdWx0OiBtdXRhdGlvblNsaWNlLmFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQsXHJcbiAgICAgICAgcmVzZXRBcGlTdGF0ZTogcmVzZXRBcGlTdGF0ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4geyByZWR1Y2VyOiByZWR1Y2VyLCBhY3Rpb25zOiBhY3Rpb25zIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTZWxlY3RvcnMudHNcclxudmFyIHNraXBUb2tlbiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiUlRLUS9za2lwVG9rZW5cIik7XHJcbnZhciBza2lwU2VsZWN0b3IgPSBza2lwVG9rZW47XHJcbnZhciBpbml0aWFsU3ViU3RhdGUgPSB7XHJcbiAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWRcclxufTtcclxudmFyIGRlZmF1bHRRdWVyeVN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovICgwLCBpbXBvcnRfdG9vbGtpdDcuY3JlYXRlTmV4dFN0YXRlKShpbml0aWFsU3ViU3RhdGUsIGZ1bmN0aW9uICgpIHtcclxufSk7XHJcbnZhciBkZWZhdWx0TXV0YXRpb25TdWJTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoMCwgaW1wb3J0X3Rvb2xraXQ3LmNyZWF0ZU5leHRTdGF0ZSkoaW5pdGlhbFN1YlN0YXRlLCBmdW5jdGlvbiAoKSB7XHJcbn0pO1xyXG5mdW5jdGlvbiBidWlsZFNlbGVjdG9ycyhfaikge1xyXG4gICAgdmFyIHNlcmlhbGl6ZVF1ZXJ5QXJncyA9IF9qLnNlcmlhbGl6ZVF1ZXJ5QXJncywgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aDtcclxuICAgIHZhciBzZWxlY3RTa2lwcGVkUXVlcnkgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGRlZmF1bHRRdWVyeVN1YlN0YXRlOyB9O1xyXG4gICAgdmFyIHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gZGVmYXVsdE11dGF0aW9uU3ViU3RhdGU7IH07XHJcbiAgICByZXR1cm4geyBidWlsZFF1ZXJ5U2VsZWN0b3I6IGJ1aWxkUXVlcnlTZWxlY3RvciwgYnVpbGRNdXRhdGlvblNlbGVjdG9yOiBidWlsZE11dGF0aW9uU2VsZWN0b3IsIHNlbGVjdEludmFsaWRhdGVkQnk6IHNlbGVjdEludmFsaWRhdGVkQnkgfTtcclxuICAgIGZ1bmN0aW9uIHdpdGhSZXF1ZXN0RmxhZ3Moc3Vic3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHN1YnN0YXRlKSwgZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2VsZWN0SW50ZXJuYWxTdGF0ZShyb290U3RhdGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSByb290U3RhdGVbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgYHN0YXRlLlwiICsgcmVkdWNlclBhdGggKyBcImAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocXVlcnlBcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQXJncyA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUFyZ3M6IHF1ZXJ5QXJncyxcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbjogZW5kcG9pbnREZWZpbml0aW9uLFxyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnROYW1lOiBlbmRwb2ludE5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RRdWVyeVN1YnN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBzZWxlY3RJbnRlcm5hbFN0YXRlKHN0YXRlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYltzZXJpYWxpemVkQXJnc10pICE9IG51bGwgPyBfYyA6IGRlZmF1bHRRdWVyeVN1YlN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlID0gcXVlcnlBcmdzID09PSBza2lwVG9rZW4gPyBzZWxlY3RTa2lwcGVkUXVlcnkgOiBzZWxlY3RRdWVyeVN1YnN0YXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF90b29sa2l0Ny5jcmVhdGVTZWxlY3RvcikoZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRNdXRhdGlvblNlbGVjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgbXV0YXRpb25JZDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25JZCA9IChfYSA9IGdldE11dGF0aW9uQ2FjaGVLZXkoaWQpKSAhPSBudWxsID8gX2EgOiBza2lwVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbklkID0gaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNlbGVjdE11dGF0aW9uU3Vic3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTIsIF9iLCBfYztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EyID0gc2VsZWN0SW50ZXJuYWxTdGF0ZShzdGF0ZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIubXV0YXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2JbbXV0YXRpb25JZF0pICE9IG51bGwgPyBfYyA6IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfdG9vbGtpdDcuY3JlYXRlU2VsZWN0b3IpKGZpbmFsU2VsZWN0TXV0YXRpb25TdWJzdGF0ZSwgd2l0aFJlcXVlc3RGbGFncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGFwaVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIHZhciB0b0ludmFsaWRhdGUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IHRhZ3MubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIHRhZyA9IF9rW19qXTtcclxuICAgICAgICAgICAgdmFyIHByb3ZpZGVkID0gYXBpU3RhdGUucHJvdmlkZWRbdGFnLnR5cGVdO1xyXG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMgPSAoX2EgPSB0YWcuaWQgIT09IHZvaWQgMCA/IHByb3ZpZGVkW3RhZy5pZF0gOiBmbGF0dGVuKE9iamVjdC52YWx1ZXMocHJvdmlkZWQpKSkgIT0gbnVsbCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9sID0gMCwgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnNfMSA9IGludmFsaWRhdGVTdWJzY3JpcHRpb25zOyBfbCA8IGludmFsaWRhdGVTdWJzY3JpcHRpb25zXzEubGVuZ3RoOyBfbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52YWxpZGF0ZSA9IGludmFsaWRhdGVTdWJzY3JpcHRpb25zXzFbX2xdO1xyXG4gICAgICAgICAgICAgICAgdG9JbnZhbGlkYXRlLmFkZChpbnZhbGlkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxhdHRlbihBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSkubWFwKGZ1bmN0aW9uIChxdWVyeUNhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBxdWVyeVN1YlN0YXRlID0gYXBpU3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5U3ViU3RhdGUgPyBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSxcclxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludE5hbWU6IHF1ZXJ5U3ViU3RhdGUuZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSA6IFtdO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG4vLyBzcmMvcXVlcnkvZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncy50c1xyXG52YXIgaW1wb3J0X3Rvb2xraXQ4ID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBjYWNoZSA9IFdlYWtNYXAgPyBuZXcgV2Vha01hcCgpIDogdm9pZCAwO1xyXG52YXIgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGVuZHBvaW50TmFtZSA9IF9qLmVuZHBvaW50TmFtZSwgcXVlcnlBcmdzID0gX2oucXVlcnlBcmdzO1xyXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBcIlwiO1xyXG4gICAgdmFyIGNhY2hlZCA9IGNhY2hlID09IG51bGwgPyB2b2lkIDAgOiBjYWNoZS5nZXQocXVlcnlBcmdzKTtcclxuICAgIGlmICh0eXBlb2YgY2FjaGVkID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgc2VyaWFsaXplZCA9IGNhY2hlZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5QXJncywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgcmV0dXJuICgwLCBpbXBvcnRfdG9vbGtpdDguaXNQbGFpbk9iamVjdCkodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5Mikge1xyXG4gICAgICAgICAgICBhY2Nba2V5Ml0gPSB2YWx1ZVtrZXkyXTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LCB7fSkgOiB2YWx1ZTsgfSk7XHJcbiAgICAgICAgaWYgKCgwLCBpbXBvcnRfdG9vbGtpdDguaXNQbGFpbk9iamVjdCkocXVlcnlBcmdzKSkge1xyXG4gICAgICAgICAgICBjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5kcG9pbnROYW1lICsgXCIoXCIgKyBzZXJpYWxpemVkICsgXCIpXCI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jcmVhdGVBcGkudHNcclxudmFyIGltcG9ydF90b29sa2l0OSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIkByZWR1eGpzL3Rvb2xraXRcIikpO1xyXG52YXIgaW1wb3J0X3Jlc2VsZWN0ID0gX190b01vZHVsZShyZXF1aXJlKFwicmVzZWxlY3RcIikpO1xyXG5mdW5jdGlvbiBidWlsZENyZWF0ZUFwaSgpIHtcclxuICAgIHZhciBtb2R1bGVzID0gW107XHJcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgYXJndW1lbnRzLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgIG1vZHVsZXNbX2pdID0gYXJndW1lbnRzW19qXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBiYXNlQ3JlYXRlQXBpKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyA9ICgwLCBpbXBvcnRfcmVzZWxlY3QuZGVmYXVsdE1lbW9pemUpKGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIChfYiA9IG9wdGlvbnMuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgYWN0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICByZWR1Y2VyUGF0aDogKF9hID0gb3B0aW9ucy5yZWR1Y2VyUGF0aCkgIT0gbnVsbCA/IF9hIDogXCJhcGlcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogXCJhcGlcIixcclxuICAgICAgICAgICAga2VlcFVudXNlZERhdGFGb3I6IDYwLFxyXG4gICAgICAgICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVmZXRjaE9uRm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IGZhbHNlXHJcbiAgICAgICAgfSwgb3B0aW9ucyksIHtcclxuICAgICAgICAgICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbzogZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcclxuICAgICAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiBmdW5jdGlvbiAocXVlcnlBcmdzQXBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic2VyaWFsaXplUXVlcnlBcmdzXCIgaW4gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludFNRQV8xID0gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbi5zZXJpYWxpemVRdWVyeUFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBmdW5jdGlvbiAocXVlcnlBcmdzQXBpMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFJlc3VsdCA9IGVuZHBvaW50U1FBXzEocXVlcnlBcmdzQXBpMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBxdWVyeUFyZ3NBcGkyKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogaW5pdGlhbFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YWdUeXBlczogX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy50YWdUeXBlcyB8fCBbXSlcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uczoge30sXHJcbiAgICAgICAgICAgIGJhdGNoOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFwaVVpZDogKDAsIGltcG9ydF90b29sa2l0OS5uYW5vaWQpKCksXHJcbiAgICAgICAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm86IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXHJcbiAgICAgICAgICAgIGhhc1JlaHlkcmF0aW9uSW5mbzogKDAsIGltcG9ydF9yZXNlbGVjdC5kZWZhdWx0TWVtb2l6ZSkoZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pICE9IG51bGw7IH0pXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYXBpID0ge1xyXG4gICAgICAgICAgICBpbmplY3RFbmRwb2ludHM6IGluamVjdEVuZHBvaW50cyxcclxuICAgICAgICAgICAgZW5oYW5jZUVuZHBvaW50czogZnVuY3Rpb24gKF9qKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkVGFnVHlwZXMgPSBfai5hZGRUYWdUeXBlcywgZW5kcG9pbnRzID0gX2ouZW5kcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFRhZ1R5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCBhZGRUYWdUeXBlc18xID0gYWRkVGFnVHlwZXM7IF9rIDwgYWRkVGFnVHlwZXNfMS5sZW5ndGg7IF9rKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVUID0gYWRkVGFnVHlwZXNfMVtfa107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5pbmNsdWRlcyhlVCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNXaXRoRGVmYXVsdHMudGFnVHlwZXMucHVzaChlVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2wgPSAwLCBfbSA9IE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cyk7IF9sIDwgX20ubGVuZ3RoOyBfbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbyA9IF9tW19sXSwgZW5kcG9pbnROYW1lID0gX29bMF0sIHBhcnRpYWxEZWZpbml0aW9uID0gX29bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydGlhbERlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbERlZmluaXRpb24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSB8fCB7fSwgcGFydGlhbERlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGluaXRpYWxpemVkTW9kdWxlcyA9IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmluaXQoYXBpLCBvcHRpb25zV2l0aERlZmF1bHRzLCBjb250ZXh0KTsgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gaW5qZWN0RW5kcG9pbnRzKGluamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XHJcbiAgICAgICAgICAgICAgICBxdWVyeTogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHgpLCB7IHR5cGU6IERlZmluaXRpb25UeXBlLnF1ZXJ5IH0pOyB9LFxyXG4gICAgICAgICAgICAgICAgbXV0YXRpb246IGZ1bmN0aW9uICh4KSB7IHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB4KSwgeyB0eXBlOiBEZWZpbml0aW9uVHlwZS5tdXRhdGlvbiB9KTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5lbnRyaWVzKGV2YWx1YXRlZEVuZHBvaW50cyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2wgPSBfa1tfal0sIGVuZHBvaW50TmFtZSA9IF9sWzBdLCBkZWZpbml0aW9uID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluamVjdC5vdmVycmlkZUV4aXN0aW5nICYmIGVuZHBvaW50TmFtZSBpbiBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FsbGVkIGBpbmplY3RFbmRwb2ludHNgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lIFwiICsgZW5kcG9pbnROYW1lICsgXCIgd2l0aG91dCBzcGVjaWZ5aW5nIGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlYFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIGluaXRpYWxpemVkTW9kdWxlc18xID0gaW5pdGlhbGl6ZWRNb2R1bGVzOyBfbSA8IGluaXRpYWxpemVkTW9kdWxlc18xLmxlbmd0aDsgX20rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gaW5pdGlhbGl6ZWRNb2R1bGVzXzFbX21dO1xyXG4gICAgICAgICAgICAgICAgICAgIG0uaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBpLmluamVjdEVuZHBvaW50cyh7IGVuZHBvaW50czogb3B0aW9ucy5lbmRwb2ludHMgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9xdWVyeS9mYWtlQmFzZVF1ZXJ5LnRzXHJcbmZ1bmN0aW9uIGZha2VCYXNlUXVlcnkoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gdXNpbmcgYGZha2VCYXNlUXVlcnlgLCBhbGwgcXVlcmllcyAmIG11dGF0aW9ucyBtdXN0IHVzZSB0aGUgYHF1ZXJ5Rm5gIGRlZmluaXRpb24gc3ludGF4LlwiKTtcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2luZGV4LnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDEzID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUNvbGxlY3Rpb24udHNcclxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcclxuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxudmFyIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTID0gMjE0NzQ4MzY0NyAvIDFlMyAtIDE7XHJcbnZhciBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBhcGkgPSBfai5hcGksIGNvbnRleHQgPSBfai5jb250ZXh0LCBpbnRlcm5hbFN0YXRlID0gX2ouaW50ZXJuYWxTdGF0ZTtcclxuICAgIHZhciBfayA9IGFwaS5pbnRlcm5hbEFjdGlvbnMsIHJlbW92ZVF1ZXJ5UmVzdWx0ID0gX2sucmVtb3ZlUXVlcnlSZXN1bHQsIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQgPSBfay51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0O1xyXG4gICAgZnVuY3Rpb24gYW55U3Vic2NyaXB0aW9uc1JlbWFpbmluZ0ZvcktleShxdWVyeUNhY2hlS2V5KSB7XHJcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnMgJiYgIWlzT2JqZWN0RW1wdHkoc3Vic2NyaXB0aW9ucyk7XHJcbiAgICB9XHJcbiAgICB2YXIgY3VycmVudFJlbW92YWxUaW1lb3V0cyA9IHt9O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSwgaW50ZXJuYWxTdGF0ZTIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBhY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgICAgICBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCAoX2EgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmVudHJpZXMoY3VycmVudFJlbW92YWxUaW1lb3V0cyk7IF9qIDwgX2subGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2wgPSBfa1tfal0sIGtleSA9IF9sWzBdLCB0aW1lb3V0ID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dClcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IGNvbnRleHQuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pLnF1ZXJpZXM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9tID0gMCwgX28gPSBPYmplY3QuZW50cmllcyhxdWVyaWVzKTsgX20gPCBfby5sZW5ndGg7IF9tKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcCA9IF9vW19tXSwgcXVlcnlDYWNoZUtleSA9IF9wWzBdLCBxdWVyeVN0YXRlID0gX3BbMV07XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCBxdWVyeVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeVN0YXRlLmVuZHBvaW50TmFtZSwgbXdBcGksIHN0YXRlLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgZW5kcG9pbnROYW1lLCBhcGkyLCBjb25maWcpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgIHZhciBrZWVwVW51c2VkRGF0YUZvciA9IChfYSA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLmtlZXBVbnVzZWREYXRhRm9yKSAhPSBudWxsID8gX2EgOiBjb25maWcua2VlcFVudXNlZERhdGFGb3I7XHJcbiAgICAgICAgaWYgKGtlZXBVbnVzZWREYXRhRm9yID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaW5hbEtlZXBVbnVzZWREYXRhRm9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oa2VlcFVudXNlZERhdGFGb3IsIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTKSk7XHJcbiAgICAgICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZW91dCA9IGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRUaW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW3F1ZXJ5Q2FjaGVLZXldID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHsgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICAgICAgfSwgZmluYWxLZWVwVW51c2VkRGF0YUZvciAqIDFlMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbnZhbGlkYXRpb25CeVRhZ3MudHNcclxudmFyIGltcG9ydF90b29sa2l0MTAgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIHJlZHVjZXJQYXRoID0gX2oucmVkdWNlclBhdGgsIGNvbnRleHQgPSBfai5jb250ZXh0LCBlbmRwb2ludERlZmluaXRpb25zID0gX2ouY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zLCBtdXRhdGlvblRodW5rID0gX2oubXV0YXRpb25UaHVuaywgYXBpID0gX2ouYXBpLCBhc3NlcnRUYWdUeXBlID0gX2ouYXNzZXJ0VGFnVHlwZSwgcmVmZXRjaFF1ZXJ5ID0gX2oucmVmZXRjaFF1ZXJ5O1xyXG4gICAgdmFyIHJlbW92ZVF1ZXJ5UmVzdWx0ID0gYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdDtcclxuICAgIHZhciBpc1RodW5rQWN0aW9uV2l0aFRhZ3MgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMC5pc0FueU9mKSgoMCwgaW1wb3J0X3Rvb2xraXQxMC5pc0Z1bGZpbGxlZCkobXV0YXRpb25UaHVuayksICgwLCBpbXBvcnRfdG9vbGtpdDEwLmlzUmVqZWN0ZWRXaXRoVmFsdWUpKG11dGF0aW9uVGh1bmspKTtcclxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgbXdBcGkpIHtcclxuICAgICAgICBpZiAoaXNUaHVua0FjdGlvbldpdGhUYWdzKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJpbnZhbGlkYXRlc1RhZ3NcIiwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLmludmFsaWRhdGVUYWdzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeShhY3Rpb24ucGF5bG9hZCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlVGFncyh0YWdzLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciByb290U3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHJvb3RTdGF0ZVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcclxuICAgICAgICBjb250ZXh0LmJhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzQXJyYXkgPSBBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMCwgdmFsdWVzQXJyYXlfMSA9IHZhbHVlc0FycmF5OyBfaiA8IHZhbHVlc0FycmF5XzEubGVuZ3RoOyBfaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlDYWNoZUtleSA9IHZhbHVlc0FycmF5XzFbX2pdLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSAoX2EgPSBzdGF0ZS5zdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldKSAhPSBudWxsID8gX2EgOiB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWVyeVN1YlN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG13QXBpLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3BvbGxpbmcudHNcclxudmFyIGJ1aWxkUG9sbGluZ0hhbmRsZXIgPSBmdW5jdGlvbiAoX2opIHtcclxuICAgIHZhciByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBxdWVyeVRodW5rID0gX2oucXVlcnlUaHVuaywgYXBpID0gX2ouYXBpLCByZWZldGNoUXVlcnkgPSBfai5yZWZldGNoUXVlcnksIGludGVybmFsU3RhdGUgPSBfai5pbnRlcm5hbFN0YXRlO1xyXG4gICAgdmFyIGN1cnJlbnRQb2xscyA9IHt9O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB1cGRhdGVQb2xsaW5nSW50ZXJ2YWwoYWN0aW9uLnBheWxvYWQsIG13QXBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pIHx8IHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSAmJiBhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcclxuICAgICAgICAgICAgdXBkYXRlUG9sbGluZ0ludGVydmFsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgIWFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICBzdGFydE5leHRQb2xsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyUG9sbHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gc3RhcnROZXh0UG9sbChfaiwgYXBpMikge1xyXG4gICAgICAgIHZhciBxdWVyeUNhY2hlS2V5ID0gX2oucXVlcnlDYWNoZUtleTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xyXG4gICAgICAgIHZhciBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaXB0aW9ucyk7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobG93ZXN0UG9sbGluZ0ludGVydmFsKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICBpZiAoY3VycmVudFBvbGwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRQb2xsLnRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRQb2xsLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9sbC50aW1lb3V0ID0gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgIHZhciBjdXJyZW50SW50ZXJ2YWwgPSBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV0gPSB7XHJcbiAgICAgICAgICAgIG5leHRQb2xsVGltZXN0YW1wOiBuZXh0UG9sbFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsOiBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsLnRpbWVvdXQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XHJcbiAgICAgICAgICAgIH0sIGxvd2VzdFBvbGxpbmdJbnRlcnZhbClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9sbGluZ0ludGVydmFsKF9qLCBhcGkyKSB7XHJcbiAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5O1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpcHRpb25zKTtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXBQb2xsRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcclxuICAgICAgICB2YXIgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgICAgIGlmICghY3VycmVudFBvbGwgfHwgbmV4dFBvbGxUaW1lc3RhbXAgPCBjdXJyZW50UG9sbC5uZXh0UG9sbFRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICBzdGFydE5leHRQb2xsKHsgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSB9LCBhcGkyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGVhbnVwUG9sbEZvcktleShrZXkpIHtcclxuICAgICAgICB2YXIgZXhpc3RpbmdQb2xsID0gY3VycmVudFBvbGxzW2tleV07XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUG9sbCA9PSBudWxsID8gdm9pZCAwIDogZXhpc3RpbmdQb2xsLnRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nUG9sbC50aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRQb2xsc1trZXldO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJQb2xscygpIHtcclxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9rID0gT2JqZWN0LmtleXMoY3VycmVudFBvbGxzKTsgX2ogPCBfay5sZW5ndGg7IF9qKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IF9rW19qXTtcclxuICAgICAgICAgICAgY2xlYW51cFBvbGxGb3JLZXkoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzID09PSB2b2lkIDApIHsgc3Vic2NyaWJlcnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghIXN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBNYXRoLm1pbihzdWJzY3JpYmVyc1trZXldLnBvbGxpbmdJbnRlcnZhbCwgbG93ZXN0UG9sbGluZ0ludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG93ZXN0UG9sbGluZ0ludGVydmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbn07XHJcbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS93aW5kb3dFdmVudEhhbmRsaW5nLnRzXHJcbnZhciBidWlsZFdpbmRvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIHJlZHVjZXJQYXRoID0gX2oucmVkdWNlclBhdGgsIGNvbnRleHQgPSBfai5jb250ZXh0LCBhcGkgPSBfai5hcGksIHJlZmV0Y2hRdWVyeSA9IF9qLnJlZmV0Y2hRdWVyeSwgaW50ZXJuYWxTdGF0ZSA9IF9qLmludGVybmFsU3RhdGU7XHJcbiAgICB2YXIgcmVtb3ZlUXVlcnlSZXN1bHQgPSBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25Gb2N1c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uT25saW5lLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25SZWNvbm5lY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHJlZmV0Y2hWYWxpZFF1ZXJpZXMoYXBpMiwgdHlwZSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XHJcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBzdGF0ZS5xdWVyaWVzO1xyXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcclxuICAgICAgICBjb250ZXh0LmJhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwLCBfayA9IE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnMpOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5Q2FjaGVLZXkgPSBfa1tfal07XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlTdWJTdGF0ZSA9IHF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBzdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25TdWJTdGF0ZSB8fCAhcXVlcnlTdWJTdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZWZldGNoID0gT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuc29tZShmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWJbdHlwZV0gPT09IHRydWU7IH0pIHx8IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpLmV2ZXJ5KGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Ylt0eXBlXSA9PT0gdm9pZCAwOyB9KSAmJiBzdGF0ZS5jb25maWdbdHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVmZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVyO1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUudHNcclxudmFyIGltcG9ydF90b29sa2l0MTEgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJAcmVkdXhqcy90b29sa2l0XCIpKTtcclxudmFyIG5ldmVyUmVzb2x2ZWRFcnJvciA9IG5ldyBFcnJvcihcIlByb21pc2UgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlIGNhY2hlRW50cnlSZW1vdmVkLlwiKTtcclxudmFyIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyID0gZnVuY3Rpb24gKF9qKSB7XHJcbiAgICB2YXIgYXBpID0gX2ouYXBpLCByZWR1Y2VyUGF0aCA9IF9qLnJlZHVjZXJQYXRoLCBjb250ZXh0ID0gX2ouY29udGV4dCwgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfai5tdXRhdGlvblRodW5rLCBpbnRlcm5hbFN0YXRlID0gX2ouaW50ZXJuYWxTdGF0ZTtcclxuICAgIHZhciBpc1F1ZXJ5VGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMS5pc0FzeW5jVGh1bmtBY3Rpb24pKHF1ZXJ5VGh1bmspO1xyXG4gICAgdmFyIGlzTXV0YXRpb25UaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDExLmlzQXN5bmNUaHVua0FjdGlvbikobXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNGdWxmaWxsZWRUaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDExLmlzRnVsZmlsbGVkKShxdWVyeVRodW5rLCBtdXRhdGlvblRodW5rKTtcclxuICAgIHZhciBsaWZlY3ljbGVNYXAgPSB7fTtcclxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGFjdGlvbiwgbXdBcGksIHN0YXRlQmVmb3JlKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoYWN0aW9uKTtcclxuICAgICAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gc3RhdGVCZWZvcmVbcmVkdWNlclBhdGhdLnF1ZXJpZXNbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5xdWVyaWVzW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgaWYgKCFvbGRTdGF0ZSAmJiBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlTmV3S2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgYWN0aW9uLm1ldGEucmVxdWVzdElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtdXRhdGlvblRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5tdXRhdGlvbnNbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU5ld0tleShhY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzLCBjYWNoZUtleSwgbXdBcGksIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGdWxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlID09IG51bGwgPyB2b2lkIDAgOiBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5wYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIGxpZmVjeWNsZSA9IGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XHJcbiAgICAgICAgICAgIGlmIChsaWZlY3ljbGUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMCwgX2sgPSBPYmplY3QuZW50cmllcyhsaWZlY3ljbGVNYXApOyBfaiA8IF9rLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sID0gX2tbX2pdLCBjYWNoZUtleTIgPSBfbFswXSwgbGlmZWN5Y2xlID0gX2xbMV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW2NhY2hlS2V5Ml07XHJcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBnZXRDYWNoZUtleShhY3Rpb24pIHtcclxuICAgICAgICBpZiAoaXNRdWVyeVRodW5rKGFjdGlvbikpXHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleTtcclxuICAgICAgICBpZiAoaXNNdXRhdGlvblRodW5rKGFjdGlvbikpXHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkLnF1ZXJ5Q2FjaGVLZXk7XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIGdldE11dGF0aW9uQ2FjaGVLZXkoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBxdWVyeUNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xyXG4gICAgICAgIHZhciBvbkNhY2hlRW50cnlBZGRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLm9uQ2FjaGVFbnRyeUFkZGVkO1xyXG4gICAgICAgIGlmICghb25DYWNoZUVudHJ5QWRkZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgbGlmZWN5Y2xlID0ge307XHJcbiAgICAgICAgdmFyIGNhY2hlRW50cnlSZW1vdmVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY2FjaGVEYXRhTG9hZGVkID0gUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGNhY2hlRW50cnlSZW1vdmVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV2ZXJSZXNvbHZlZEVycm9yO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNhY2hlRGF0YUxvYWRlZC5jYXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3F1ZXJ5Q2FjaGVLZXldID0gbGlmZWN5Y2xlO1xyXG4gICAgICAgIHZhciBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gb3JpZ2luYWxBcmdzIDogcXVlcnlDYWNoZUtleSk7XHJcbiAgICAgICAgdmFyIGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goZnVuY3Rpb24gKF8sIF9fLCBleHRyYTIpIHsgcmV0dXJuIGV4dHJhMjsgfSk7XHJcbiAgICAgICAgdmFyIGxpZmVjeWNsZUFwaSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG13QXBpKSwge1xyXG4gICAgICAgICAgICBnZXRDYWNoZUVudHJ5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKTsgfSxcclxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gZnVuY3Rpb24gKHVwZGF0ZVJlY2lwZSkgeyByZXR1cm4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKTsgfSA6IHZvaWQgMCxcclxuICAgICAgICAgICAgY2FjaGVEYXRhTG9hZGVkOiBjYWNoZURhdGFMb2FkZWQsXHJcbiAgICAgICAgICAgIGNhY2hlRW50cnlSZW1vdmVkOiBjYWNoZUVudHJ5UmVtb3ZlZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBydW5uaW5nSGFuZGxlciA9IG9uQ2FjaGVFbnRyeUFkZGVkKG9yaWdpbmFsQXJncywgbGlmZWN5Y2xlQXBpKTtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUocnVubmluZ0hhbmRsZXIpLmNhdGNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSBuZXZlclJlc29sdmVkRXJyb3IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlLnRzXHJcbnZhciBpbXBvcnRfdG9vbGtpdDEyID0gX190b01vZHVsZShyZXF1aXJlKFwiQHJlZHV4anMvdG9vbGtpdFwiKSk7XHJcbnZhciBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGFwaSA9IF9qLmFwaSwgY29udGV4dCA9IF9qLmNvbnRleHQsIHF1ZXJ5VGh1bmsgPSBfai5xdWVyeVRodW5rLCBtdXRhdGlvblRodW5rID0gX2oubXV0YXRpb25UaHVuaztcclxuICAgIHZhciBpc1BlbmRpbmdUaHVuayA9ICgwLCBpbXBvcnRfdG9vbGtpdDEyLmlzUGVuZGluZykocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNSZWplY3RlZFRodW5rID0gKDAsIGltcG9ydF90b29sa2l0MTIuaXNSZWplY3RlZCkocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgaXNGdWxsZmlsbGVkVGh1bmsgPSAoMCwgaW1wb3J0X3Rvb2xraXQxMi5pc0Z1bGZpbGxlZCkocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XHJcbiAgICB2YXIgbGlmZWN5Y2xlTWFwID0ge307XHJcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChhY3Rpb24sIG13QXBpKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgaWYgKGlzUGVuZGluZ1RodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9qLnJlcXVlc3RJZCwgX2sgPSBfai5hcmcsIGVuZHBvaW50TmFtZV8xID0gX2suZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3NfMSA9IF9rLm9yaWdpbmFsQXJncztcclxuICAgICAgICAgICAgdmFyIGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVfMV07XHJcbiAgICAgICAgICAgIHZhciBvblF1ZXJ5U3RhcnRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZW5kcG9pbnREZWZpbml0aW9uLm9uUXVlcnlTdGFydGVkO1xyXG4gICAgICAgICAgICBpZiAob25RdWVyeVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaWZlY3ljbGVfMSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5RnVsZmlsbGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZV8xLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZV8xLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlGdWxmaWxsZWQuY2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXSA9IGxpZmVjeWNsZV8xO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yXzEgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV8xXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gb3JpZ2luYWxBcmdzXzEgOiByZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goZnVuY3Rpb24gKF8sIF9fLCBleHRyYTIpIHsgcmV0dXJuIGV4dHJhMjsgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlmZWN5Y2xlQXBpID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbXdBcGkpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVFbnRyeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0b3JfMShtd0FwaS5nZXRTdGF0ZSgpKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5ID8gZnVuY3Rpb24gKHVwZGF0ZVJlY2lwZSkgeyByZXR1cm4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZV8xLCBvcmlnaW5hbEFyZ3NfMSwgdXBkYXRlUmVjaXBlKSk7IH0gOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlGdWxmaWxsZWQ6IHF1ZXJ5RnVsZmlsbGVkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9uUXVlcnlTdGFydGVkKG9yaWdpbmFsQXJnc18xLCBsaWZlY3ljbGVBcGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRnVsbGZpbGxlZFRodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9sID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9sLnJlcXVlc3RJZCwgYmFzZVF1ZXJ5TWV0YSA9IF9sLmJhc2VRdWVyeU1ldGE7XHJcbiAgICAgICAgICAgIChfYSA9IGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIG1ldGE6IGJhc2VRdWVyeU1ldGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWplY3RlZFRodW5rKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9tID0gYWN0aW9uLm1ldGEsIHJlcXVlc3RJZCA9IF9tLnJlcXVlc3RJZCwgcmVqZWN0ZWRXaXRoVmFsdWUgPSBfbS5yZWplY3RlZFdpdGhWYWx1ZSwgYmFzZVF1ZXJ5TWV0YSA9IF9tLmJhc2VRdWVyeU1ldGE7XHJcbiAgICAgICAgICAgIChfYyA9IGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVqZWN0KHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiAoX2IgPSBhY3Rpb24ucGF5bG9hZCkgIT0gbnVsbCA/IF9iIDogYWN0aW9uLmVycm9yLFxyXG4gICAgICAgICAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2Rldk1pZGRsZXdhcmUudHNcclxudmFyIGJ1aWxkRGV2Q2hlY2tIYW5kbGVyID0gZnVuY3Rpb24gKF9qKSB7XHJcbiAgICB2YXIgYXBpID0gX2ouYXBpLCBhcGlVaWQgPSBfai5jb250ZXh0LmFwaVVpZCwgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkKGFwaVVpZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5wYXlsb2FkID09PSBhcGlVaWQgJiYgKChfYiA9IChfYSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWlkZGxld2FyZVJlZ2lzdGVyZWQpID09PSBcImNvbmZsaWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIGlzIGEgbWlzbWF0Y2ggYmV0d2VlbiBzbGljZSBhbmQgbWlkZGxld2FyZSBmb3IgdGhlIHJlZHVjZXJQYXRoIFxcXCJcIiArIHJlZHVjZXJQYXRoICsgXCJcXFwiLlxcbllvdSBjYW4gb25seSBoYXZlIG9uZSBhcGkgcGVyIHJlZHVjZXIgcGF0aCwgdGhpcyB3aWxsIGxlYWQgdG8gY3Jhc2hlcyBpbiB2YXJpb3VzIHNpdHVhdGlvbnMhXCIgKyAocmVkdWNlclBhdGggPT09IFwiYXBpXCIgPyBcIlxcbklmIHlvdSBoYXZlIG11bHRpcGxlIGFwaXMsIHlvdSAqaGF2ZSogdG8gc3BlY2lmeSB0aGUgcmVkdWNlclBhdGggb3B0aW9uIHdoZW4gdXNpbmcgY3JlYXRlQXBpIVwiIDogXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2JhdGNoQWN0aW9ucy50c1xyXG52YXIgaW1wb3J0X2ltbWVyNCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIHByb21pc2U7XHJcbnZhciBxdWV1ZU1pY3JvdGFza1NoaW0gPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09IFwiZnVuY3Rpb25cIiA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBnbG9iYWxUaGlzKSA6IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpLnRoZW4oY2IpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgdGhyb3cgZXJyO1xyXG59LCAwKTsgfSk7IH07XHJcbnZhciBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciA9IGZ1bmN0aW9uIChfaikge1xyXG4gICAgdmFyIGFwaSA9IF9qLmFwaSwgcXVlcnlUaHVuayA9IF9qLnF1ZXJ5VGh1bmssIGludGVybmFsU3RhdGUgPSBfai5pbnRlcm5hbFN0YXRlO1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvbnNQcmVmaXggPSBhcGkucmVkdWNlclBhdGggKyBcIi9zdWJzY3JpcHRpb25zXCI7XHJcbiAgICB2YXIgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbnVsbDtcclxuICAgIHZhciBkaXNwYXRjaFF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgdmFyIF9rID0gYXBpLmludGVybmFsQWN0aW9ucywgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IF9rLnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMsIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQgPSBfay51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0O1xyXG4gICAgdmFyIGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChtdXRhYmxlU3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xyXG4gICAgICAgIGlmICh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9qID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfai5xdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQgPSBfai5yZXF1ZXN0SWQsIG9wdGlvbnMgPSBfai5vcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoKF9hID0gbXV0YWJsZVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVtyZXF1ZXN0SWRdKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9rID0gYWN0aW9uLnBheWxvYWQsIHF1ZXJ5Q2FjaGVLZXkgPSBfay5xdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQgPSBfay5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmIChtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgbXV0YWJsZVN0YXRlW2FjdGlvbi5wYXlsb2FkLnF1ZXJ5Q2FjaGVLZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHZhciBfbCA9IGFjdGlvbi5tZXRhLCBhcmcgPSBfbC5hcmcsIHJlcXVlc3RJZCA9IF9sLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJzdGF0ZSA9IChfYyA9IG11dGFibGVTdGF0ZVtfYiA9IGFyZy5xdWVyeUNhY2hlS2V5XSkgIT0gbnVsbCA/IF9jIDogbXV0YWJsZVN0YXRlW19iXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IChfZSA9IChfZCA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zKSAhPSBudWxsID8gX2QgOiBzdWJzdGF0ZVtyZXF1ZXN0SWRdKSAhPSBudWxsID8gX2UgOiB7fTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgdmFyIF9tID0gYWN0aW9uLm1ldGEsIGNvbmRpdGlvbiA9IF9tLmNvbmRpdGlvbiwgYXJnID0gX20uYXJnLCByZXF1ZXN0SWQgPSBfbS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0YXRlID0gKF9nID0gbXV0YWJsZVN0YXRlW19mID0gYXJnLnF1ZXJ5Q2FjaGVLZXldKSAhPSBudWxsID8gX2cgOiBtdXRhYmxlU3RhdGVbX2ZdID0ge307XHJcbiAgICAgICAgICAgICAgICBzdWJzdGF0ZVtyZXF1ZXN0SWRdID0gKF9pID0gKF9oID0gYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMpICE9IG51bGwgPyBfaCA6IHN1YnN0YXRlW3JlcXVlc3RJZF0pICE9IG51bGwgPyBfaSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uLCBtd0FwaSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91c1N1YnNjcmlwdGlvbnMpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfcHJvYmVTdWJzY3JpcHRpb24ubWF0Y2goYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgX2ogPSBhY3Rpb24ucGF5bG9hZCwgcXVlcnlDYWNoZUtleSA9IF9qLnF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCA9IF9qLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgdmFyIGhhc1N1YnNjcmlwdGlvbiA9ICEhKChfYSA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV0pID09IG51bGwgPyB2b2lkIDAgOiBfYVtyZXF1ZXN0SWRdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgaGFzU3Vic2NyaXB0aW9uXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpZE11dGF0ZSA9IGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyhpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zLCBhY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaWRNdXRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKCFkaXNwYXRjaFF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2tTaGltKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3Vic2NyaXB0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfaiA9ICgwLCBpbXBvcnRfaW1tZXI0LnByb2R1Y2VXaXRoUGF0Y2hlcykocHJldmlvdXNTdWJzY3JpcHRpb25zLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdTdWJzY3JpcHRpb25zOyB9KSwgcGF0Y2hlcyA9IF9qWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG13QXBpLm5leHQoYXBpLmludGVybmFsQWN0aW9ucy5zdWJzY3JpcHRpb25zVXBkYXRlZChwYXRjaGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbmV3U3Vic2NyaXB0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gPSAhISgoX2IgPSBhY3Rpb24udHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoc3Vic2NyaXB0aW9uc1ByZWZpeCkpO1xyXG4gICAgICAgICAgICB2YXIgaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uID0gcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbiAmJiAhIWFjdGlvbi5tZXRhLmFyZy5zdWJzY3JpYmU7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25TaG91bGRDb250aW51ZSA9ICFpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uICYmICFpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb247XHJcbiAgICAgICAgICAgIHJldHVybiBbYWN0aW9uU2hvdWxkQ29udGludWUsIGZhbHNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt0cnVlLCBmYWxzZV07XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvaW5kZXgudHNcclxuZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlKGlucHV0KSB7XHJcbiAgICB2YXIgcmVkdWNlclBhdGggPSBpbnB1dC5yZWR1Y2VyUGF0aCwgcXVlcnlUaHVuayA9IGlucHV0LnF1ZXJ5VGh1bmssIGFwaSA9IGlucHV0LmFwaSwgY29udGV4dCA9IGlucHV0LmNvbnRleHQ7XHJcbiAgICB2YXIgYXBpVWlkID0gY29udGV4dC5hcGlVaWQ7XHJcbiAgICB2YXIgYWN0aW9ucyA9IHtcclxuICAgICAgICBpbnZhbGlkYXRlVGFnczogKDAsIGltcG9ydF90b29sa2l0MTMuY3JlYXRlQWN0aW9uKShyZWR1Y2VyUGF0aCArIFwiL2ludmFsaWRhdGVUYWdzXCIpXHJcbiAgICB9O1xyXG4gICAgdmFyIGlzVGhpc0FwaVNsaWNlQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAhIWFjdGlvbiAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYWN0aW9uLnR5cGUuc3RhcnRzV2l0aChyZWR1Y2VyUGF0aCArIFwiL1wiKTtcclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlckJ1aWxkZXJzID0gW1xyXG4gICAgICAgIGJ1aWxkRGV2Q2hlY2tIYW5kbGVyLFxyXG4gICAgICAgIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlcixcclxuICAgICAgICBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIsXHJcbiAgICAgICAgYnVpbGRQb2xsaW5nSGFuZGxlcixcclxuICAgICAgICBidWlsZENhY2hlTGlmZWN5Y2xlSGFuZGxlcixcclxuICAgICAgICBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlclxyXG4gICAgXTtcclxuICAgIHZhciBtaWRkbGV3YXJlID0gZnVuY3Rpb24gKG13QXBpKSB7XHJcbiAgICAgICAgdmFyIGluaXRpYWxpemVkMiA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpbnRlcm5hbFN0YXRlID0ge1xyXG4gICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBidWlsZGVyQXJncyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGlucHV0KSwge1xyXG4gICAgICAgICAgICBpbnRlcm5hbFN0YXRlOiBpbnRlcm5hbFN0YXRlLFxyXG4gICAgICAgICAgICByZWZldGNoUXVlcnk6IHJlZmV0Y2hRdWVyeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IGhhbmRsZXJCdWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkKSB7IHJldHVybiBidWlsZChidWlsZGVyQXJncyk7IH0pO1xyXG4gICAgICAgIHZhciBiYXRjaGVkQWN0aW9uc0hhbmRsZXIgPSBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlcihidWlsZGVyQXJncyk7XHJcbiAgICAgICAgdmFyIHdpbmRvd0V2ZW50c0hhbmRsZXIgPSBidWlsZFdpbmRvd0V2ZW50SGFuZGxlcihidWlsZGVyQXJncyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxpemVkMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtd0FwaVdpdGhOZXh0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbXdBcGkpLCB7IG5leHQ6IG5leHQgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVCZWZvcmUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9qID0gYmF0Y2hlZEFjdGlvbnNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpLCBhY3Rpb25TaG91bGRDb250aW51ZSA9IF9qWzBdLCBoYXNTdWJzY3JpcHRpb24gPSBfalsxXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uU2hvdWxkQ29udGludWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBoYXNTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoISFtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0V2ZW50c0hhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGhpc0FwaVNsaWNlQWN0aW9uKGFjdGlvbikgfHwgY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2sgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19rXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgbWlkZGxld2FyZTogbWlkZGxld2FyZSwgYWN0aW9uczogYWN0aW9ucyB9O1xyXG4gICAgZnVuY3Rpb24gcmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXksIG92ZXJyaWRlKSB7XHJcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBxdWVyeVRodW5rKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxyXG4gICAgICAgICAgICBlbmRwb2ludE5hbWU6IHF1ZXJ5U3ViU3RhdGUuZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IHF1ZXJ5U3ViU3RhdGUub3JpZ2luYWxBcmdzLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXHJcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHF1ZXJ5Q2FjaGVLZXlcclxuICAgICAgICB9LCBvdmVycmlkZSkpO1xyXG4gICAgfVxyXG59XHJcbi8vIHNyYy9xdWVyeS90c0hlbHBlcnMudHNcclxuZnVuY3Rpb24gYXNzZXJ0Q2FzdCh2KSB7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUFzc2lnbih0YXJnZXQpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaiA9IDE7IF9qIDwgYXJndW1lbnRzLmxlbmd0aDsgX2orKykge1xyXG4gICAgICAgIGFyZ3NbX2ogLSAxXSA9IGFyZ3VtZW50c1tfal07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX19zcHJlYWRBcnJheShbdGFyZ2V0XSwgYXJncykpO1xyXG59XHJcbi8vIHNyYy9xdWVyeS9jb3JlL21vZHVsZS50c1xyXG52YXIgaW1wb3J0X2ltbWVyNSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImltbWVyXCIpKTtcclxudmFyIGNvcmVNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xyXG52YXIgY29yZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICBuYW1lOiBjb3JlTW9kdWxlTmFtZSxcclxuICAgIGluaXQ6IGZ1bmN0aW9uIChhcGksIF9qLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGJhc2VRdWVyeSA9IF9qLmJhc2VRdWVyeSwgdGFnVHlwZXMgPSBfai50YWdUeXBlcywgcmVkdWNlclBhdGggPSBfai5yZWR1Y2VyUGF0aCwgc2VyaWFsaXplUXVlcnlBcmdzID0gX2ouc2VyaWFsaXplUXVlcnlBcmdzLCBrZWVwVW51c2VkRGF0YUZvciA9IF9qLmtlZXBVbnVzZWREYXRhRm9yLCByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlID0gX2oucmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSwgcmVmZXRjaE9uRm9jdXMgPSBfai5yZWZldGNoT25Gb2N1cywgcmVmZXRjaE9uUmVjb25uZWN0ID0gX2oucmVmZXRjaE9uUmVjb25uZWN0O1xyXG4gICAgICAgICgwLCBpbXBvcnRfaW1tZXI1LmVuYWJsZVBhdGNoZXMpKCk7XHJcbiAgICAgICAgYXNzZXJ0Q2FzdChzZXJpYWxpemVRdWVyeUFyZ3MpO1xyXG4gICAgICAgIHZhciBhc3NlcnRUYWdUeXBlID0gZnVuY3Rpb24gKHRhZykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdUeXBlcy5pbmNsdWRlcyh0YWcudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGFnIHR5cGUgJ1wiICsgdGFnLnR5cGUgKyBcIicgd2FzIHVzZWQsIGJ1dCBub3Qgc3BlY2lmaWVkIGluIGB0YWdUeXBlc2AhXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YWc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGgsXHJcbiAgICAgICAgICAgIGVuZHBvaW50czoge30sXHJcbiAgICAgICAgICAgIGludGVybmFsQWN0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgb25PbmxpbmU6IG9uT25saW5lLFxyXG4gICAgICAgICAgICAgICAgb25PZmZsaW5lOiBvbk9mZmxpbmUsXHJcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBvbkZvY3VzLFxyXG4gICAgICAgICAgICAgICAgb25Gb2N1c0xvc3Q6IG9uRm9jdXNMb3N0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHV0aWw6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIF9rID0gYnVpbGRUaHVua3Moe1xyXG4gICAgICAgICAgICBiYXNlUXVlcnk6IGJhc2VRdWVyeSxcclxuICAgICAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICBhcGk6IGFwaSxcclxuICAgICAgICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiBzZXJpYWxpemVRdWVyeUFyZ3MsXHJcbiAgICAgICAgICAgIGFzc2VydFRhZ1R5cGU6IGFzc2VydFRhZ1R5cGVcclxuICAgICAgICB9KSwgcXVlcnlUaHVuayA9IF9rLnF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmsgPSBfay5tdXRhdGlvblRodW5rLCBwYXRjaFF1ZXJ5RGF0YSA9IF9rLnBhdGNoUXVlcnlEYXRhLCB1cGRhdGVRdWVyeURhdGEgPSBfay51cGRhdGVRdWVyeURhdGEsIHVwc2VydFF1ZXJ5RGF0YSA9IF9rLnVwc2VydFF1ZXJ5RGF0YSwgcHJlZmV0Y2ggPSBfay5wcmVmZXRjaCwgYnVpbGRNYXRjaFRodW5rQWN0aW9ucyA9IF9rLmJ1aWxkTWF0Y2hUaHVua0FjdGlvbnM7XHJcbiAgICAgICAgdmFyIF9sID0gYnVpbGRTbGljZSh7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIHF1ZXJ5VGh1bms6IHF1ZXJ5VGh1bmssXHJcbiAgICAgICAgICAgIG11dGF0aW9uVGh1bms6IG11dGF0aW9uVGh1bmssXHJcbiAgICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aCxcclxuICAgICAgICAgICAgYXNzZXJ0VGFnVHlwZTogYXNzZXJ0VGFnVHlwZSxcclxuICAgICAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25Gb2N1czogcmVmZXRjaE9uRm9jdXMsXHJcbiAgICAgICAgICAgICAgICByZWZldGNoT25SZWNvbm5lY3Q6IHJlZmV0Y2hPblJlY29ubmVjdCxcclxuICAgICAgICAgICAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U6IHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXHJcbiAgICAgICAgICAgICAgICBrZWVwVW51c2VkRGF0YUZvcjoga2VlcFVudXNlZERhdGFGb3IsXHJcbiAgICAgICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCByZWR1Y2VyID0gX2wucmVkdWNlciwgc2xpY2VBY3Rpb25zID0gX2wuYWN0aW9ucztcclxuICAgICAgICBzYWZlQXNzaWduKGFwaS51dGlsLCB7XHJcbiAgICAgICAgICAgIHBhdGNoUXVlcnlEYXRhOiBwYXRjaFF1ZXJ5RGF0YSxcclxuICAgICAgICAgICAgdXBkYXRlUXVlcnlEYXRhOiB1cGRhdGVRdWVyeURhdGEsXHJcbiAgICAgICAgICAgIHVwc2VydFF1ZXJ5RGF0YTogdXBzZXJ0UXVlcnlEYXRhLFxyXG4gICAgICAgICAgICBwcmVmZXRjaDogcHJlZmV0Y2gsXHJcbiAgICAgICAgICAgIHJlc2V0QXBpU3RhdGU6IHNsaWNlQWN0aW9ucy5yZXNldEFwaVN0YXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGkuaW50ZXJuYWxBY3Rpb25zLCBzbGljZUFjdGlvbnMpO1xyXG4gICAgICAgIHZhciBfbSA9IGJ1aWxkTWlkZGxld2FyZSh7XHJcbiAgICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aCxcclxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgcXVlcnlUaHVuazogcXVlcnlUaHVuayxcclxuICAgICAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICAgICAgYXBpOiBhcGksXHJcbiAgICAgICAgICAgIGFzc2VydFRhZ1R5cGU6IGFzc2VydFRhZ1R5cGVcclxuICAgICAgICB9KSwgbWlkZGxld2FyZSA9IF9tLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmVBY3Rpb25zID0gX20uYWN0aW9ucztcclxuICAgICAgICBzYWZlQXNzaWduKGFwaS51dGlsLCBtaWRkbGV3YXJlQWN0aW9ucyk7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGksIHsgcmVkdWNlcjogcmVkdWNlciwgbWlkZGxld2FyZTogbWlkZGxld2FyZSB9KTtcclxuICAgICAgICB2YXIgX28gPSBidWlsZFNlbGVjdG9ycyh7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogc2VyaWFsaXplUXVlcnlBcmdzLFxyXG4gICAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGhcclxuICAgICAgICB9KSwgYnVpbGRRdWVyeVNlbGVjdG9yID0gX28uYnVpbGRRdWVyeVNlbGVjdG9yLCBidWlsZE11dGF0aW9uU2VsZWN0b3IgPSBfby5idWlsZE11dGF0aW9uU2VsZWN0b3IsIHNlbGVjdEludmFsaWRhdGVkQnkgPSBfby5zZWxlY3RJbnZhbGlkYXRlZEJ5O1xyXG4gICAgICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHsgc2VsZWN0SW52YWxpZGF0ZWRCeTogc2VsZWN0SW52YWxpZGF0ZWRCeSB9KTtcclxuICAgICAgICB2YXIgX3AgPSBidWlsZEluaXRpYXRlKHtcclxuICAgICAgICAgICAgcXVlcnlUaHVuazogcXVlcnlUaHVuayxcclxuICAgICAgICAgICAgbXV0YXRpb25UaHVuazogbXV0YXRpb25UaHVuayxcclxuICAgICAgICAgICAgYXBpOiBhcGksXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogc2VyaWFsaXplUXVlcnlBcmdzLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XHJcbiAgICAgICAgfSksIGJ1aWxkSW5pdGlhdGVRdWVyeSA9IF9wLmJ1aWxkSW5pdGlhdGVRdWVyeSwgYnVpbGRJbml0aWF0ZU11dGF0aW9uID0gX3AuYnVpbGRJbml0aWF0ZU11dGF0aW9uLCBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayA9IF9wLmdldFJ1bm5pbmdNdXRhdGlvblRodW5rLCBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsgPSBfcC5nZXRSdW5uaW5nTXV0YXRpb25zVGh1bmssIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsgPSBfcC5nZXRSdW5uaW5nUXVlcmllc1RodW5rLCBnZXRSdW5uaW5nUXVlcnlUaHVuayA9IF9wLmdldFJ1bm5pbmdRdWVyeVRodW5rLCBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMgPSBfcC5nZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMsIHJlbW92YWxXYXJuaW5nID0gX3AucmVtb3ZhbFdhcm5pbmc7XHJcbiAgICAgICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xyXG4gICAgICAgICAgICBnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXM6IGdldFJ1bm5pbmdPcGVyYXRpb25Qcm9taXNlcyxcclxuICAgICAgICAgICAgZ2V0UnVubmluZ09wZXJhdGlvblByb21pc2U6IHJlbW92YWxXYXJuaW5nLFxyXG4gICAgICAgICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuazogZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXHJcbiAgICAgICAgICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuazogZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxyXG4gICAgICAgICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuazogZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXHJcbiAgICAgICAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bms6IGdldFJ1bm5pbmdRdWVyaWVzVGh1bmtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiBjb3JlTW9kdWxlTmFtZSxcclxuICAgICAgICAgICAgaW5qZWN0RW5kcG9pbnQ6IGZ1bmN0aW9uIChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW55QXBpID0gYXBpO1xyXG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gYW55QXBpLmVuZHBvaW50cylbZW5kcG9pbnROYW1lXSkgIT0gbnVsbCA/IF9iIDogX2FbZW5kcG9pbnROYW1lXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IGJ1aWxkUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNdXRhdGlvbkRlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbmRwb2ludE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlOiBidWlsZEluaXRpYXRlTXV0YXRpb24oZW5kcG9pbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMobXV0YXRpb25UaHVuaywgZW5kcG9pbnROYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59KTsgfTtcclxuLy8gc3JjL3F1ZXJ5L2NvcmUvaW5kZXgudHNcclxudmFyIGNyZWF0ZUFwaSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydGstcXVlcnkuY2pzLmRldmVsb3BtZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2dlbmVyYXRvciIsInRoaXNBcmciLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwibmV4dCIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwic3RlcCIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsImRvbmUiLCJ2YWx1ZSIsInBvcCIsImxlbmd0aCIsInB1c2giLCJlIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsImkiLCJpbCIsImoiLCJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19kZWZQcm9wcyIsImRlZmluZVByb3BlcnRpZXMiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wRGVzY3MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRPd25Qcm9wU3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsImIiLCJwcm9wIiwiX2oiLCJfayIsIl9fc3ByZWFkUHJvcHMiLCJfX21hcmtBc01vZHVsZSIsInRhcmdldCIsIl9fb2JqUmVzdCIsInNvdXJjZSIsImV4Y2x1ZGUiLCJpbmRleE9mIiwiX19leHBvcnQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiX19yZUV4cG9ydCIsIm1vZHVsZTIiLCJkZXNjIiwiX2xvb3BfMSIsIl9fdG9Nb2R1bGUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwiUXVlcnlTdGF0dXMiLCJidWlsZENyZWF0ZUFwaSIsImNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmciLCJjb3JlTW9kdWxlIiwiY29yZU1vZHVsZU5hbWUiLCJjcmVhdGVBcGkiLCJkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIiwiZmFrZUJhc2VRdWVyeSIsImZldGNoQmFzZVF1ZXJ5IiwicmV0cnkiLCJzZXR1cExpc3RlbmVycyIsInNraXBTZWxlY3RvciIsInNraXBUb2tlbiIsIlF1ZXJ5U3RhdHVzMiIsImdldFJlcXVlc3RTdGF0dXNGbGFncyIsInN0YXR1cyIsImlzVW5pbml0aWFsaXplZCIsInVuaW5pdGlhbGl6ZWQiLCJpc0xvYWRpbmciLCJwZW5kaW5nIiwiaXNTdWNjZXNzIiwiaXNFcnJvciIsImlzQWJzb2x1dGVVcmwiLCJ1cmwiLCJSZWdFeHAiLCJ0ZXN0Iiwid2l0aG91dFRyYWlsaW5nU2xhc2giLCJyZXBsYWNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsImpvaW5VcmxzIiwiYmFzZSIsImRlbGltaXRlciIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsImZsYXR0ZW4iLCJhcnIiLCJjb25jYXQiLCJpc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzRG9jdW1lbnRWaXNpYmxlIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJpbXBvcnRfdG9vbGtpdCIsInJlcXVpcmUiLCJpc1BsYWluT2JqZWN0Iiwib2xkT2JqIiwibmV3T2JqIiwiQXJyYXkiLCJpc0FycmF5IiwibmV3S2V5cyIsImtleXMiLCJvbGRLZXlzIiwiaXNTYW1lT2JqZWN0IiwibWVyZ2VPYmoiLCJuZXdLZXlzXzEiLCJpbXBvcnRfdG9vbGtpdDIiLCJkZWZhdWx0RmV0Y2hGbiIsImFyZ3MiLCJhcmd1bWVudHMiLCJmZXRjaCIsImRlZmF1bHRWYWxpZGF0ZVN0YXR1cyIsInJlc3BvbnNlIiwiZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlIiwiaGVhZGVycyIsInN0cmlwVW5kZWZpbmVkIiwiY29weSIsImVudHJpZXMiLCJfbCIsImsiLCJfYSIsIl90aGlzIiwiX2IiLCJiYXNlVXJsIiwicHJlcGFyZUhlYWRlcnMiLCJmZXRjaEZuIiwicGFyYW1zU2VyaWFsaXplciIsImlzSnNvbkNvbnRlbnRUeXBlIiwiX20iLCJqc29uQ29udGVudFR5cGUiLCJqc29uUmVwbGFjZXIiLCJkZWZhdWx0VGltZW91dCIsInRpbWVvdXQiLCJnbG9iYWxSZXNwb25zZUhhbmRsZXIiLCJyZXNwb25zZUhhbmRsZXIiLCJnbG9iYWxWYWxpZGF0ZVN0YXR1cyIsInZhbGlkYXRlU3RhdHVzIiwiYmFzZUZldGNoT3B0aW9ucyIsImNvbnNvbGUiLCJ3YXJuIiwiYXJnIiwiYXBpIiwic2lnbmFsIiwiZ2V0U3RhdGUiLCJleHRyYSIsImVuZHBvaW50IiwiZm9yY2VkIiwidHlwZSIsIm1ldGEiLCJfYTIiLCJwYXJhbXMiLCJfbyIsInJlc3QiLCJjb25maWciLCJfcCIsImlzSnNvbmlmaWFibGUiLCJkaXZpZGVyIiwicXVlcnkiLCJyZXF1ZXN0IiwicmVxdWVzdENsb25lIiwidGltZWRPdXQiLCJ0aW1lb3V0SWQiLCJlXzEiLCJyZXNwb25zZUNsb25lIiwicmVzdWx0RGF0YSIsInJlc3BvbnNlVGV4dCIsImhhbmRsZVJlc3BvbnNlRXJyb3JfMSIsImVfMiIsIl9xIiwiSGVhZGVycyIsInRvSlNPTiIsImhhcyIsInNldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJSZXF1ZXN0Iiwic2V0VGltZW91dCIsImFib3J0IiwiZXJyb3IiLCJTdHJpbmciLCJjbGVhclRpbWVvdXQiLCJjbG9uZSIsImhhbmRsZVJlc3BvbnNlIiwiciIsInRleHQiLCJvcmlnaW5hbFN0YXR1cyIsImRhdGEiLCJwYXJzZSIsIkhhbmRsZWRFcnJvciIsImRlZmF1bHRCYWNrb2ZmIiwiYXR0ZW1wdCIsIm1heFJldHJpZXMiLCJhdHRlbXB0cyIsIk1hdGgiLCJtaW4iLCJyYW5kb20iLCJyZXMiLCJmYWlsIiwiYXNzaWduIiwidGhyb3dJbW1lZGlhdGVseSIsIkVNUFRZX09QVElPTlMiLCJyZXRyeVdpdGhCYWNrb2ZmIiwiYmFzZVF1ZXJ5IiwiZGVmYXVsdE9wdGlvbnMiLCJleHRyYU9wdGlvbnMiLCJwb3NzaWJsZU1heFJldHJpZXMiLCJkZWZhdWx0UmV0cnlDb25kaXRpb24iLCJvcHRpb25zIiwicmV0cnkyIiwicmVzdWx0IiwiZV8zIiwiZmlsdGVyIiwic2xpY2UiLCJfXyIsImJhY2tvZmYiLCJyZXRyeUNvbmRpdGlvbiIsImJhc2VRdWVyeUFwaSIsImltcG9ydF90b29sa2l0MyIsIm9uRm9jdXMiLCJjcmVhdGVBY3Rpb24iLCJvbkZvY3VzTG9zdCIsIm9uT25saW5lIiwib25PZmZsaW5lIiwiaW5pdGlhbGl6ZWQiLCJkaXNwYXRjaCIsImN1c3RvbUhhbmRsZXIiLCJkZWZhdWx0SGFuZGxlciIsImhhbmRsZUZvY3VzIiwiaGFuZGxlRm9jdXNMb3N0IiwiaGFuZGxlT25saW5lIiwiaGFuZGxlT2ZmbGluZSIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW1wb3J0X3Rvb2xraXQ3IiwiRGVmaW5pdGlvblR5cGUiLCJEZWZpbml0aW9uVHlwZTIiLCJpc1F1ZXJ5RGVmaW5pdGlvbiIsImlzTXV0YXRpb25EZWZpbml0aW9uIiwibXV0YXRpb24iLCJjYWxjdWxhdGVQcm92aWRlZEJ5IiwiZGVzY3JpcHRpb24iLCJxdWVyeUFyZyIsImFzc2VydFRhZ1R5cGVzIiwiaXNGdW5jdGlvbiIsIm1hcCIsImV4cGFuZFRhZ0Rlc2NyaXB0aW9uIiwiaW1wb3J0X3Rvb2xraXQ2IiwiaXNOb3ROdWxsaXNoIiwiZm9yY2VRdWVyeUZuU3ltYm9sIiwiaXNVcHNlcnRRdWVyeSIsImJ1aWxkSW5pdGlhdGUiLCJzZXJpYWxpemVRdWVyeUFyZ3MiLCJxdWVyeVRodW5rIiwibXV0YXRpb25UaHVuayIsImNvbnRleHQiLCJydW5uaW5nUXVlcmllcyIsIk1hcCIsInJ1bm5pbmdNdXRhdGlvbnMiLCJpbnRlcm5hbEFjdGlvbnMiLCJ1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0IiwicmVtb3ZlTXV0YXRpb25SZXN1bHQiLCJ1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zIiwiYnVpbGRJbml0aWF0ZVF1ZXJ5IiwiYnVpbGRJbml0aWF0ZU11dGF0aW9uIiwiZ2V0UnVubmluZ1F1ZXJ5VGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25UaHVuayIsImdldFJ1bm5pbmdRdWVyaWVzVGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsiLCJnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZXMiLCJyZW1vdmFsV2FybmluZyIsIkVycm9yIiwicHJvY2VzcyIsImV4dHJhY3QiLCJ2YWx1ZXMiLCJmbGF0TWFwIiwicXVlcmllc0ZvclN0b3JlIiwiZW5kcG9pbnROYW1lIiwicXVlcnlBcmdzIiwiZW5kcG9pbnREZWZpbml0aW9uIiwiZW5kcG9pbnREZWZpbml0aW9ucyIsInF1ZXJ5Q2FjaGVLZXkiLCJfZW5kcG9pbnROYW1lIiwiZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkIiwibWlkZGxld2FyZVdhcm5pbmciLCJ0cmlnZ2VyZWQiLCJyZWdpc3RlcmVkIiwiaW50ZXJuYWxfcHJvYmVTdWJzY3JpcHRpb24iLCJyZXF1ZXN0SWQiLCJyZWR1Y2VyUGF0aCIsInF1ZXJ5QWN0aW9uIiwic3Vic2NyaWJlIiwiZm9yY2VSZWZldGNoIiwic3Vic2NyaXB0aW9uT3B0aW9ucyIsImZvcmNlUXVlcnlGbiIsInRodW5rIiwib3JpZ2luYWxBcmdzIiwic2VsZWN0b3IiLCJlbmRwb2ludHMiLCJzZWxlY3QiLCJ0aHVua1Jlc3VsdCIsInN0YXRlQWZ0ZXIiLCJza2lwcGVkU3luY2hyb25vdXNseSIsInJ1bm5pbmdRdWVyeSIsInNlbGVjdEZyb21TdGF0ZSIsInN0YXRlUHJvbWlzZSIsInVud3JhcCIsInJlZmV0Y2giLCJydW5uaW5nXzEiLCJkZWxldGUiLCJ0cmFjayIsImZpeGVkQ2FjaGVLZXkiLCJyZXR1cm5WYWx1ZVByb21pc2UiLCJjYXRjaCIsInJlc2V0IiwicmV0IiwicnVubmluZyIsImltcG9ydF90b29sa2l0NCIsImltcG9ydF9pbW1lciIsImltcG9ydF90b29sa2l0NSIsImRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZSIsImJhc2VRdWVyeVJldHVyblZhbHVlIiwiYnVpbGRUaHVua3MiLCJhc3NlcnRUYWdUeXBlIiwicGF0Y2hRdWVyeURhdGEiLCJwYXRjaGVzIiwidXBkYXRlUHJvdmlkZWQiLCJxdWVyeVJlc3VsdFBhdGNoZWQiLCJuZXdWYWx1ZSIsInByb3ZpZGVkVGFncyIsInByb3ZpZGVzVGFncyIsInVwZGF0ZVByb3ZpZGVkQnkiLCJ1cGRhdGVRdWVyeURhdGEiLCJ1cGRhdGVSZWNpcGUiLCJjdXJyZW50U3RhdGUiLCJpbnZlcnNlUGF0Y2hlcyIsInVuZG8iLCJ1dGlsIiwiaXNEcmFmdGFibGUiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJwYXRoIiwidXBzZXJ0UXVlcnlEYXRhIiwiaW5pdGlhdGUiLCJleGVjdXRlRW5kcG9pbnQiLCJfMCIsIl8xIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJiYXNlUXVlcnlBcGlfMSIsIndoYXQiLCJlcnIiLCJlcnJvcl8xIiwiY2F0Y2hlZEVycm9yIiwidHJhbnNmb3JtRXJyb3JSZXNwb25zZSIsImVfNCIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJfciIsImlzRm9yY2VkUXVlcnkiLCJxdWVyeUZuIiwiYXJnMiIsImZ1bGZpbGxlZFRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJiYXNlUXVlcnlNZXRhIiwiU0hPVUxEX0FVVE9CQVRDSCIsInN0YXRlIiwiX2MiLCJfZCIsInJlcXVlc3RTdGF0ZSIsInF1ZXJpZXMiLCJiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJyZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlIiwiZnVsZmlsbGVkVmFsIiwicmVmZXRjaFZhbCIsIk51bWJlciIsImNyZWF0ZUFzeW5jVGh1bmsiLCJnZXRQZW5kaW5nTWV0YSIsInN0YXJ0ZWRUaW1lU3RhbXAiLCJjb25kaXRpb24iLCJxdWVyeVRodW5rQXJncyIsImN1cnJlbnRBcmciLCJwcmV2aW91c0FyZyIsImVuZHBvaW50U3RhdGUiLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsImhhc1RoZUZvcmNlIiwiaGFzTWF4QWdlIiwicHJlZmV0Y2giLCJmb3JjZSIsIm1heEFnZSIsImlmT2xkZXJUaGFuIiwiZm9yY2UyIiwibGF0ZXN0U3RhdGVWYWx1ZSIsImxhc3RGdWxmaWxsZWRUcyIsInNob3VsZFJldHJpZ2dlciIsIm1hdGNoZXNFbmRwb2ludCIsImFjdGlvbiIsImJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMiLCJtYXRjaFBlbmRpbmciLCJpc0FsbE9mIiwiaXNQZW5kaW5nIiwibWF0Y2hGdWxmaWxsZWQiLCJpc0Z1bGZpbGxlZCIsIm1hdGNoUmVqZWN0ZWQiLCJpc1JlamVjdGVkIiwiY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rIiwicGF5bG9hZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJpbXBvcnRfaW1tZXIyIiwiaW1wb3J0X2ltbWVyMyIsInVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyIsInVwZGF0ZSIsInN1YnN0YXRlIiwiZ2V0TXV0YXRpb25DYWNoZUtleSIsImlkIiwidXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzIiwiaW5pdGlhbFN0YXRlIiwiYnVpbGRTbGljZSIsImRlZmluaXRpb25zIiwiYXBpVWlkIiwiZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyIsImhhc1JlaHlkcmF0aW9uSW5mbyIsInJlc2V0QXBpU3RhdGUiLCJxdWVyeVNsaWNlIiwiY3JlYXRlU2xpY2UiLCJyZWR1Y2VycyIsInJlbW92ZVF1ZXJ5UmVzdWx0IiwicmVkdWNlciIsImRyYWZ0IiwicHJlcGFyZSIsInByZXBhcmVBdXRvQmF0Y2hlZCIsImFwcGx5UGF0Y2hlcyIsImV4dHJhUmVkdWNlcnMiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInVwc2VydGluZyIsIm1lcmdlIiwiZnVsZmlsbGVkVGltZVN0YW1wXzEiLCJhcmdfMSIsImJhc2VRdWVyeU1ldGFfMSIsInJlcXVlc3RJZF8xIiwibmV3RGF0YSIsImNyZWF0ZU5leHRTdGF0ZSIsImRyYWZ0U3Vic3RhdGVEYXRhIiwic3RydWN0dXJhbFNoYXJpbmciLCJpc0RyYWZ0Iiwib3JpZ2luYWwiLCJhZGRNYXRjaGVyIiwiZW50cnkiLCJtdXRhdGlvblNsaWNlIiwiY2FjaGVLZXkiLCJtdXRhdGlvbnMiLCJpbnZhbGlkYXRpb25TbGljZSIsInRhZ1R5cGVTdWJzY3JpcHRpb25zIiwiaWRTdWJzY3JpcHRpb25zIiwiZm91bmRBdCIsInNwbGljZSIsInByb3ZpZGVkVGFnc18xIiwic3Vic2NyaWJlZFF1ZXJpZXMiLCJhbHJlYWR5U3Vic2NyaWJlZCIsImluY2x1ZGVzIiwiYWN0aW9ucyIsInByb3ZpZGVkIiwiaW5jb21pbmdUYWdzIiwiY2FjaGVLZXlzIiwiY2FjaGVLZXlzXzEiLCJpc0FueU9mIiwiY2FzZVJlZHVjZXJzIiwic3Vic2NyaXB0aW9uU2xpY2UiLCJkIiwiaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UiLCJzdWJzY3JpcHRpb25zVXBkYXRlZCIsImNvbmZpZ1NsaWNlIiwib25saW5lIiwiZm9jdXNlZCIsIm1pZGRsZXdhcmVSZWdpc3RlcmVkIiwiY29tYmluZWRSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwic3Vic2NyaXB0aW9ucyIsIm1hdGNoIiwidW5zdWJzY3JpYmVNdXRhdGlvblJlc3VsdCIsImZvciIsImluaXRpYWxTdWJTdGF0ZSIsImRlZmF1bHRRdWVyeVN1YlN0YXRlIiwiZGVmYXVsdE11dGF0aW9uU3ViU3RhdGUiLCJidWlsZFNlbGVjdG9ycyIsInNlbGVjdFNraXBwZWRRdWVyeSIsInNlbGVjdFNraXBwZWRNdXRhdGlvbiIsImJ1aWxkUXVlcnlTZWxlY3RvciIsImJ1aWxkTXV0YXRpb25TZWxlY3RvciIsInNlbGVjdEludmFsaWRhdGVkQnkiLCJ3aXRoUmVxdWVzdEZsYWdzIiwic2VsZWN0SW50ZXJuYWxTdGF0ZSIsInJvb3RTdGF0ZSIsInNlcmlhbGl6ZWRBcmdzIiwic2VsZWN0UXVlcnlTdWJzdGF0ZSIsImZpbmFsU2VsZWN0UXVlcnlTdWJTdGF0ZSIsImNyZWF0ZVNlbGVjdG9yIiwibXV0YXRpb25JZCIsInNlbGVjdE11dGF0aW9uU3Vic3RhdGUiLCJmaW5hbFNlbGVjdE11dGF0aW9uU3Vic3RhdGUiLCJ0YWdzIiwiYXBpU3RhdGUiLCJ0b0ludmFsaWRhdGUiLCJTZXQiLCJ0YWciLCJpbnZhbGlkYXRlU3Vic2NyaXB0aW9ucyIsImludmFsaWRhdGVTdWJzY3JpcHRpb25zXzEiLCJpbnZhbGlkYXRlIiwiYWRkIiwicXVlcnlTdWJTdGF0ZSIsImltcG9ydF90b29sa2l0OCIsImNhY2hlIiwiV2Vha01hcCIsInNlcmlhbGl6ZWQiLCJjYWNoZWQiLCJzdHJpbmdpZmllZCIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJrZXkyIiwiaW1wb3J0X3Rvb2xraXQ5IiwiaW1wb3J0X3Jlc2VsZWN0IiwibW9kdWxlcyIsImJhc2VDcmVhdGVBcGkiLCJkZWZhdWx0TWVtb2l6ZSIsIm9wdGlvbnNXaXRoRGVmYXVsdHMiLCJrZWVwVW51c2VkRGF0YUZvciIsInJlZmV0Y2hPbkZvY3VzIiwicmVmZXRjaE9uUmVjb25uZWN0IiwicXVlcnlBcmdzQXBpIiwiZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MiLCJlbmRwb2ludFNRQV8xIiwicXVlcnlBcmdzQXBpMiIsImluaXRpYWxSZXN1bHQiLCJ0YWdUeXBlcyIsImJhdGNoIiwiZm4iLCJuYW5vaWQiLCJpbmplY3RFbmRwb2ludHMiLCJlbmhhbmNlRW5kcG9pbnRzIiwiYWRkVGFnVHlwZXMiLCJhZGRUYWdUeXBlc18xIiwiZVQiLCJwYXJ0aWFsRGVmaW5pdGlvbiIsImluaXRpYWxpemVkTW9kdWxlcyIsIm0iLCJpbml0IiwiaW5qZWN0IiwiZXZhbHVhdGVkRW5kcG9pbnRzIiwiZGVmaW5pdGlvbiIsIm92ZXJyaWRlRXhpc3RpbmciLCJpbml0aWFsaXplZE1vZHVsZXNfMSIsImluamVjdEVuZHBvaW50IiwiaW1wb3J0X3Rvb2xraXQxMyIsImlzT2JqZWN0RW1wdHkiLCJUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyIsImJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciIsImludGVybmFsU3RhdGUiLCJhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5IiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJjdXJyZW50UmVtb3ZhbFRpbWVvdXRzIiwiaGFuZGxlciIsIm13QXBpIiwiaW50ZXJuYWxTdGF0ZTIiLCJoYW5kbGVVbnN1YnNjcmliZSIsInF1ZXJ5U3RhdGUiLCJhcGkyIiwiSW5maW5pdHkiLCJmaW5hbEtlZXBVbnVzZWREYXRhRm9yIiwibWF4IiwiY3VycmVudFRpbWVvdXQiLCJpbXBvcnRfdG9vbGtpdDEwIiwiYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyIiwicmVmZXRjaFF1ZXJ5IiwiaXNUaHVua0FjdGlvbldpdGhUYWdzIiwiaW52YWxpZGF0ZVRhZ3MiLCJ2YWx1ZXNBcnJheSIsInZhbHVlc0FycmF5XzEiLCJzdWJzY3JpcHRpb25TdWJTdGF0ZSIsImJ1aWxkUG9sbGluZ0hhbmRsZXIiLCJjdXJyZW50UG9sbHMiLCJ1cGRhdGVQb2xsaW5nSW50ZXJ2YWwiLCJzdGFydE5leHRQb2xsIiwiY2xlYXJQb2xscyIsImxvd2VzdFBvbGxpbmdJbnRlcnZhbCIsImZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwiLCJpc0Zpbml0ZSIsImN1cnJlbnRQb2xsIiwibmV4dFBvbGxUaW1lc3RhbXAiLCJjdXJyZW50SW50ZXJ2YWwiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjbGVhbnVwUG9sbEZvcktleSIsImV4aXN0aW5nUG9sbCIsInN1YnNjcmliZXJzIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJidWlsZFdpbmRvd0V2ZW50SGFuZGxlciIsInJlZmV0Y2hWYWxpZFF1ZXJpZXMiLCJzaG91bGRSZWZldGNoIiwic29tZSIsInN1YiIsImV2ZXJ5IiwiaW1wb3J0X3Rvb2xraXQxMSIsIm5ldmVyUmVzb2x2ZWRFcnJvciIsImJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyIiwiaXNRdWVyeVRodW5rIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiaXNNdXRhdGlvblRodW5rIiwiaXNGdWxmaWxsZWRUaHVuayIsImxpZmVjeWNsZU1hcCIsInN0YXRlQmVmb3JlIiwiZ2V0Q2FjaGVLZXkiLCJvbGRTdGF0ZSIsImhhbmRsZU5ld0tleSIsImxpZmVjeWNsZSIsInZhbHVlUmVzb2x2ZWQiLCJjYWNoZUVudHJ5UmVtb3ZlZCIsImNhY2hlS2V5MiIsIm9uQ2FjaGVFbnRyeUFkZGVkIiwiY2FjaGVEYXRhTG9hZGVkIiwicmFjZSIsImV4dHJhMiIsImxpZmVjeWNsZUFwaSIsImdldENhY2hlRW50cnkiLCJ1cGRhdGVDYWNoZWREYXRhIiwicnVubmluZ0hhbmRsZXIiLCJpbXBvcnRfdG9vbGtpdDEyIiwiYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXIiLCJpc1BlbmRpbmdUaHVuayIsImlzUmVqZWN0ZWRUaHVuayIsImlzRnVsbGZpbGxlZFRodW5rIiwiZW5kcG9pbnROYW1lXzEiLCJvcmlnaW5hbEFyZ3NfMSIsIm9uUXVlcnlTdGFydGVkIiwibGlmZWN5Y2xlXzEiLCJxdWVyeUZ1bGZpbGxlZCIsInNlbGVjdG9yXzEiLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzVW5oYW5kbGVkRXJyb3IiLCJidWlsZERldkNoZWNrSGFuZGxlciIsImltcG9ydF9pbW1lcjQiLCJwcm9taXNlIiwicXVldWVNaWNyb3Rhc2tTaGltIiwicXVldWVNaWNyb3Rhc2siLCJiaW5kIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiYnVpbGRCYXRjaGVkQWN0aW9uc0hhbmRsZXIiLCJzdWJzY3JpcHRpb25zUHJlZml4IiwicHJldmlvdXNTdWJzY3JpcHRpb25zIiwiZGlzcGF0Y2hRdWV1ZWQiLCJhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMiLCJtdXRhYmxlU3RhdGUiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9pIiwiaGFzU3Vic2NyaXB0aW9uIiwiZGlkTXV0YXRlIiwibmV3U3Vic2NyaXB0aW9ucyIsImlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24iLCJpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb24iLCJhY3Rpb25TaG91bGRDb250aW51ZSIsImJ1aWxkTWlkZGxld2FyZSIsImlucHV0IiwiaXNUaGlzQXBpU2xpY2VBY3Rpb24iLCJoYW5kbGVyQnVpbGRlcnMiLCJtaWRkbGV3YXJlIiwiaW5pdGlhbGl6ZWQyIiwiYnVpbGRlckFyZ3MiLCJoYW5kbGVycyIsImJ1aWxkIiwiYmF0Y2hlZEFjdGlvbnNIYW5kbGVyIiwid2luZG93RXZlbnRzSGFuZGxlciIsIm13QXBpV2l0aE5leHQiLCJoYW5kbGVyc18xIiwib3ZlcnJpZGUiLCJhc3NlcnRDYXN0Iiwic2FmZUFzc2lnbiIsImltcG9ydF9pbW1lcjUiLCJlbmFibGVQYXRjaGVzIiwic2xpY2VBY3Rpb25zIiwibWlkZGxld2FyZUFjdGlvbnMiLCJnZXRSdW5uaW5nT3BlcmF0aW9uUHJvbWlzZSIsImFueUFwaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancerArray: () => (/* binding */ EnhancerArray),\n/* harmony export */   MiddlewareArray: () => (/* binding */ MiddlewareArray),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   getDefaultMiddleware: () => (/* binding */ getDefaultMiddleware),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/es/index.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return isAction(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    var splitType = type ? (\"\" + type).split(\"/\") : [];\n    var actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return 'Detected an action creator with type \"' + (type || \"unknown\") + \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\" + actionName + \"())` instead of `dispatch(\" + actionName + \")`. This is necessary even if the action has no payload.\";\n}\nfunction createActionCreatorInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isActionCreator, isActionCreator2 = _c === void 0 ? isActionCreator : _c;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n        };\n    };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\nvar EnhancerArray = /** @class */ function(_super) {\n    __extends(EnhancerArray, _super);\n    function EnhancerArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, EnhancerArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(EnhancerArray, Symbol.species, {\n        get: function() {\n            return EnhancerArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EnhancerArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    EnhancerArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return EnhancerArray;\n}(Array);\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(val, function() {}) : val;\n}\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path, checkedObjects) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (checkedObjects === void 0) {\n        checkedObjects = new Set();\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_1 = function(key) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return {\n                value: result\n            };\n        }\n    };\n    for(var key in keysToDetect){\n        var state_1 = _loop_1(key);\n        if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache == null ? void 0 : cache.has(value)) return false;\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_2 = function(key, nestedValue) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                value: {\n                    keyPath: nestedPath,\n                    value: nestedValue\n                }\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return {\n                    value: foundNestedSerializable\n                };\n            }\n        }\n    };\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var state_2 = _loop_2(key, nestedValue);\n        if (typeof state_2 === \"object\") return state_2.value;\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for(var _i = 0, _c = Object.values(value); _i < _c.length; _i++){\n        var nestedValue = _c[_i];\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options.disableCache, disableCache = _k === void 0 ? false : _k;\n    var cache = !disableCache && WeakSet ? new WeakSet() : void 0;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e, _f = options.actionCreatorCheck, actionCreatorCheck = _f === void 0 ? true : _f;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n        if (actionCreatorCheck) {\n            var actionCreatorOptions = {};\n            if (!isBoolean(actionCreatorCheck)) {\n                actionCreatorOptions = actionCreatorCheck;\n            }\n            middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var defaultEnhancers = new EnhancerArray(middlewareEnhancer);\n    var storeEnhancers = defaultEnhancers;\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(defaultEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error(\"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error(\"`builder.addCase` cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nvar hasWarnedAboutObjectNotation = false;\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            if (!hasWarnedAboutObjectNotation) {\n                hasWarnedAboutObjectNotation = true;\n                console.warn(\"The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n            }\n        }\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return freezeDraftable(initialState());\n        };\n    } else {\n        var frozenInitialState_1 = freezeDraftable(initialState);\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nvar hasWarnedAboutObjectNotation2 = false;\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (options.initialState === void 0) {\n            console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n        }\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : freezeDraftable(options.initialState);\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        if (true) {\n            if (typeof options.extraReducers === \"object\") {\n                if (!hasWarnedAboutObjectNotation2) {\n                    hasWarnedAboutObjectNotation2 = true;\n                    console.warn(\"The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n        }\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, function(builder) {\n            for(var key in finalCaseReducers){\n                builder.addCase(key, finalCaseReducers[key]);\n            }\n            for(var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++){\n                var m = actionMatchers_1[_i];\n                builder.addMatcher(m.matcher, m.reducer);\n            }\n            if (defaultCaseReducer) {\n                builder.addDefaultCase(defaultCaseReducer);\n            }\n        });\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.keys(state.entities);\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var appliedUpdates = false;\n        for(var _i = 0, updates_1 = updates; _i < updates_1.length; _i++){\n            var update = updates_1[_i];\n            var entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            var newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = function() {\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n            return {\n                payload: payload,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"fulfilled\"\n                })\n            };\n        });\n        var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n            return {\n                payload: void 0,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"pending\"\n                })\n            };\n        });\n        var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n            return {\n                payload: payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                    condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n                })\n            };\n        });\n        var displayedWarning = false;\n        var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n            function class_1() {\n                this.signal = {\n                    aborted: false,\n                    addEventListener: function() {},\n                    dispatchEvent: function() {\n                        return false;\n                    },\n                    onabort: function() {},\n                    removeEventListener: function() {},\n                    reason: void 0,\n                    throwIfAborted: function() {}\n                };\n            }\n            class_1.prototype.abort = function() {\n                if (true) {\n                    if (!displayedWarning) {\n                        displayedWarning = true;\n                        console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                    }\n                }\n            };\n            return class_1;\n        }();\n        function actionCreator(arg) {\n            return function(dispatch, getState, extra) {\n                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                var abortController = new AC();\n                var abortReason;\n                var started = false;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                var promise2 = function() {\n                    return __async(this, null, function() {\n                        var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;\n                        return __generator(this, function(_c) {\n                            switch(_c.label){\n                                case 0:\n                                    _c.trys.push([\n                                        0,\n                                        4,\n                                        ,\n                                        5\n                                    ]);\n                                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                        getState: getState,\n                                        extra: extra\n                                    });\n                                    if (!isThenable(conditionResult)) return [\n                                        3 /*break*/ ,\n                                        2\n                                    ];\n                                    return [\n                                        4 /*yield*/ ,\n                                        conditionResult\n                                    ];\n                                case 1:\n                                    conditionResult = _c.sent();\n                                    _c.label = 2;\n                                case 2:\n                                    if (conditionResult === false || abortController.signal.aborted) {\n                                        throw {\n                                            name: \"ConditionError\",\n                                            message: \"Aborted due to condition callback returning false.\"\n                                        };\n                                    }\n                                    started = true;\n                                    abortedPromise = new Promise(function(_, reject) {\n                                        return abortController.signal.addEventListener(\"abort\", function() {\n                                            return reject({\n                                                name: \"AbortError\",\n                                                message: abortReason || \"Aborted\"\n                                            });\n                                        });\n                                    });\n                                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                        requestId: requestId,\n                                        arg: arg\n                                    }, {\n                                        getState: getState,\n                                        extra: extra\n                                    })));\n                                    return [\n                                        4 /*yield*/ ,\n                                        Promise.race([\n                                            abortedPromise,\n                                            Promise.resolve(payloadCreator(arg, {\n                                                dispatch: dispatch,\n                                                getState: getState,\n                                                extra: extra,\n                                                requestId: requestId,\n                                                signal: abortController.signal,\n                                                abort: abort,\n                                                rejectWithValue: function(value, meta) {\n                                                    return new RejectWithValue(value, meta);\n                                                },\n                                                fulfillWithValue: function(value, meta) {\n                                                    return new FulfillWithMeta(value, meta);\n                                                }\n                                            })).then(function(result) {\n                                                if (result instanceof RejectWithValue) {\n                                                    throw result;\n                                                }\n                                                if (result instanceof FulfillWithMeta) {\n                                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                                }\n                                                return fulfilled(result, requestId, arg);\n                                            })\n                                        ])\n                                    ];\n                                case 3:\n                                    finalAction = _c.sent();\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 4:\n                                    err_1 = _c.sent();\n                                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 5:\n                                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                    if (!skipDispatch) {\n                                        dispatch(finalAction);\n                                    }\n                                    return [\n                                        2 /*return*/ ,\n                                        finalAction\n                                    ];\n                            }\n                        });\n                    });\n                }();\n                return Object.assign(promise2, {\n                    abort: abort,\n                    requestId: requestId,\n                    arg: arg,\n                    unwrap: function() {\n                        return promise2.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending: pending,\n            rejected: rejected,\n            fulfilled: fulfilled,\n            typePrefix: typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = function() {\n        return createAsyncThunk2;\n    };\n    return createAsyncThunk2;\n}();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise2, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise2.catch(onError);\n    return promise2;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return function() {\n        return abortSignal.removeEventListener(\"abort\", callback);\n    };\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise2) {\n    var cleanup = noop;\n    return new Promise(function(resolve, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise2.finally(function() {\n            return cleanup();\n        }).then(resolve, reject);\n    }).finally(function() {\n        cleanup = noop;\n    });\n}\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise2) {\n        return catchRejection(raceWithSignal(signal, promise2).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal, parentBlockingPromises) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor, opts) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        if (opts == null ? void 0 : opts.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve, reject) {\n                            var stopListening = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                            unsubscribe = function() {\n                                stopListening();\n                                reject();\n                            };\n                        });\n                        promises = [\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            raceWithSignal(signal, Promise.race(promises))\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, autoJoinPromises, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        autoJoinPromises = [];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            6\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            Promise.allSettled(autoJoinPromises)\n                        ];\n                    case 5:\n                        _c.sent();\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (!isAction(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = function() {\n    return function(payload) {\n        var _c;\n        return {\n            payload: payload,\n            meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)\n        };\n    };\n};\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( false ? 0 : typeof global !== \"undefined\" ? global : globalThis) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar createQueueWithTimer = function(timeout) {\n    return function(notify) {\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = function(options) {\n    if (options === void 0) {\n        options = {\n            type: \"raf\"\n        };\n    }\n    return function(next) {\n        return function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var store = next.apply(void 0, args);\n            var notifying = true;\n            var shouldNotifyAtEndOfTick = false;\n            var notificationQueued = false;\n            var listeners = new Set();\n            var queueCallback = options.type === \"tick\" ? queueMicrotaskShim : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            var notifyListeners = function() {\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach(function(l) {\n                        return l();\n                    });\n                }\n            };\n            return Object.assign({}, store, {\n                subscribe: function(listener2) {\n                    var wrappedListener = function() {\n                        return notifying && listener2();\n                    };\n                    var unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return function() {\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                dispatch: function(action) {\n                    var _a;\n                    try {\n                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n    };\n};\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUs7SUFDeEMsSUFBSUMsZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUM5QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1lBQUVDLFdBQVcsRUFBRTtRQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1lBQUlELEVBQUVJLFNBQVMsR0FBR0g7UUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7WUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUFFO1FBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0lBQzVCO0lBQ0EsT0FBTyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJUyxVQUFVLHlCQUF5QkMsT0FBT1YsS0FBSztRQUM3REYsY0FBY0MsR0FBR0M7UUFDakIsU0FBU1c7WUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2I7UUFBRztRQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9ZLE1BQU0sQ0FBQ2IsS0FBTVcsQ0FBQUEsR0FBR0wsU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSUssSUFBRztJQUN0RjtBQUNKO0FBQ0EsSUFBSUcsY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMsT0FBTyxFQUFFQyxJQUFJ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U0FBVWtDLFNBQVM7b0JBQzFCLElBQUlDLGtCQUFrQjt3QkFBYyxPQUFPVCxhQUFhUTtvQkFBYTtvQkFDckUsSUFBSTdFLGNBQWNvRSxNQUFNekIsU0FBUyxDQUFDbUM7b0JBQ2xDTixVQUFVN2IsR0FBRyxDQUFDa2M7b0JBQ2QsT0FBTzt3QkFDSDdFO3dCQUNBd0UsVUFBVTdDLE1BQU0sQ0FBQ2tEO29CQUNyQjtnQkFDSjtnQkFDQS9LLFVBQVUsU0FBVTlWLE1BQU07b0JBQ3RCLElBQUlvVztvQkFDSixJQUFJO3dCQUNBaUssWUFBWSxDQUFFLEVBQUNqSyxLQUFLcFcsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT0gsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJdVcsRUFBRSxDQUFDa0osaUJBQWlCO3dCQUNsR2dCLDBCQUEwQixDQUFDRDt3QkFDM0IsSUFBSUMseUJBQXlCOzRCQUN6QixJQUFJLENBQUNDLG9CQUFvQjtnQ0FDckJBLHFCQUFxQjtnQ0FDckJFLGNBQWNFOzRCQUNsQjt3QkFDSjt3QkFDQSxPQUFPUCxNQUFNdEssUUFBUSxDQUFDOVY7b0JBQzFCLFNBQ1E7d0JBQ0pxZ0IsWUFBWTtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKO0lBQUc7QUFDUDtBQUNBLGVBQWU7QUFDZmxqQixnREFBU0E7QUFDKzBCLENBQ3gxQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmllbmRib29rLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcz84Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufTtcclxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcclxudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX3NwcmVhZFByb3BzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOyB9O1xyXG52YXIgX19hc3luYyA9IGZ1bmN0aW9uIChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH07XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8vIHNyYy9pbmRleC50c1xyXG5pbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgY3JlYXRlU2VsZWN0b3IyIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xyXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICB2YXIgd3JhcHBlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWVdLCByZXN0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcclxufTtcclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBhcHBseU1pZGRsZXdhcmUsIGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XHJcbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobm9vcDIpIHtcclxuICAgICAgICByZXR1cm4gbm9vcDI7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC10aHVua1wiO1xyXG4vLyBzcmMvdHNIZWxwZXJzLnRzXHJcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVwYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkXHJcbiAgICAgICAgICAgIH0sIFwibWV0YVwiIGluIHByZXBhcmVkICYmIHsgbWV0YTogcHJlcGFyZWQubWV0YSB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBhcmdzWzBdIH07XHJcbiAgICB9XHJcbiAgICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHR5cGU7IH07XHJcbiAgICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xyXG4gICAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi50eXBlID09PSB0eXBlOyB9O1xyXG4gICAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcclxuICAgIHZhciBzcGxpdFR5cGUgPSB0eXBlID8gKFwiXCIgKyB0eXBlKS5zcGxpdChcIi9cIikgOiBbXTtcclxuICAgIHZhciBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcclxuICAgIHJldHVybiBcIkRldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcXFwiXCIgKyAodHlwZSB8fCBcInVua25vd25cIikgKyBcIlxcXCIgYmVpbmcgZGlzcGF0Y2hlZC4gXFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gYGRpc3BhdGNoKFwiICsgYWN0aW9uTmFtZSArIFwiKCkpYCBpbnN0ZWFkIG9mIGBkaXNwYXRjaChcIiArIGFjdGlvbk5hbWUgKyBcIilgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuXCI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIG5leHQoYWN0aW9uKTsgfTsgfTsgfTtcclxuICAgIH1cclxuICAgIHZhciBfYyA9IG9wdGlvbnMuaXNBY3Rpb25DcmVhdG9yLCBpc0FjdGlvbkNyZWF0b3IyID0gX2MgPT09IHZvaWQgMCA/IGlzQWN0aW9uQ3JlYXRvciA6IF9jO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgfTsgfTsgfTtcclxufVxyXG4vLyBzcmMvdXRpbHMudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcclxuICAgIHZhciBlbGFwc2VkID0gMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVhc3VyZVRpbWU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybklmRXhjZWVkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGZuTmFtZSArIFwiIHRvb2sgXCIgKyBlbGFwc2VkICsgXCJtcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiBcIiArIG1heERlbGF5ICsgXCJtcy4gXFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxudmFyIE1pZGRsZXdhcmVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaWRkbGV3YXJlQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaWRkbGV3YXJlQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pZGRsZXdhcmVBcnJheSwgU3ltYm9sLnNwZWNpZXMsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoTWlkZGxld2FyZUFycmF5LmJpbmQuYXBwbHkoTWlkZGxld2FyZUFycmF5LCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcnIuY29uY2F0KHRoaXMpKSkpKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxufShBcnJheSkpO1xyXG52YXIgRW5oYW5jZXJBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbmhhbmNlckFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW5oYW5jZXJBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFbmhhbmNlckFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuaGFuY2VyQXJyYXksIFN5bWJvbC5zcGVjaWVzLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmhhbmNlckFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5oYW5jZXJBcnJheTtcclxufShBcnJheSkpO1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pIDogdmFsO1xyXG59XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xyXG4gICAgdmFyIHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGV0ZWN0TXV0YXRpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaiwgcGF0aCwgY2hlY2tlZE9iamVjdHMpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChjaGVja2VkT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGNoZWNrZWRPYmplY3RzID0gbmV3IFNldCgpOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xyXG4gICAgICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xyXG4gICAgICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFja2VkO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAoc2FtZVBhcmVudFJlZiA9PT0gdm9pZCAwKSB7IHNhbWVQYXJlbnRSZWYgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgICB2YXIgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICAgIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xyXG4gICAgICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGg6IHBhdGggfTtcclxuICAgIH1cclxuICAgIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzVG9EZXRlY3QgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgICAgICAgdmFyIGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGtleXNUb0RldGVjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShrZXkpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc0ltbXV0YWJsZSwgaXNJbW11dGFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNJbW11dGFibGVEZWZhdWx0IDogX2MsIGlnbm9yZWRQYXRocyA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBfZCA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZCA9PT0gdm9pZCAwID8gMzIgOiBfZCwgaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XHJcbiAgICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlO1xyXG4gICAgdmFyIHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYy5nZXRTdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIicuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJiBpbnZhcmlhbnQoIXJlc3VsdC53YXNNdXRhdGVkLCBcIkEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIi4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiBcIiArIHN0cmluZ2lmeShhY3Rpb24pICsgXCIuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcclxuICAgICAgICB9OyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSkge1xyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgaWYgKGlzU2VyaWFsaXphYmxlID09PSB2b2lkIDApIHsgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluOyB9XHJcbiAgICBpZiAoaWdub3JlZFBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlZFBhdGhzID0gW107IH1cclxuICAgIHZhciBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcclxuICAgIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuaGFzKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoa2V5LCBuZXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgICAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoa2V5LCBuZXN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8yID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMi52YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXHJcbiAgICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgbmVzdGVkVmFsdWUgPSBfY1tfaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc1NlcmlhbGl6YWJsZSwgaXNTZXJpYWxpemFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNQbGFpbiA6IF9jLCBnZXRFbnRyaWVzID0gb3B0aW9ucy5nZXRFbnRyaWVzLCBfZCA9IG9wdGlvbnMuaWdub3JlZEFjdGlvbnMsIGlnbm9yZWRBY3Rpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9uUGF0aHMsIGlnbm9yZWRBY3Rpb25QYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSA6IF9lLCBfZiA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBpZ25vcmVkUGF0aHMgPSBfZiA9PT0gdm9pZCAwID8gW10gOiBfZiwgX2cgPSBvcHRpb25zLndhcm5BZnRlciwgd2FybkFmdGVyID0gX2cgPT09IHZvaWQgMCA/IDMyIDogX2csIF9oID0gb3B0aW9ucy5pZ25vcmVTdGF0ZSwgaWdub3JlU3RhdGUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBvcHRpb25zLmlnbm9yZUFjdGlvbnMsIGlnbm9yZUFjdGlvbnMgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmRpc2FibGVDYWNoZSwgZGlzYWJsZUNhY2hlID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2s7XHJcbiAgICB2YXIgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSwgX2YgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3JDaGVjaywgYWN0aW9uQ3JlYXRvckNoZWNrID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZjtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9jID0gb3B0aW9ucyB8fCB7fSwgX2QgPSBfYy5yZWR1Y2VyLCByZWR1Y2VyID0gX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLCBfZSA9IF9jLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZSA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZSwgX2YgPSBfYy5kZXZUb29scywgZGV2VG9vbHMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9jLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZywgX2ggPSBfYy5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaDtcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdEVuaGFuY2VycyA9IG5ldyBFbmhhbmNlckFycmF5KG1pZGRsZXdhcmVFbmhhbmNlcik7XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBkZWZhdWx0RW5oYW5jZXJzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gX19zcHJlYWRBcnJheShbbWlkZGxld2FyZUVuaGFuY2VyXSwgZW5oYW5jZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gZW5oYW5jZXJzKGRlZmF1bHRFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoZXI6IGZ1bmN0aW9uIChtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyOiBtYXRjaGVyLCByZWR1Y2VyOiByZWR1Y2VyIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlZmF1bHRDYXNlOiBmdW5jdGlvbiAocmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XHJcbiAgICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgIGlmIChhY3Rpb25NYXRjaGVycyA9PT0gdm9pZCAwKSB7IGFjdGlvbk1hdGNoZXJzID0gW107IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSVEsgMi4wLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlUmVkdWNlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfYyA9IHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spIDogW21hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXSwgYWN0aW9uc01hcCA9IF9jWzBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzID0gX2NbMV0sIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyID0gX2NbMl07XHJcbiAgICB2YXIgZ2V0SW5pdGlhbFN0YXRlO1xyXG4gICAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb3plbkluaXRpYWxTdGF0ZV8xOyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTsgfVxyXG4gICAgICAgIHZhciBjYXNlUmVkdWNlcnMgPSBfX3NwcmVhZEFycmF5KFtcclxuICAgICAgICAgICAgYWN0aW9uc01hcFthY3Rpb24udHlwZV1cclxuICAgICAgICBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXIgPSBfYy5tYXRjaGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIHJlZHVjZXIyID0gX2MucmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZXIyO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcihmdW5jdGlvbiAoY3IpIHsgcmV0dXJuICEhY3I7IH0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFmdDIocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIgPSBmYWxzZTtcclxuZnVuY3Rpb24gZ2V0VHlwZTIoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gICAgcmV0dXJuIHNsaWNlICsgXCIvXCIgKyBhY3Rpb25LZXk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpY2Uob3B0aW9ucykge1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxTdGF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxTdGF0ZSA6IGZyZWV6ZURyYWZ0YWJsZShvcHRpb25zLmluaXRpYWxTdGF0ZSk7XHJcbiAgICB2YXIgcmVkdWNlcnMgPSBvcHRpb25zLnJlZHVjZXJzIHx8IHt9O1xyXG4gICAgdmFyIHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgdmFyIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlID0ge307XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VyTmFtZSkge1xyXG4gICAgICAgIHZhciBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUyKG5hbWUsIHJlZHVjZXJOYW1lKTtcclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgdmFyIHByZXBhcmVDYWxsYmFjaztcclxuICAgICAgICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbcmVkdWNlck5hbWVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlcjtcclxuICAgICAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dE9iamVjdE5vdGF0aW9uMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUlRLIDIuMC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYyA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXSwgX2QgPSBfY1swXSwgZXh0cmFSZWR1Y2VycyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBfZSA9IF9jWzFdLCBhY3Rpb25NYXRjaGVycyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IF9jWzJdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Y7XHJcbiAgICAgICAgdmFyIGZpbmFsQ2FzZVJlZHVjZXJzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGV4dHJhUmVkdWNlcnMpLCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYWN0aW9uTWF0Y2hlcnNfMSA9IGFjdGlvbk1hdGNoZXJzOyBfaSA8IGFjdGlvbk1hdGNoZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGFjdGlvbk1hdGNoZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBfcmVkdWNlcjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICByZWR1Y2VyOiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uczogYWN0aW9uQ3JlYXRvcnMsXHJcbiAgICAgICAgY2FzZVJlZHVjZXJzOiBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVkdWNlcilcclxuICAgICAgICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHNcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZSkge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsU3RhdGUgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsU3RhdGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0SWRzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5pZHM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEVudGl0aWVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5lbnRpdGllczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgZnVuY3Rpb24gKGlkcywgZW50aXRpZXMpIHsgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH0pOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0SWQgPSBmdW5jdGlvbiAoXywgaWQpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RCeUlkID0gZnVuY3Rpb24gKGVudGl0aWVzLCBpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgZnVuY3Rpb24gKGlkcykgeyByZXR1cm4gaWRzLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0SWRzOiBzZWxlY3RJZHMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBzZWxlY3RUb3RhbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0SWRzOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgICAgICAgc2VsZWN0QWxsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldFNlbGVjdG9yczogZ2V0U2VsZWN0b3JzIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZTMsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgdmFyIG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcihmdW5jdGlvbiAoXywgc3RhdGUpIHsgcmV0dXJuIG11dGF0b3Ioc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydW5NdXRhdG9yID0gZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNEcmFmdDMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcclxuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XHJcbiAgICB2YXIga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0aWVzO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHZhciBhZGRlZCA9IFtdO1xyXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMSA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzFbX2ldO1xyXG4gICAgICAgIHZhciBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkOiBpZCwgY2hhbmdlczogZW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzIgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMltfaV07XHJcbiAgICAgICAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzMgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfM1tfaV07XHJcbiAgICAgICAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzID0ge307XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gc3RhdGUuZW50aXRpZXM7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgICAgICAgIGlkczogW10sXHJcbiAgICAgICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsMiA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDIsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICB2YXIgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xyXG4gICAgICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAgICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc05ld0tleTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9O1xyXG4gICAgICAgIHZhciB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCksIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSk7IH0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC5rZXlzKHN0YXRlLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB1cGRhdGVzXzEgPSB1cGRhdGVzOyBfaSA8IHVwZGF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYyA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2NbMF0sIHVwZGF0ZWQgPSBfY1sxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcclxuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgZnVuY3Rpb24gKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGFib3J0ZWQ6IChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubmFtZSkgPT09IFwiQWJvcnRFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgQUMgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSBcInVuZGVmaW5lZFwiID8gQWJvcnRDb250cm9sbGVyIDogLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbmFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQWJvcnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRHZW5lcmF0b3IpID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRSZWFzb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBhYm9ydGVkUHJvbWlzZSwgZXJyXzEsIHNraXBEaXNwYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFswLCA0LCAsIDVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kaXRpb25SZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0UGVuZGluZ01ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGFyZzogYXJnIH0sIHsgZ2V0U3RhdGU6IGdldFN0YXRlLCBleHRyYTogZXh0cmEgfSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVycl8xIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVycl8xLnBheWxvYWQsIGVycl8xLm1ldGEpIDogcmVqZWN0ZWQoZXJyXzEsIHJlcXVlc3RJZCwgYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmluYWxBY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTIudGhlbih1bndyYXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XHJcbiAgICAgICAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICAgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXHJcbiAgICAgICAgICAgIHR5cGVQcmVmaXg6IHR5cGVQcmVmaXhcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyOyB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy9tYXRjaGVycy50c1xyXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChtYXRjaGVyLCBhY3Rpb24pIHtcclxuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGlzQW55T2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsT2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XHJcbiAgICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGVuZGluZygpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucGVuZGluZzsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnJlamVjdGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5mdWxmaWxsZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhc3luY1RodW5rc18xID0gYXN5bmNUaHVua3M7IF9pIDwgYXN5bmNUaHVua3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGh1bmsgPSBhc3luY1RodW5rc18xW19pXTtcclxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXHJcbnZhciBhc3NlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGV4cGVjdGVkICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG52YXIgY2F0Y2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZTIsIG9uRXJyb3IpIHtcclxuICAgIGlmIChvbkVycm9yID09PSB2b2lkIDApIHsgb25FcnJvciA9IG5vb3A7IH1cclxuICAgIHByb21pc2UyLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2UyO1xyXG59O1xyXG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYm9ydFNpZ25hbCwgY2FsbGJhY2spIHtcclxuICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7IH07XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZTIpIHtcclxuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZTIuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFudXAgPSBub29wO1xyXG4gICAgfSk7XHJcbn1cclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZTIpIHtcclxuICAgICAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlMikudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKHNpZ25hbCkge1xyXG4gICAgdmFyIHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZW91dE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcyk7IH0pKTtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gZnVuY3Rpb24gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSB7XHJcbiAgICB2YXIgbGlua0NvbnRyb2xsZXJzID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHsgcmV0dXJuIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKTsgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhc2tFeGVjdXRvciwgb3B0cykge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICAgICAgdmFyIGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1blRhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCk7IH0pO1xyXG4gICAgICAgIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmF1dG9Kb2luKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IGZ1bmN0aW9uIChzdGFydExpc3RlbmluZywgc2lnbmFsKSB7XHJcbiAgICB2YXIgdGFrZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlLCB0dXBsZVByb21pc2UsIHByb21pc2VzLCBvdXRwdXQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogZnVuY3Rpb24gKGFjdGlvbiwgbGlzdGVuZXJBcGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCk7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG91dHB1dF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7IH07XHJcbn07XHJcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlLCBhY3Rpb25DcmVhdG9yID0gb3B0aW9ucy5hY3Rpb25DcmVhdG9yLCBtYXRjaGVyID0gb3B0aW9ucy5tYXRjaGVyLCBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZSwgZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3Q7XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcclxuICAgICAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZSkge1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XHJcbiAgICByZXR1cm4geyBwcmVkaWNhdGU6IHByZWRpY2F0ZSwgdHlwZTogdHlwZSwgZWZmZWN0OiBlZmZlY3QgfTtcclxufTtcclxudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZSwgZWZmZWN0ID0gX2MuZWZmZWN0O1xyXG4gICAgdmFyIGlkID0gbmFub2lkKCk7XHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGVmZmVjdDogZWZmZWN0LFxyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXHJcbiAgICAgICAgcGVuZGluZzogbmV3IFNldCgpLFxyXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59O1xyXG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBmdW5jdGlvbiAobGlzdGVuZXJNYXApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBhZGRMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9hZGRcIik7XHJcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVBbGxcIik7XHJcbnZhciByZW1vdmVMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVcIik7XHJcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfX3NwcmVhZEFycmF5KFthbG0gKyBcIi9lcnJvclwiXSwgYXJncykpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBpZiAobWlkZGxld2FyZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlT3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgbGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgZXh0cmEgPSBtaWRkbGV3YXJlT3B0aW9ucy5leHRyYSwgX2MgPSBtaWRkbGV3YXJlT3B0aW9ucy5vbkVycm9yLCBvbkVycm9yID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBfYztcclxuICAgIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcclxuICAgIHZhciBpbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTsgfTtcclxuICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbmNlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbE9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZmluZExpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAoY29tcGFyYXRvcikge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuICAgIHZhciBzdGFydExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkoZnVuY3Rpb24gKGV4aXN0aW5nRW50cnkpIHsgcmV0dXJuIGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdDsgfSk7XHJcbiAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYyA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyksIHR5cGUgPSBfYy50eXBlLCBlZmZlY3QgPSBfYy5lZmZlY3QsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZTtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZW50cnkyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISFlbnRyeTtcclxuICAgIH07XHJcbiAgICB2YXIgbm90aWZ5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSB7IHJldHVybiBfX2FzeW5jKF90aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGludGVybmFsVGFza0NvbnRyb2xsZXIsIHRha2UsIGF1dG9Kb2luUHJvbWlzZXMsIGxpc3RlbmVyRXJyb3JfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAzLCA0LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sIGFzc2lnbih7fSwgYXBpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlOiBnZXRPcmlnaW5hbFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlciwgXywgc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyRXJyb3JfMSA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShsaXN0ZW5lckVycm9yXzEgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvcl8xLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsU2V0dGxlZChhdXRvSm9pblByb21pc2VzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBnZXRPcmlnaW5hbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWxtICsgXCI6IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyRW50cmllc18xID0gbGlzdGVuZXJFbnRyaWVzOyBfaSA8IGxpc3RlbmVyRW50cmllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3RlbmVyRW50cmllc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLFxyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBzdGFydExpc3RlbmluZyxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBzdG9wTGlzdGVuaW5nLFxyXG4gICAgICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcclxudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcclxudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICB2YXIgX2M7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IChfYyA9IHt9LCBfY1tTSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9jKVxyXG4gICAgfSk7XHJcbn07IH07XHJcbnZhciBwcm9taXNlO1xyXG52YXIgcXVldWVNaWNyb3Rhc2tTaGltID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZ2xvYmFsVGhpcykgOiBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IGVycjtcclxufSwgMCk7IH0pOyB9O1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3RpZnkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgdHlwZTogXCJyYWZcIiB9OyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3JlID0gbmV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrU2hpbSA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9OyB9O1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuZW5hYmxlRVM1KCk7XHJcbmV4cG9ydCB7IEVuaGFuY2VyQXJyYXksIE1pZGRsZXdhcmVBcnJheSwgU0hPVUxEX0FVVE9CQVRDSCwgVGFza0Fib3J0RXJyb3IsIGFkZExpc3RlbmVyLCBhdXRvQmF0Y2hFbmhhbmNlciwgY2xlYXJBbGxMaXN0ZW5lcnMsIGNvbmZpZ3VyZVN0b3JlLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWN0aW9uLCBpc0FjdGlvbkNyZWF0b3IsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCBwcmVwYXJlQXV0b0JhdGNoZWQsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiaGFzTWF0Y2hGdW5jdGlvbiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInBheWxvYWQiLCJtZXRhIiwiZXJyb3IiLCJ0b1N0cmluZyIsImFjdGlvbiIsImlzQWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiaW5kZXhPZiIsImdldFR5cGUiLCJnZXRNZXNzYWdlIiwic3BsaXRUeXBlIiwic3BsaXQiLCJhY3Rpb25OYW1lIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwicHJvY2VzcyIsImlzQWN0aW9uQ3JlYXRvcjIiLCJjb25zb2xlIiwid2FybiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRHJhZnRhYmxlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJNaWRkbGV3YXJlQXJyYXkiLCJfc3VwZXIiLCJfdGhpcyIsInNwZWNpZXMiLCJnZXQiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImJpbmQiLCJFbmhhbmNlckFycmF5IiwiZnJlZXplRHJhZnRhYmxlIiwidmFsIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsInN0cmluZ2lmeSIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJnZXRTZXJpYWxpemUiLCJzdGFjayIsInNsaWNlIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwiY2hlY2tlZE9iamVjdHMiLCJTZXQiLCJ0cmFja2VkIiwiaGFzIiwiYWRkIiwiY2hpbGRyZW4iLCJjaGlsZFBhdGgiLCJpZ25vcmVkUGF0aHMiLCJ0cmFja2VkUHJvcGVydHkiLCJzYW1lUGFyZW50UmVmIiwicHJldk9iaiIsInNhbWVSZWYiLCJOdW1iZXIiLCJpc05hTiIsIndhc011dGF0ZWQiLCJrZXlzVG9EZXRlY3QiLCJoYXNJZ25vcmVkUGF0aHMiLCJfbG9vcF8xIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdGF0ZV8xIiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiX2QiLCJ3YXJuQWZ0ZXIiLCJpZ25vcmUiLCJ0cmFjayIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJfbG9vcF8yIiwibmVzdGVkVmFsdWUiLCJlbnRyaWVzXzEiLCJzdGF0ZV8yIiwiaXNOZXN0ZWRGcm96ZW4iLCJ2YWx1ZXMiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJfayIsImRpc2FibGVDYWNoZSIsIldlYWtTZXQiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc0Jvb2xlYW4iLCJjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlIiwiY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJ0aHVuayIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImV4dHJhQXJndW1lbnQiLCJpbW11dGFibGVPcHRpb25zIiwidW5zaGlmdCIsInNlcmlhbGl6YWJsZU9wdGlvbnMiLCJhY3Rpb25DcmVhdG9yT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiZGVmYXVsdEVuaGFuY2VycyIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGVfMSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yIiwiZ2V0VHlwZTIiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsImZvckVhY2giLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsImFjdGlvbk1hdGNoZXJzXzEiLCJtIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwidXBkYXRlc18xIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsImNvbW1vblByb3BlcnRpZXNfMSIsInByb3BlcnR5IiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwicmVxdWVzdElkIiwicmVxdWVzdFN0YXR1cyIsInBlbmRpbmciLCJzZXJpYWxpemVFcnJvciIsInJlamVjdGVkV2l0aFZhbHVlIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImNsYXNzXzEiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhc29uIiwidGhyb3dJZkFib3J0ZWQiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsInByb21pc2UyIiwiX2EiLCJfYiIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiYWJvcnRlZFByb21pc2UiLCJlcnJfMSIsInNraXBEaXNwYXRjaCIsImlzVGhlbmFibGUiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJ3aXRoVHlwZXMiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiaXNQZW5kaW5nIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJoYXNGbGFnIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJhc3luY1RodW5rc18xIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsImVycm9yXzEiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJzZXRUaW1lb3V0IiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJlbnRyeSIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwibGlzdGVuZXJNYXAiLCJjbGVhciIsInNhZmVseU5vdGlmeUVycm9yIiwiZXJyb3JIYW5kbGVyIiwiZXJyb3JUb05vdGlmeSIsImVycm9ySW5mbyIsImVycm9ySGFuZGxlckVycm9yIiwiYWRkTGlzdGVuZXIiLCJjbGVhckFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsImNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVPcHRpb25zIiwiTWFwIiwiaW5zZXJ0RW50cnkiLCJkZWxldGUiLCJzZXQiLCJjYW5jZWxPcHRpb25zIiwiY2FuY2VsQWN0aXZlIiwiZmluZExpc3RlbmVyRW50cnkiLCJjb21wYXJhdG9yIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwiYXV0b0pvaW5Qcm9taXNlcyIsImxpc3RlbmVyRXJyb3JfMSIsIkJvb2xlYW4iLCJmb3JrIiwic3Vic2NyaWJlIiwicmFpc2VkQnkiLCJhbGxTZXR0bGVkIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwibGlzdGVuZXJFbnRyaWVzXzEiLCJydW5MaXN0ZW5lciIsInByZWRpY2F0ZUVycm9yIiwiY2xlYXJMaXN0ZW5lcnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicHJvbWlzZSIsInF1ZXVlTWljcm90YXNrU2hpbSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiZXJyIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJub3RpZnkiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVOb3RpZmljYXRpb24iLCJub3RpZnlMaXN0ZW5lcnMiLCJsIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n");

/***/ })

};
;