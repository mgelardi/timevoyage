"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer";
exports.ids = ["vendor-chunks/immer"];
exports.modules = {

/***/ "(ssr)/./node_modules/immer/dist/immer.cjs.development.js":
/*!**********************************************************!*\
  !*** ./node_modules/immer/dist/immer.cjs.development.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _ref;\n// Should be no imports here!\n// Some things that should be evaluated before all else...\n// We only want to know if non-polyfilled symbols are available\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof /*#__PURE__*/ Symbol(\"x\") === \"symbol\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */ var NOTHING = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */ var DRAFTABLE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\nvar errors = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function _(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function _(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function _(op) {\n        return \"Unsupported patch operation: \" + op;\n    },\n    18: function _(plugin) {\n        return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function _(thing) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\n    },\n    22: function _(thing) {\n        return \"'current' expects a draft, got: \" + thing;\n    },\n    23: function _(thing) {\n        return \"'original' expects a draft, got: \" + thing;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n};\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    {\n        var e = errors[error];\n        var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\n        throw new Error(\"[Immer] \" + msg);\n    }\n}\n/** Returns true if the given value is an Immer draft */ /*#__PURE__*/ function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */ /*#__PURE__*/ function isDraftable(value) {\n    var _value$constructor;\n    if (!value) return false;\n    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString = /*#__PURE__*/ Object.prototype.constructor.toString();\n/*#__PURE__*/ function isPlainObject(value) {\n    if (!value || typeof value !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    if (Ctor === Object) return true;\n    return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(23, value);\n    return value[DRAFT_STATE].base_;\n}\n/*#__PURE__*/ var ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function(obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    ownKeys(target).forEach(function(key) {\n        res[key] = Object.getOwnPropertyDescriptor(target, key);\n    });\n    return res;\n};\nfunction each(obj, iter, enumerableOnly) {\n    if (enumerableOnly === void 0) {\n        enumerableOnly = false;\n    }\n    if (getArchtype(obj) === 0) {\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {\n            if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach(function(entry, index) {\n            return iter(index, entry, obj);\n        });\n    }\n}\n/*#__PURE__*/ function getArchtype(thing) {\n    /* istanbul ignore next */ var state = thing[DRAFT_STATE];\n    return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\n     : state.type_ // others are the same\n     : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0 /* Object */ ;\n}\n/*#__PURE__*/ function has(thing, prop) {\n    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n/*#__PURE__*/ function get(thing, prop) {\n    // @ts-ignore\n    return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];\n}\n/*#__PURE__*/ function set(thing, propOrOldValue, value) {\n    var t = getArchtype(thing);\n    if (t === 2) thing.set(propOrOldValue, value);\n    else if (t === 3) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n/*#__PURE__*/ function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\n/*#__PURE__*/ function isMap(target) {\n    return hasMap && target instanceof Map;\n}\n/*#__PURE__*/ function isSet(target) {\n    return hasSet && target instanceof Set;\n}\n/*#__PURE__*/ function latest(state) {\n    return state.copy_ || state.base_;\n}\n/*#__PURE__*/ function shallowCopy(base) {\n    if (Array.isArray(base)) return Array.prototype.slice.call(base);\n    var descriptors = getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    var keys = ownKeys(descriptors);\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        var desc = descriptors[key];\n        if (desc.writable === false) {\n            desc.writable = true;\n            desc.configurable = true;\n        } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n        // with libraries that trap values, like mobx or vue\n        // unlike object.assign, non-enumerables will be copied as well\n        if (desc.get || desc.set) descriptors[key] = {\n            configurable: true,\n            writable: true,\n            enumerable: desc.enumerable,\n            value: base[key]\n        };\n    }\n    return Object.create(Object.getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n    Object.freeze(obj);\n    if (deep) each(obj, function(key, value) {\n        return freeze(value, true);\n    }, true);\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nfunction isFrozen(obj) {\n    if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\n    return Object.isFrozen(obj);\n}\n/** Plugin utilities */ var plugins = {};\nfunction getPlugin(pluginKey) {\n    var plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(18, pluginKey);\n    } // @ts-ignore\n    return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\nvar currentScope;\nfunction getCurrentScope() {\n    if (!currentScope) die(0);\n    return currentScope;\n}\nfunction createScope(parent_, immer_) {\n    return {\n        drafts_: [],\n        parent_: parent_,\n        immer_: immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0\n    };\n}\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        getPlugin(\"Patches\"); // assert we have the plugin\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft); // @ts-ignore\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nfunction enterScope(immer) {\n    return currentScope = createScope(currentScope, immer);\n}\nfunction revokeDraft(draft) {\n    var state = draft[DRAFT_STATE];\n    if (state.type_ === 0 || state.type_ === 1) state.revoke_();\n    else state.revoked_ = true;\n}\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    var baseDraft = scope.drafts_[0];\n    var isReplaced = result !== undefined && result !== baseDraft;\n    if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            // Finalize the result in case it contains (or is) a subset of the draft.\n            result = finalize(scope, result);\n            if (!scope.parent_) maybeFreeze(scope, result);\n        }\n        if (scope.patches_) {\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n        }\n    } else {\n        // Finalize the base draft.\n        result = finalize(scope, baseDraft, []);\n    }\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : undefined;\n}\nfunction finalize(rootScope, value, path) {\n    // Don't recurse in tho recursive data structures\n    if (isFrozen(value)) return value;\n    var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\n    if (!state) {\n        each(value, function(key, childValue) {\n            return finalizeProperty(rootScope, state, value, key, childValue, path);\n        }, true // See #590, don't recurse into non-enumerable of non drafted objects\n        );\n        return value;\n    } // Never finalize drafts owned by another scope.\n    if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\n    if (!state.modified_) {\n        maybeFreeze(rootScope, state.base_, true);\n        return state.base_;\n    } // Not finalized yet, let's do that now\n    if (!state.finalized_) {\n        state.finalized_ = true;\n        state.scope_.unfinalizedDrafts_--;\n        var result = state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n        // To preserve insertion order in all cases we then clear the set\n        // And we let finalizeProperty know it needs to re-add non-draft children back to the target\n        var resultEach = result;\n        var isSet = false;\n        if (state.type_ === 3) {\n            resultEach = new Set(result);\n            result.clear();\n            isSet = true;\n        }\n        each(resultEach, function(key, childValue) {\n            return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);\n        }); // everything inside is frozen, we can freeze here\n        maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\n        if (path && rootScope.patches_) {\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n        }\n    }\n    return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n    if (childValue === targetObject) die(5);\n    if (isDraft(childValue)) {\n        var path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.\n        !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\n         ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n        var res = finalize(rootScope, childValue, path);\n        set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n        if (isDraft(res)) {\n            rootScope.canAutoFreeze_ = false;\n        } else return;\n    } else if (targetIsSet) {\n        targetObject.add(childValue);\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n            // optimization: if an object is not a draft, and we don't have to\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n            // This benefits especially adding large data tree's without further processing.\n            // See add-data.js perf test\n            return;\n        }\n        finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\n        if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n    }\n}\nfunction maybeFreeze(scope, value, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */ function createProxyProxy(base, parent) {\n    var isArray = Array.isArray(base);\n    var state = {\n        type_: isArray ? 1 : 0,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned_: {},\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false\n    }; // the traps must target something, a bit like the 'real' base.\n    // but also, we need to be able to determine from the target what the relevant state is\n    // (to avoid creating traps per instance to capture the state in closure,\n    // and to avoid creating weird hidden properties as well)\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n    var target = state;\n    var traps = objectTraps;\n    if (isArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return proxy;\n}\n/**\r\n * Object drafts\r\n */ var objectTraps = {\n    get: function get(state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        var source = latest(state);\n        if (!has(source, prop)) {\n            // non-existing or non-own property...\n            return readPropFromProto(state, source, prop);\n        }\n        var value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        } // Check for existing draft in modified state.\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\n        }\n        return value;\n    },\n    has: function has(state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys: function ownKeys(state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set: function set(state, prop, value) {\n        var desc = getDescriptorFromProto(latest(state), prop);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // special case: if this write is captured by a setter, we have\n            // to trigger it with the correct context\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n            // from setting an existing property with value undefined to undefined (which is not a change)\n            var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\n            var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_[prop] = false;\n                return true;\n            }\n            if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && (value !== undefined || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore\n        state.copy_[prop] = value;\n        state.assigned_[prop] = true;\n        return true;\n    },\n    deleteProperty: function deleteProperty(state, prop) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\n            state.assigned_[prop] = false;\n            prepareCopy(state);\n            markChanged(state);\n        } else {\n            // if an originally not assigned property was deleted\n            delete state.assigned_[prop];\n        } // @ts-ignore\n        if (state.copy_) delete state.copy_[prop];\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n        var owner = latest(state);\n        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            writable: true,\n            configurable: state.type_ !== 1 || prop !== \"length\",\n            enumerable: desc.enumerable,\n            value: owner[prop]\n        };\n    },\n    defineProperty: function defineProperty() {\n        die(11);\n    },\n    getPrototypeOf: function getPrototypeOf(state) {\n        return Object.getPrototypeOf(state.base_);\n    },\n    setPrototypeOf: function setPrototypeOf() {\n        die(12);\n    }\n};\n/**\r\n * Array drafts\r\n */ var arrayTraps = {};\neach(objectTraps, function(key, fn) {\n    // @ts-ignore\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) die(13); // @ts-ignore\n    return arrayTraps.set.call(this, state, prop, undefined);\n};\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Access a property without creating an Immer draft.\nfunction peek(draft, prop) {\n    var state = draft[DRAFT_STATE];\n    var source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    var _desc$get;\n    var desc = getDescriptorFromProto(source, prop);\n    return desc ? \"value\" in desc ? desc.value : // prototype, we should invoke it with the draft as context!\n    (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\n}\nfunction getDescriptorFromProto(source, prop) {\n    // 'in' checks proto!\n    if (!(prop in source)) return undefined;\n    var proto = Object.getPrototypeOf(source);\n    while(proto){\n        var desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = Object.getPrototypeOf(proto);\n    }\n    return undefined;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.copy_ = shallowCopy(state.base_);\n    }\n}\nvar Immer = /*#__PURE__*/ function() {\n    function Immer(config) {\n        var _this = this;\n        this.useProxies_ = hasProxies;\n        this.autoFreeze_ = true;\n        /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */ this.produce = function(base, recipe, patchListener) {\n            // curried invocation\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                var defaultBase = recipe;\n                recipe = base;\n                var self = _this;\n                return function curriedProduce(base) {\n                    var _this2 = this;\n                    if (base === void 0) {\n                        base = defaultBase;\n                    }\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return self.produce(base, function(draft) {\n                        var _recipe;\n                        return (_recipe = recipe).call.apply(_recipe, [\n                            _this2,\n                            draft\n                        ].concat(args));\n                    }); // prettier-ignore\n                };\n            }\n            if (typeof recipe !== \"function\") die(6);\n            if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\n            var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n            if (isDraftable(base)) {\n                var scope = enterScope(_this);\n                var proxy = createProxy(_this, base, undefined);\n                var hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    // finally instead of catch + rethrow better preserves original stack\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                    return result.then(function(result) {\n                        usePatchesInScope(scope, patchListener);\n                        return processResult(result, scope);\n                    }, function(error) {\n                        revokeScope(scope);\n                        throw error;\n                    });\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || typeof base !== \"object\") {\n                result = recipe(base);\n                if (result === undefined) result = base;\n                if (result === NOTHING) result = undefined;\n                if (_this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    var p = [];\n                    var ip = [];\n                    getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(21, base);\n        };\n        this.produceWithPatches = function(base, recipe) {\n            // curried invocation\n            if (typeof base === \"function\") {\n                return function(state) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    return _this.produceWithPatches(state, function(draft) {\n                        return base.apply(void 0, [\n                            draft\n                        ].concat(args));\n                    });\n                };\n            }\n            var patches, inversePatches;\n            var result = _this.produce(base, recipe, function(p, ip) {\n                patches = p;\n                inversePatches = ip;\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then(function(nextState) {\n                    return [\n                        nextState,\n                        patches,\n                        inversePatches\n                    ];\n                });\n            }\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\n        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    }\n    var _proto = Immer.prototype;\n    _proto.createDraft = function createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        var scope = enterScope(this);\n        var proxy = createProxy(this, base, undefined);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    };\n    _proto.finishDraft = function finishDraft(draft, patchListener) {\n        var state = draft && draft[DRAFT_STATE];\n        {\n            if (!state || !state.isManual_) die(9);\n            if (state.finalized_) die(10);\n        }\n        var scope = state.scope_;\n        usePatchesInScope(scope, patchListener);\n        return processResult(undefined, scope);\n    } /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */ ;\n    _proto.setAutoFreeze = function setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    } /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */ ;\n    _proto.setUseProxies = function setUseProxies(value) {\n        if (value && !hasProxies) {\n            die(20);\n        }\n        this.useProxies_ = value;\n    };\n    _proto.applyPatches = function applyPatches(base, patches) {\n        // If a patch replaces the entire state, take that replacement as base\n        // before applying patches\n        var i;\n        for(i = patches.length - 1; i >= 0; i--){\n            var patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        } // If there was a patch that replaced the entire state, start from the\n        // patch after that.\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n        if (isDraft(base)) {\n            // N.B: never hits if some patch a replacement, patches are never drafts\n            return applyPatchesImpl(base, patches);\n        } // Otherwise, produce a copy of the base state.\n        return this.produce(base, function(draft) {\n            return applyPatchesImpl(draft, patches);\n        });\n    };\n    return Immer;\n}();\nfunction createProxy(immer, value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\n    var scope = parent ? parent.scope_ : getCurrentScope();\n    scope.drafts_.push(draft);\n    return draft;\n}\nfunction current(value) {\n    if (!isDraft(value)) die(22, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value)) return value;\n    var state = value[DRAFT_STATE];\n    var copy;\n    var archType = getArchtype(value);\n    if (state) {\n        if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\n        state.finalized_ = true;\n        copy = copyHelper(value, archType);\n        state.finalized_ = false;\n    } else {\n        copy = copyHelper(value, archType);\n    }\n    each(copy, function(key, childValue) {\n        if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\n        set(copy, key, currentImpl(childValue));\n    }); // In the future, we might consider freezing here, based on the current settings\n    return archType === 3 ? new Set(copy) : copy;\n}\nfunction copyHelper(value, archType) {\n    // creates a shallow copy, even if it is a map or set\n    switch(archType){\n        case 2:\n            return new Map(value);\n        case 3:\n            // Set will be cloned as array temporarily, so that we can replace individual items\n            return Array.from(value);\n    }\n    return shallowCopy(value);\n}\nfunction enableES5() {\n    function willFinalizeES5_(scope, result, isReplaced) {\n        if (!isReplaced) {\n            if (scope.patches_) {\n                markChangesRecursively(scope.drafts_[0]);\n            } // This is faster when we don't care about which attributes changed.\n            markChangesSweep(scope.drafts_);\n        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\n            markChangesSweep(scope.drafts_);\n        }\n    }\n    function createES5Draft(isArray, base) {\n        if (isArray) {\n            var draft = new Array(base.length);\n            for(var i = 0; i < base.length; i++){\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\n            }\n            return draft;\n        } else {\n            var _descriptors = getOwnPropertyDescriptors(base);\n            delete _descriptors[DRAFT_STATE];\n            var keys = ownKeys(_descriptors);\n            for(var _i = 0; _i < keys.length; _i++){\n                var key = keys[_i];\n                _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\n            }\n            return Object.create(Object.getPrototypeOf(base), _descriptors);\n        }\n    }\n    function createES5Proxy_(base, parent) {\n        var isArray = Array.isArray(base);\n        var draft = createES5Draft(isArray, base);\n        var state = {\n            type_: isArray ? 5 : 4,\n            scope_: parent ? parent.scope_ : getCurrentScope(),\n            modified_: false,\n            finalized_: false,\n            assigned_: {},\n            parent_: parent,\n            // base is the object we are drafting\n            base_: base,\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n            draft_: draft,\n            copy_: null,\n            revoked_: false,\n            isManual_: false\n        };\n        Object.defineProperty(draft, DRAFT_STATE, {\n            value: state,\n            // enumerable: false <- the default\n            writable: true\n        });\n        return draft;\n    } // property descriptors are recycled to make sure we don't create a get and set closure per property,\n    // but share them all instead\n    var descriptors = {};\n    function proxyProperty(prop, enumerable) {\n        var desc = descriptors[prop];\n        if (desc) {\n            desc.enumerable = enumerable;\n        } else {\n            descriptors[prop] = desc = {\n                configurable: true,\n                enumerable: enumerable,\n                get: function get() {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    return objectTraps.get(state, prop);\n                },\n                set: function set(value) {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    objectTraps.set(state, prop, value);\n                }\n            };\n        }\n        return desc;\n    } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n    function markChangesSweep(drafts) {\n        // The natural order of drafts in the `scope` array is based on when they\n        // were accessed. By processing drafts in reverse natural order, we have a\n        // better chance of processing leaf nodes first. When a leaf node is known to\n        // have changed, we can avoid any traversal of its ancestor nodes.\n        for(var i = drafts.length - 1; i >= 0; i--){\n            var state = drafts[i][DRAFT_STATE];\n            if (!state.modified_) {\n                switch(state.type_){\n                    case 5:\n                        if (hasArrayChanges(state)) markChanged(state);\n                        break;\n                    case 4:\n                        if (hasObjectChanges(state)) markChanged(state);\n                        break;\n                }\n            }\n        }\n    }\n    function markChangesRecursively(object) {\n        if (!object || typeof object !== \"object\") return;\n        var state = object[DRAFT_STATE];\n        if (!state) return;\n        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;\n        if (type_ === 4) {\n            // Look for added keys.\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n            // unnecessary work.\n            // also: probably we can store the information we detect here, to speed up tree finalization!\n            each(draft_, function(key) {\n                if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\n                if (base_[key] === undefined && !has(base_, key)) {\n                    assigned_[key] = true;\n                    markChanged(state);\n                } else if (!assigned_[key]) {\n                    // Only untouched properties trigger recursion.\n                    markChangesRecursively(draft_[key]);\n                }\n            }); // Look for removed keys.\n            each(base_, function(key) {\n                // The `undefined` check is a fast path for pre-existing keys.\n                if (draft_[key] === undefined && !has(draft_, key)) {\n                    assigned_[key] = false;\n                    markChanged(state);\n                }\n            });\n        } else if (type_ === 5) {\n            if (hasArrayChanges(state)) {\n                markChanged(state);\n                assigned_.length = true;\n            }\n            if (draft_.length < base_.length) {\n                for(var i = draft_.length; i < base_.length; i++){\n                    assigned_[i] = false;\n                }\n            } else {\n                for(var _i2 = base_.length; _i2 < draft_.length; _i2++){\n                    assigned_[_i2] = true;\n                }\n            } // Minimum count is enough, the other parts has been processed.\n            var min = Math.min(draft_.length, base_.length);\n            for(var _i3 = 0; _i3 < min; _i3++){\n                // Only untouched indices trigger recursion.\n                if (!draft_.hasOwnProperty(_i3)) {\n                    assigned_[_i3] = true;\n                }\n                if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\n            }\n        }\n    }\n    function hasObjectChanges(state) {\n        var base_ = state.base_, draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\n        // non-numeric keys are ordered by time of definition on the object.\n        var keys = ownKeys(draft_);\n        for(var i = keys.length - 1; i >= 0; i--){\n            var key = keys[i];\n            if (key === DRAFT_STATE) continue;\n            var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\n            if (baseValue === undefined && !has(base_, key)) {\n                return true;\n            } else {\n                var value = draft_[key];\n                var _state = value && value[DRAFT_STATE];\n                if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\n                    return true;\n                }\n            }\n        } // At this point, no keys were added or changed.\n        // Compare key count to determine if keys were deleted.\n        var baseIsDraft = !!base_[DRAFT_STATE];\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\n    }\n    function hasArrayChanges(state) {\n        var draft_ = state.draft_;\n        if (draft_.length !== state.base_.length) return true; // See #116\n        // If we first shorten the length, our array interceptors will be removed.\n        // If after that new items are added, result in the same original length,\n        // those last items will have no intercepting property.\n        // So if there is no own descriptor on the last position, we know that items were removed and added\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n        // the last one\n        // last descriptor can be not a trap, if the array was extended\n        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n        if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\n        for(var i = 0; i < draft_.length; i++){\n            if (!draft_.hasOwnProperty(i)) return true;\n        } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n        return false;\n    }\n    function hasChanges_(state) {\n        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"ES5\", {\n        createES5Proxy_: createES5Proxy_,\n        willFinalizeES5_: willFinalizeES5_,\n        hasChanges_: hasChanges_\n    });\n}\nfunction enablePatches() {\n    var REPLACE = \"replace\";\n    var ADD = \"add\";\n    var REMOVE = \"remove\";\n    function generatePatches_(state, basePath, patches, inversePatches) {\n        switch(state.type_){\n            case 0:\n            case 4:\n            case 2:\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n            case 5:\n            case 1:\n                return generateArrayPatches(state, basePath, patches, inversePatches);\n            case 3:\n                return generateSetPatches(state, basePath, patches, inversePatches);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, assigned_ = state.assigned_;\n        var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\n        if (copy_.length < base_.length) {\n            var _ref = [\n                copy_,\n                base_\n            ];\n            base_ = _ref[0];\n            copy_ = _ref[1];\n            var _ref2 = [\n                inversePatches,\n                patches\n            ];\n            patches = _ref2[0];\n            inversePatches = _ref2[1];\n        } // Process replaced indices.\n        for(var i = 0; i < base_.length; i++){\n            if (assigned_[i] && copy_[i] !== base_[i]) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path: path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copy_[i])\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path: path,\n                    value: clonePatchValueIfNeeded(base_[i])\n                });\n            }\n        } // Process added indices.\n        for(var _i = base_.length; _i < copy_.length; _i++){\n            var _path = basePath.concat([\n                _i\n            ]);\n            patches.push({\n                op: ADD,\n                path: _path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[_i])\n            });\n        }\n        if (base_.length < copy_.length) {\n            inversePatches.push({\n                op: REPLACE,\n                path: basePath.concat([\n                    \"length\"\n                ]),\n                value: base_.length\n            });\n        }\n    } // This is used for both Map objects and normal objects.\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        each(state.assigned_, function(key, assignedValue) {\n            var origValue = get(base_, key);\n            var value = get(copy_, key);\n            var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            var path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op: op,\n                path: path\n            } : {\n                op: op,\n                path: path,\n                value: value\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path: path\n            } : op === REMOVE ? {\n                op: ADD,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        var i = 0;\n        base_.forEach(function(value) {\n            if (!copy_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach(function(value) {\n            if (!base_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n        patches.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? undefined : replacement\n        });\n        inversePatches.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach(function(patch) {\n            var path = patch.path, op = patch.op;\n            var base = draft;\n            for(var i = 0; i < path.length - 1; i++){\n                var parentType = getArchtype(base);\n                var p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                } // See #738, avoid prototype pollution\n                if ((parentType === 0 || parentType === 1) && (p === \"__proto__\" || p === \"constructor\")) die(24);\n                if (typeof base === \"function\" && p === \"prototype\") die(24);\n                base = get(base, p);\n                if (typeof base !== \"object\") die(15, path.join(\"/\"));\n            }\n            var type = getArchtype(base);\n            var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n            var key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2:\n                            return base.set(key, value);\n                        /* istanbul ignore next */ case 3:\n                            die(16);\n                        default:\n                            // if value is an object, then it's assigned by reference\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\n                            // so we use value from the cloned patch\n                            // @ts-ignore\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1:\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2:\n                            return base.set(key, value);\n                        case 3:\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1:\n                            return base.splice(key, 1);\n                        case 2:\n                            return base.delete(key);\n                        case 3:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(17, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function(_ref3) {\n            var k = _ref3[0], v = _ref3[1];\n            return [\n                k,\n                deepClonePatchValue(v)\n            ];\n        }));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        var cloned = Object.create(Object.getPrototypeOf(obj));\n        for(var key in obj){\n            cloned[key] = deepClonePatchValue(obj[key]);\n        }\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(\"Patches\", {\n        applyPatches_: applyPatches_,\n        generatePatches_: generatePatches_,\n        generateReplacementPatches_: generateReplacementPatches_\n    });\n}\n// types only!\nfunction enableMapSet() {\n    /* istanbul ignore next */ var _extendStatics = function extendStatics(d, b) {\n        _extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b){\n                if (b.hasOwnProperty(p)) d[p] = b[p];\n            }\n        };\n        return _extendStatics(d, b);\n    }; // Ugly hack to resolve #502 and inherit built in Map / Set\n    function __extends(d, b) {\n        _extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = (__.prototype = b.prototype, new __());\n    }\n    var DraftMap = function(_super) {\n        __extends(DraftMap, _super); // Create class manually, cause #502\n        function DraftMap(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 2,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                assigned_: undefined,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false\n            };\n            return this;\n        }\n        var p = DraftMap.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: false,\n        });\n        p.has = function(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        };\n        p.set = function(key, value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        };\n        p.delete = function(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = new Map();\n                each(state.base_, function(key) {\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        };\n        p.forEach = function(cb, thisArg) {\n            var _this = this;\n            var state = this[DRAFT_STATE];\n            latest(state).forEach(function(_value, key, _map) {\n                cb.call(thisArg, _this.get(key), key, _this);\n            });\n        };\n        p.get = function(key) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            var value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value; // either already drafted or reassigned\n            } // despite what it looks, this creates a draft only once, see above condition\n            var draft = createProxy(state.scope_.immer_, value, state);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        };\n        p.keys = function() {\n            return latest(this[DRAFT_STATE]).keys();\n        };\n        p.values = function() {\n            var _this2 = this, _ref;\n            var iterator = this.keys();\n            return _ref = {}, _ref[iteratorSymbol] = function() {\n                return _this2.values();\n            }, _ref.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this2.get(r.value);\n                return {\n                    done: false,\n                    value: value\n                };\n            }, _ref;\n        };\n        p.entries = function() {\n            var _this3 = this, _ref2;\n            var iterator = this.keys();\n            return _ref2 = {}, _ref2[iteratorSymbol] = function() {\n                return _this3.entries();\n            }, _ref2.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this3.get(r.value);\n                return {\n                    done: false,\n                    value: [\n                        r.value,\n                        value\n                    ]\n                };\n            }, _ref2;\n        };\n        p[iteratorSymbol] = function() {\n            return this.entries();\n        };\n        return DraftMap;\n    }(Map);\n    function proxyMap_(target, parent) {\n        // @ts-ignore\n        return new DraftMap(target, parent);\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    var DraftSet = function(_super) {\n        __extends(DraftSet, _super); // Create class manually, cause #502\n        function DraftSet(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 3,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                base_: target,\n                draft_: this,\n                drafts_: new Map(),\n                revoked_: false,\n                isManual_: false\n            };\n            return this;\n        }\n        var p = DraftSet.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: true,\n        });\n        p.has = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        };\n        p.add = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        };\n        p.delete = function(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        };\n        p.values = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        };\n        p.entries = function entries() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        };\n        p.keys = function() {\n            return this.values();\n        };\n        p[iteratorSymbol] = function() {\n            return this.values();\n        };\n        p.forEach = function forEach(cb, thisArg) {\n            var iterator = this.values();\n            var result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        };\n        return DraftSet;\n    }(Set);\n    function proxySet_(target, parent) {\n        // @ts-ignore\n        return new DraftSet(target, parent);\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            // create drafts for all entries to preserve insertion order\n            state.copy_ = new Set();\n            state.base_.forEach(function(value) {\n                if (isDraftable(value)) {\n                    var draft = createProxy(state.scope_.immer_, value, state);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"MapSet\", {\n        proxyMap_: proxyMap_,\n        proxySet_: proxySet_\n    });\n}\nfunction enableAllPlugins() {\n    enableES5();\n    enableMapSet();\n    enablePatches();\n}\nvar immer = /*#__PURE__*/ new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */ var produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */ var produceWithPatches = /*#__PURE__*/ immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */ var setAutoFreeze = /*#__PURE__*/ immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */ var setUseProxies = /*#__PURE__*/ immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */ var applyPatches = /*#__PURE__*/ immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */ var createDraft = /*#__PURE__*/ immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */ var finishDraft = /*#__PURE__*/ immer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */ function castDraft(value) {\n    return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */ function castImmutable(value) {\n    return value;\n}\nexports.Immer = Immer;\nexports.applyPatches = applyPatches;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.createDraft = createDraft;\nexports.current = current;\nexports[\"default\"] = produce;\nexports.enableAllPlugins = enableAllPlugins;\nexports.enableES5 = enableES5;\nexports.enableMapSet = enableMapSet;\nexports.enablePatches = enablePatches;\nexports.finishDraft = finishDraft;\nexports.freeze = freeze;\nexports.immerable = DRAFTABLE;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.nothing = NOTHING;\nexports.original = original;\nexports.produce = produce;\nexports.produceWithPatches = produceWithPatches;\nexports.setAutoFreeze = setAutoFreeze;\nexports.setUseProxies = setUseProxies; //# sourceMappingURL=immer.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUM7QUFFSiw2QkFBNkI7QUFDN0IsMERBQTBEO0FBQzFELCtEQUErRDtBQUMvRCxJQUFJQyxZQUFZLE9BQU9DLFdBQVcsZUFBZSxPQUNqRCxXQUFXLEdBQ1hBLE9BQU8sU0FBUztBQUNoQixJQUFJQyxTQUFTLE9BQU9DLFFBQVE7QUFDNUIsSUFBSUMsU0FBUyxPQUFPQyxRQUFRO0FBQzVCLElBQUlDLGFBQWEsT0FBT0MsVUFBVSxlQUFlLE9BQU9BLE1BQU1DLFNBQVMsS0FBSyxlQUFlLE9BQU9DLFlBQVk7QUFDOUc7O0NBRUMsR0FFRCxJQUFJQyxVQUFVVixZQUNkLFdBQVcsR0FDWEMsT0FBT1UsR0FBRyxDQUFDLG1CQUFvQlosQ0FBQUEsT0FBTyxDQUFDLEdBQUdBLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNQSxJQUFHO0FBQzNFOzs7Ozs7O0NBT0MsR0FFRCxJQUFJYSxZQUFZWixZQUNoQixXQUFXLEdBQ1hDLE9BQU9VLEdBQUcsQ0FBQyxxQkFBcUI7QUFDaEMsSUFBSUUsY0FBY2IsWUFDbEIsV0FBVyxHQUNYQyxPQUFPVSxHQUFHLENBQUMsaUJBQWlCLGtCQUFrQix5REFBeUQ7QUFFdkcsSUFBSUcsaUJBQWlCLE9BQU9iLFVBQVUsZUFBZUEsT0FBT2MsUUFBUSxJQUFJO0FBRXhFLElBQUlDLFNBQVM7SUFDWCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHLFNBQVNDLEVBQUVDLElBQUk7UUFDaEIsT0FBTyx5SEFBeUhBO0lBQ2xJO0lBQ0EsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osSUFBSTtJQUNKLElB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O0FBQ2xCMUwsd0JBQXdCLEdBQUd3UztBQUMzQnhTLGlCQUFpQixHQUFHaU87QUFDcEJqTyxvQkFBb0IsR0FBR2lSO0FBQ3ZCalIscUJBQXFCLEdBQUd1UDtBQUN4QnZQLG1CQUFtQixHQUFHa047QUFDdEJsTixjQUFjLEdBQUdtRztBQUNqQm5HLGlCQUFpQixHQUFHZTtBQUNwQmYsZUFBZSxHQUFHc0M7QUFDbEJ0QyxtQkFBbUIsR0FBR3VDO0FBQ3RCdkMsZUFBZSxHQUFHYTtBQUNsQmIsZ0JBQWdCLEdBQUd1RDtBQUNuQnZELGVBQWUsR0FBRzBMO0FBQ2xCMUwsMEJBQTBCLEdBQUdzTTtBQUM3QnRNLHFCQUFxQixHQUFHK007QUFDeEIvTSxxQkFBcUIsR0FBRzZNLGVBQ3hCLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyaWVuZGJvb2svLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5janMuZGV2ZWxvcG1lbnQuanM/OWE5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfcmVmO1xuXG4vLyBTaG91bGQgYmUgbm8gaW1wb3J0cyBoZXJlIVxuLy8gU29tZSB0aGluZ3MgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbGwgZWxzZS4uLlxuLy8gV2Ugb25seSB3YW50IHRvIGtub3cgaWYgbm9uLXBvbHlmaWxsZWQgc3ltYm9scyBhcmUgYXZhaWxhYmxlXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Zcbi8qI19fUFVSRV9fKi9cblN5bWJvbChcInhcIikgPT09IFwic3ltYm9sXCI7XG52YXIgaGFzTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXNTZXQgPSB0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGhhc1Byb3hpZXMgPSB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFByb3h5LnJldm9jYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIE5PVEhJTkcgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIikgOiAoX3JlZiA9IHt9LCBfcmVmW1wiaW1tZXItbm90aGluZ1wiXSA9IHRydWUsIF9yZWYpO1xuLyoqXHJcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xyXG4gKiAoYWxiZWl0IHdpdGggYSBjdXN0b20gcHJvdG90eXBlKSwgeW91IG11c3QgZGVmaW5lIGVpdGhlciBhbiBpbnN0YW5jZSBwcm9wZXJ0eVxyXG4gKiBvciBhIHN0YXRpYyBwcm9wZXJ0eSBvbiBlYWNoIG9mIHlvdXIgY3VzdG9tIGNsYXNzZXMuXHJcbiAqXHJcbiAqIE90aGVyd2lzZSwgeW91ciBjbGFzcyBpbnN0YW5jZSB3aWxsIG5ldmVyIGJlIGRyYWZ0ZWQsIHdoaWNoIG1lYW5zIGl0IHdvbid0IGJlXHJcbiAqIHNhZmUgdG8gbXV0YXRlIGluIGEgcHJvZHVjZSBjYWxsYmFjay5cclxuICovXG5cbnZhciBEUkFGVEFCTEUgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKSA6IFwiX18kaW1tZXJfZHJhZnRhYmxlXCI7XG52YXIgRFJBRlRfU1RBVEUgPSBoYXNTeW1ib2wgP1xuLyojX19QVVJFX18qL1xuU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpIDogXCJfXyRpbW1lcl9zdGF0ZVwiOyAvLyBFdmVuIGEgcG9seWZpbGxlZCBTeW1ib2wgbWlnaHQgcHJvdmlkZSBTeW1ib2wuaXRlcmF0b3JcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxudmFyIGVycm9ycyA9IHtcbiAgMDogXCJJbGxlZ2FsIHN0YXRlXCIsXG4gIDE6IFwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIixcbiAgMjogXCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLFxuICAzOiBmdW5jdGlvbiBfKGRhdGEpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcbiAgfSxcbiAgNDogXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICA1OiBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICA2OiBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICA3OiBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICA4OiBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgOTogXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIDEwOiBcIlRoZSBnaXZlbiBkcmFmdCBpcyBhbHJlYWR5IGZpbmFsaXplZFwiLFxuICAxMTogXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICAxMjogXCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICAxMzogXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcbiAgMTQ6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuICAxNTogZnVuY3Rpb24gXyhwYXRoKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xuICB9LFxuICAxNjogJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuICAxNzogZnVuY3Rpb24gXyhvcCkge1xuICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcDtcbiAgfSxcbiAgMTg6IGZ1bmN0aW9uIF8ocGx1Z2luKSB7XG4gICAgcmV0dXJuIFwiVGhlIHBsdWdpbiBmb3IgJ1wiICsgcGx1Z2luICsgXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIgKyBwbHVnaW4gKyBcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwiO1xuICB9LFxuICAyMDogXCJDYW5ub3QgdXNlIHByb3hpZXMgaWYgUHJveHksIFByb3h5LnJldm9jYWJsZSBvciBSZWZsZWN0IGFyZSBub3QgYXZhaWxhYmxlXCIsXG4gIDIxOiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwicHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnXCIgKyB0aGluZyArIFwiJ1wiO1xuICB9LFxuICAyMjogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIidjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIgKyB0aGluZztcbiAgfSxcbiAgMjM6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCInb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIiArIHRoaW5nO1xuICB9LFxuICAyNDogXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbn07XG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBlID0gZXJyb3JzW2Vycm9yXTtcbiAgICB2YXIgbXNnID0gIWUgPyBcInVua25vd24gZXJyb3IgbnI6IFwiICsgZXJyb3IgOiB0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiID8gZS5hcHBseShudWxsLCBhcmdzKSA6IGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0ltbWVyXSBcIiArIG1zZyk7XG4gIH1cbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gSW1tZXIgZHJhZnQgKi9cblxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc0RyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGRyYWZ0ZWQgYnkgSW1tZXIgKi9cblxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSkge1xuICB2YXIgX3ZhbHVlJGNvbnN0cnVjdG9yO1xuXG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhISgoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF92YWx1ZSRjb25zdHJ1Y3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJGNvbnN0cnVjdG9yW0RSQUZUQUJMRV0pIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XG59XG52YXIgb2JqZWN0Q3RvclN0cmluZyA9XG4vKiNfX1BVUkVfXyovXG5PYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblxuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5mdW5jdGlvbiBvcmlnaW5hbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjMsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcbn1cbi8qI19fUFVSRV9fKi9cblxudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTtcbiAgb3duS2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBlbnVtZXJhYmxlT25seSkge1xuICBpZiAoZW51bWVyYWJsZU9ubHkgPT09IHZvaWQgMCkge1xuICAgIGVudW1lcmFibGVPbmx5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMFxuICAvKiBPYmplY3QgKi9cbiAgKSB7XG4gICAgICAoZW51bWVyYWJsZU9ubHkgPyBPYmplY3Qua2V5cyA6IG93bktleXMpKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghZW51bWVyYWJsZU9ubHkgfHwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIikgaXRlcihrZXksIG9ialtrZXldLCBvYmopO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XG4gICAgICByZXR1cm4gaXRlcihpbmRleCwgZW50cnksIG9iaik7XG4gICAgfSk7XG4gIH1cbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA+IDMgPyBzdGF0ZS50eXBlXyAtIDQgLy8gY2F1c2UgT2JqZWN0IGFuZCBBcnJheSBtYXAgYmFjayBmcm9tIDQgYW5kIDVcbiAgOiBzdGF0ZS50eXBlXyAvLyBvdGhlcnMgYXJlIHRoZSBzYW1lXG4gIDogQXJyYXkuaXNBcnJheSh0aGluZykgPyAxXG4gIC8qIEFycmF5ICovXG4gIDogaXNNYXAodGhpbmcpID8gMlxuICAvKiBNYXAgKi9cbiAgOiBpc1NldCh0aGluZykgPyAzXG4gIC8qIFNldCAqL1xuICA6IDBcbiAgLyogT2JqZWN0ICovXG4gIDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaGFzKHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcbiAgLyogTWFwICovXG4gID8gdGhpbmcuaGFzKHByb3ApIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKTtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMlxuICAvKiBNYXAgKi9cbiAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXTtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gc2V0KHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpIHtcbiAgdmFyIHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XG4gIGlmICh0ID09PSAyXG4gIC8qIE1hcCAqL1xuICApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO2Vsc2UgaWYgKHQgPT09IDNcbiAgLyogU2V0ICovXG4gICkge1xuICAgICAgdGhpbmcuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2UgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWU7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gRnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9jNjk5MDRhNTExYjkwMDI2NjkzNTE2ODIyMzA2M2RkODc3MmRmYzQwL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvc2hhbGxvd0VxdWFsLmpzXG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc1NldCh0YXJnZXQpIHtcbiAgcmV0dXJuIGhhc1NldCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTZXQ7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGxhdGVzdChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGJhc2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlKTtcbiAgdmFyIGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcbiAgdmFyIGtleXMgPSBvd25LZXlzKGRlc2NyaXB0b3JzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW2tleV07XG5cbiAgICBpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIH0gLy8gbGlrZSBvYmplY3QuYXNzaWduLCB3ZSB3aWxsIHJlYWQgYW55IF9vd25fLCBnZXQvc2V0IGFjY2Vzc29ycy4gVGhpcyBoZWxwcyBpbiBkZWFsaW5nXG4gICAgLy8gd2l0aCBsaWJyYXJpZXMgdGhhdCB0cmFwIHZhbHVlcywgbGlrZSBtb2J4IG9yIHZ1ZVxuICAgIC8vIHVubGlrZSBvYmplY3QuYXNzaWduLCBub24tZW51bWVyYWJsZXMgd2lsbCBiZSBjb3BpZWQgYXMgd2VsbFxuXG5cbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIGRlc2NyaXB0b3JzW2tleV0gPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiBmcmVlemUob2JqLCBkZWVwKSB7XG4gIGlmIChkZWVwID09PSB2b2lkIDApIHtcbiAgICBkZWVwID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGcm96ZW4ob2JqKSB8fCBpc0RyYWZ0KG9iaikgfHwgIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmo7XG5cbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPiAxXG4gIC8qIE1hcCBvciBTZXQgKi9cbiAgKSB7XG4gICAgICBvYmouc2V0ID0gb2JqLmFkZCA9IG9iai5jbGVhciA9IG9iai5kZWxldGUgPSBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnM7XG4gICAgfVxuXG4gIE9iamVjdC5mcmVlemUob2JqKTtcbiAgaWYgKGRlZXApIGVhY2gob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBmcmVlemUodmFsdWUsIHRydWUpO1xuICB9LCB0cnVlKTtcbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG5cbmZ1bmN0aW9uIGlzRnJvemVuKG9iaikge1xuICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRydWU7IC8vIFNlZSAjNjAwLCBJRSBkaWVzIG9uIG5vbi1vYmplY3RzIGluIE9iamVjdC5pc0Zyb3plblxuXG4gIHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKTtcbn1cblxuLyoqIFBsdWdpbiB1dGlsaXRpZXMgKi9cblxudmFyIHBsdWdpbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcbiAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XTtcblxuICBpZiAoIXBsdWdpbikge1xuICAgIGRpZSgxOCwgcGx1Z2luS2V5KTtcbiAgfSAvLyBAdHMtaWdub3JlXG5cblxuICByZXR1cm4gcGx1Z2luO1xufVxuZnVuY3Rpb24gbG9hZFBsdWdpbihwbHVnaW5LZXksIGltcGxlbWVudGF0aW9uKSB7XG4gIGlmICghcGx1Z2luc1twbHVnaW5LZXldKSBwbHVnaW5zW3BsdWdpbktleV0gPSBpbXBsZW1lbnRhdGlvbjtcbn1cblxudmFyIGN1cnJlbnRTY29wZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgaWYgKCAhY3VycmVudFNjb3BlKSBkaWUoMCk7XG4gIHJldHVybiBjdXJyZW50U2NvcGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHBhcmVudF8sIGltbWVyXykge1xuICByZXR1cm4ge1xuICAgIGRyYWZ0c186IFtdLFxuICAgIHBhcmVudF86IHBhcmVudF8sXG4gICAgaW1tZXJfOiBpbW1lcl8sXG4gICAgLy8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKSB7XG4gIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKTsgLy8gYXNzZXJ0IHdlIGhhdmUgdGhlIHBsdWdpblxuXG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpOyAvLyBAdHMtaWdub3JlXG5cbiAgc2NvcGUuZHJhZnRzXyA9IG51bGw7XG59XG5mdW5jdGlvbiBsZWF2ZVNjb3BlKHNjb3BlKSB7XG4gIGlmIChzY29wZSA9PT0gY3VycmVudFNjb3BlKSB7XG4gICAgY3VycmVudFNjb3BlID0gc2NvcGUucGFyZW50XztcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJTY29wZShpbW1lcikge1xuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcik7XG59XG5cbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0KSB7XG4gIHZhciBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgaWYgKHN0YXRlLnR5cGVfID09PSAwXG4gIC8qIFByb3h5T2JqZWN0ICovXG4gIHx8IHN0YXRlLnR5cGVfID09PSAxXG4gIC8qIFByb3h5QXJyYXkgKi9cbiAgKSBzdGF0ZS5yZXZva2VfKCk7ZWxzZSBzdGF0ZS5yZXZva2VkXyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSkge1xuICBzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aDtcbiAgdmFyIGJhc2VEcmFmdCA9IHNjb3BlLmRyYWZ0c19bMF07XG4gIHZhciBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmICghc2NvcGUuaW1tZXJfLnVzZVByb3hpZXNfKSBnZXRQbHVnaW4oXCJFUzVcIikud2lsbEZpbmFsaXplRVM1XyhzY29wZSwgcmVzdWx0LCBpc1JlcGxhY2VkKTtcblxuICBpZiAoaXNSZXBsYWNlZCkge1xuICAgIGlmIChiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLm1vZGlmaWVkXykge1xuICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgZGllKDQpO1xuICAgIH1cblxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICAvLyBGaW5hbGl6ZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgY29udGFpbnMgKG9yIGlzKSBhIHN1YnNldCBvZiB0aGUgZHJhZnQuXG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50XykgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLCByZXN1bHQsIHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5hbGl6ZSB0aGUgYmFzZSBkcmFmdC5cbiAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgYmFzZURyYWZ0LCBbXSk7XG4gIH1cblxuICByZXZva2VTY29wZShzY29wZSk7XG5cbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8oc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGUsIHZhbHVlLCBwYXRoKSB7XG4gIC8vIERvbid0IHJlY3Vyc2UgaW4gdGhvIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXNcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07IC8vIEEgcGxhaW4gb2JqZWN0LCBtaWdodCBuZWVkIGZyZWV6aW5nLCBtaWdodCBjb250YWluIGRyYWZ0c1xuXG4gIGlmICghc3RhdGUpIHtcbiAgICBlYWNoKHZhbHVlLCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICB9LCB0cnVlIC8vIFNlZSAjNTkwLCBkb24ndCByZWN1cnNlIGludG8gbm9uLWVudW1lcmFibGUgb2Ygbm9uIGRyYWZ0ZWQgb2JqZWN0c1xuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IC8vIE5ldmVyIGZpbmFsaXplIGRyYWZ0cyBvd25lZCBieSBhbm90aGVyIHNjb3BlLlxuXG5cbiAgaWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKSByZXR1cm4gdmFsdWU7IC8vIFVubW9kaWZpZWQgZHJhZnQsIHJldHVybiB0aGUgKGZyb3plbikgb3JpZ2luYWxcblxuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpO1xuICAgIHJldHVybiBzdGF0ZS5iYXNlXztcbiAgfSAvLyBOb3QgZmluYWxpemVkIHlldCwgbGV0J3MgZG8gdGhhdCBub3dcblxuXG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbiAgICB2YXIgcmVzdWx0ID0gLy8gRm9yIEVTNSwgY3JlYXRlIGEgZ29vZCBjb3B5IGZyb20gdGhlIGRyYWZ0IGZpcnN0LCB3aXRoIGFkZGVkIGtleXMgYW5kIHdpdGhvdXQgZGVsZXRlZCBrZXlzLlxuICAgIHN0YXRlLnR5cGVfID09PSA0XG4gICAgLyogRVM1T2JqZWN0ICovXG4gICAgfHwgc3RhdGUudHlwZV8gPT09IDVcbiAgICAvKiBFUzVBcnJheSAqL1xuICAgID8gc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdF8pIDogc3RhdGUuY29weV87IC8vIEZpbmFsaXplIGFsbCBjaGlsZHJlbiBvZiB0aGUgY29weVxuICAgIC8vIEZvciBzZXRzIHdlIGNsb25lIGJlZm9yZSBpdGVyYXRpbmcsIG90aGVyd2lzZSB3ZSBjYW4gZ2V0IGluIGVuZGxlc3MgbG9vcCBkdWUgdG8gbW9kaWZ5aW5nIGR1cmluZyBpdGVyYXRpb24sIHNlZSAjNjI4XG4gICAgLy8gVG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyIGluIGFsbCBjYXNlcyB3ZSB0aGVuIGNsZWFyIHRoZSBzZXRcbiAgICAvLyBBbmQgd2UgbGV0IGZpbmFsaXplUHJvcGVydHkga25vdyBpdCBuZWVkcyB0byByZS1hZGQgbm9uLWRyYWZ0IGNoaWxkcmVuIGJhY2sgdG8gdGhlIHRhcmdldFxuXG4gICAgdmFyIHJlc3VsdEVhY2ggPSByZXN1bHQ7XG4gICAgdmFyIGlzU2V0ID0gZmFsc2U7XG5cbiAgICBpZiAoc3RhdGUudHlwZV8gPT09IDNcbiAgICAvKiBTZXQgKi9cbiAgICApIHtcbiAgICAgICAgcmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KTtcbiAgICAgICAgcmVzdWx0LmNsZWFyKCk7XG4gICAgICAgIGlzU2V0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGVhY2gocmVzdWx0RWFjaCwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgcmVzdWx0LCBrZXksIGNoaWxkVmFsdWUsIHBhdGgsIGlzU2V0KTtcbiAgICB9KTsgLy8gZXZlcnl0aGluZyBpbnNpZGUgaXMgZnJvemVuLCB3ZSBjYW4gZnJlZXplIGhlcmVcblxuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSk7IC8vIGZpcnN0IHRpbWUgZmluYWxpemluZywgbGV0J3MgY3JlYXRlIHRob3NlIHBhdGNoZXNcblxuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKHN0YXRlLCBwYXRoLCByb290U2NvcGUucGF0Y2hlc18sIHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5jb3B5Xztcbn1cblxuZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHBhcmVudFN0YXRlLCB0YXJnZXRPYmplY3QsIHByb3AsIGNoaWxkVmFsdWUsIHJvb3RQYXRoLCB0YXJnZXRJc1NldCkge1xuICBpZiAoIGNoaWxkVmFsdWUgPT09IHRhcmdldE9iamVjdCkgZGllKDUpO1xuXG4gIGlmIChpc0RyYWZ0KGNoaWxkVmFsdWUpKSB7XG4gICAgdmFyIHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gM1xuICAgIC8qIFNldCAqL1xuICAgICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuICAgID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdW5kZWZpbmVkOyAvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cbiAgICB2YXIgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICBzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpOyAvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudGVkIHRvIGJlIGZyb3plblxuICAgIC8vIGlmIHdlIGdvdCBhIGRyYWZ0IGJhY2sgZnJvbSBmaW5hbGl6ZSwgd2UncmUgaW4gYSBuZXN0ZWQgcHJvZHVjZSBhbmQgc2hvdWxkbid0IGZyZWV6ZVxuXG4gICAgaWYgKGlzRHJhZnQocmVzKSkge1xuICAgICAgcm9vdFNjb3BlLmNhbkF1dG9GcmVlemVfID0gZmFsc2U7XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuICAgIHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSk7XG4gIH0gLy8gU2VhcmNoIG5ldyBvYmplY3RzIGZvciB1bmZpbmFsaXplZCBkcmFmdHMuIEZyb3plbiBvYmplY3RzIHNob3VsZCBuZXZlciBjb250YWluIGRyYWZ0cy5cblxuXG4gIGlmIChpc0RyYWZ0YWJsZShjaGlsZFZhbHVlKSAmJiAhaXNGcm96ZW4oY2hpbGRWYWx1ZSkpIHtcbiAgICBpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcbiAgICAgIC8vIG9wdGltaXphdGlvbjogaWYgYW4gb2JqZWN0IGlzIG5vdCBhIGRyYWZ0LCBhbmQgd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgLy8gZGVlcGZyZWV6ZSBldmVyeXRoaW5nLCBhbmQgd2UgYXJlIHN1cmUgdGhhdCBubyBkcmFmdHMgYXJlIGxlZnQgaW4gdGhlIHJlbWFpbmluZyBvYmplY3RcbiAgICAgIC8vIGNhdXNlIHdlIHNhdyBhbmQgZmluYWxpemVkIGFsbCBkcmFmdHMgYWxyZWFkeTsgd2UgY2FuIHN0b3AgdmlzaXRpbmcgdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG4gICAgICAvLyBUaGlzIGJlbmVmaXRzIGVzcGVjaWFsbHkgYWRkaW5nIGxhcmdlIGRhdGEgdHJlZSdzIHdpdGhvdXQgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAgLy8gU2VlIGFkZC1kYXRhLmpzIHBlcmYgdGVzdFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7IC8vIGltbWVyIGRlZXAgZnJlZXplcyBwbGFpbiBvYmplY3RzLCBzbyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgc3RhdGUsIHdlIGZyZWV6ZSBhcyB3ZWxsXG5cbiAgICBpZiAoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZSwgdmFsdWUsIGRlZXApIHtcbiAgaWYgKGRlZXAgPT09IHZvaWQgMCkge1xuICAgIGRlZXAgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIHdlIG5ldmVyIGZyZWV6ZSBmb3IgYSBub24tcm9vdCBzY29wZTsgYXMgaXQgd291bGQgcHJldmVudCBwcnVuaW5nIGZvciBkcmFmdHMgaW5zaWRlIHdyYXBwaW5nIG9iamVjdHNcbiAgaWYgKCFzY29wZS5wYXJlbnRfICYmIHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xuICAgIGZyZWV6ZSh2YWx1ZSwgZGVlcCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgZHJhZnQgb2YgdGhlIGBiYXNlYCBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHBhcmVudCBkcmFmdC1zdGF0ZSAodXNlZCBpbnRlcm5hbGx5KS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHR5cGVfOiBpc0FycmF5ID8gMVxuICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICA6IDBcbiAgICAvKiBQcm94eU9iamVjdCAqL1xuICAgICxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgLy8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXG4gICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAvLyBVc2VkIGR1cmluZyBmaW5hbGl6YXRpb24uXG4gICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cbiAgICBhc3NpZ25lZF86IHt9LFxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG4gICAgcGFyZW50XzogcGFyZW50LFxuICAgIC8vIFRoZSBiYXNlIHN0YXRlLlxuICAgIGJhc2VfOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0XzogbnVsbCxcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuICAgIGNvcHlfOiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZV86IG51bGwsXG4gICAgaXNNYW51YWxfOiBmYWxzZVxuICB9OyAvLyB0aGUgdHJhcHMgbXVzdCB0YXJnZXQgc29tZXRoaW5nLCBhIGJpdCBsaWtlIHRoZSAncmVhbCcgYmFzZS5cbiAgLy8gYnV0IGFsc28sIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgZnJvbSB0aGUgdGFyZ2V0IHdoYXQgdGhlIHJlbGV2YW50IHN0YXRlIGlzXG4gIC8vICh0byBhdm9pZCBjcmVhdGluZyB0cmFwcyBwZXIgaW5zdGFuY2UgdG8gY2FwdHVyZSB0aGUgc3RhdGUgaW4gY2xvc3VyZSxcbiAgLy8gYW5kIHRvIGF2b2lkIGNyZWF0aW5nIHdlaXJkIGhpZGRlbiBwcm9wZXJ0aWVzIGFzIHdlbGwpXG4gIC8vIFNvIHRoZSB0cmljayBpcyB0byB1c2UgJ3N0YXRlJyBhcyB0aGUgYWN0dWFsICd0YXJnZXQnISAoYW5kIG1ha2Ugc3VyZSB3ZSBpbnRlcmNlcHQgZXZlcnl0aGluZylcbiAgLy8gTm90ZSB0aGF0IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LCB3ZSBwdXQgdGhlIHN0YXRlIGluIGFuIGFycmF5IHRvIGhhdmUgYmV0dGVyIFJlZmxlY3QgZGVmYXVsdHMgb290YlxuXG4gIHZhciB0YXJnZXQgPSBzdGF0ZTtcbiAgdmFyIHRyYXBzID0gb2JqZWN0VHJhcHM7XG5cbiAgaWYgKGlzQXJyYXkpIHtcbiAgICB0YXJnZXQgPSBbc3RhdGVdO1xuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcbiAgfVxuXG4gIHZhciBfUHJveHkkcmV2b2NhYmxlID0gUHJveHkucmV2b2NhYmxlKHRhcmdldCwgdHJhcHMpLFxuICAgICAgcmV2b2tlID0gX1Byb3h5JHJldm9jYWJsZS5yZXZva2UsXG4gICAgICBwcm94eSA9IF9Qcm94eSRyZXZvY2FibGUucHJveHk7XG5cbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XG4gIHN0YXRlLnJldm9rZV8gPSByZXZva2U7XG4gIHJldHVybiBwcm94eTtcbn1cbi8qKlxyXG4gKiBPYmplY3QgZHJhZnRzXHJcbiAqL1xuXG52YXIgb2JqZWN0VHJhcHMgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKSByZXR1cm4gc3RhdGU7XG4gICAgdmFyIHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XG5cbiAgICBpZiAoIWhhcyhzb3VyY2UsIHByb3ApKSB7XG4gICAgICAvLyBub24tZXhpc3Rpbmcgb3Igbm9uLW93biBwcm9wZXJ0eS4uLlxuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IC8vIENoZWNrIGZvciBleGlzdGluZyBkcmFmdCBpbiBtb2RpZmllZCBzdGF0ZS5cbiAgICAvLyBBc3NpZ25lZCB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0ZWQuIFRoaXMgY2F0Y2hlcyBhbnkgZHJhZnRzIHdlIGNyZWF0ZWQsIHRvby5cblxuXG4gICAgaWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfW3Byb3BdID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gaGFzKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyhzdGF0ZSkge1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobGF0ZXN0KHN0YXRlKSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlLCBwcm9wXG4gIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovXG4gICwgdmFsdWUpIHtcbiAgICB2YXIgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG5cbiAgICBpZiAoZGVzYyA9PT0gbnVsbCB8fCBkZXNjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNjLnNldCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG4gICAgICAvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICAvLyB0aGUgbGFzdCBjaGVjayBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBzZXR0aW5nIGEgbm9uLWV4aXN0aW5nIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgYSBjaGFuZ2UpXG4gICAgICAvLyBmcm9tIHNldHRpbmcgYW4gZXhpc3RpbmcgcHJvcGVydHkgd2l0aCB2YWx1ZSB1bmRlZmluZWQgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBub3QgYSBjaGFuZ2UpXG4gICAgICB2YXIgY3VycmVudCA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7IC8vIHNwZWNpYWwgY2FzZSwgaWYgd2UgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBhIGRyYWZ0LCB3ZSBjYW4gaWdub3JlIHRoZSBhc3NpZ25tZW50XG5cbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRbRFJBRlRfU1RBVEVdO1xuXG4gICAgICBpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuY29weV9bcHJvcF0gPT09IHZhbHVlICYmICggLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuY29weV8pIHx8IC8vIHNwZWNpYWwgY2FzZTogTmFOXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKSByZXR1cm4gdHJ1ZTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcbiAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgIGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbiBvcmlnaW5hbGx5IG5vdCBhc3NpZ25lZCBwcm9wZXJ0eSB3YXMgZGVsZXRlZFxuICAgICAgZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXTtcbiAgICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgaWYgKHN0YXRlLmNvcHlfKSBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3RhdGUsIHByb3ApIHtcbiAgICB2YXIgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIHZhciBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYykgcmV0dXJuIGRlc2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gMVxuICAgICAgLyogUHJveHlBcnJheSAqL1xuICAgICAgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICBkaWUoMTEpO1xuICB9LFxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKCkge1xuICAgIGRpZSgxMik7XG4gIH1cbn07XG4vKipcclxuICogQXJyYXkgZHJhZnRzXHJcbiAqL1xuXG52YXIgYXJyYXlUcmFwcyA9IHt9O1xuZWFjaChvYmplY3RUcmFwcywgZnVuY3Rpb24gKGtleSwgZm4pIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcbiAgaWYgKCBpc05hTihwYXJzZUludChwcm9wKSkpIGRpZSgxMyk7IC8vIEB0cy1pZ25vcmVcblxuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdW5kZWZpbmVkKTtcbn07XG5cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAoIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKSBkaWUoMTQpO1xuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XG59OyAvLyBBY2Nlc3MgYSBwcm9wZXJ0eSB3aXRob3V0IGNyZWF0aW5nIGFuIEltbWVyIGRyYWZ0LlxuXG5cbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICB2YXIgc291cmNlID0gc3RhdGUgPyBsYXRlc3Qoc3RhdGUpIDogZHJhZnQ7XG4gIHJldHVybiBzb3VyY2VbcHJvcF07XG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcbiAgdmFyIF9kZXNjJGdldDtcblxuICB2YXIgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcbiAgcmV0dXJuIGRlc2MgPyBcInZhbHVlXCIgaW4gZGVzYyA/IGRlc2MudmFsdWUgOiAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG4gIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxuICAoX2Rlc2MkZ2V0ID0gZGVzYy5nZXQpID09PSBudWxsIHx8IF9kZXNjJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Rlc2MkZ2V0LmNhbGwoc3RhdGUuZHJhZnRfKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcbiAgLy8gJ2luJyBjaGVja3MgcHJvdG8hXG4gIGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG5cbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcbiAgICBpZiAoZGVzYykgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbWFya0NoYW5nZWQoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBzdGF0ZS5tb2RpZmllZF8gPSB0cnVlO1xuXG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlLnBhcmVudF8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUNvcHkoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgIHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuYmFzZV8pO1xuICB9XG59XG5cbnZhciBJbW1lciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEltbWVyKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnVzZVByb3hpZXNfID0gaGFzUHJveGllcztcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxyXG4gICAgICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcclxuICAgICAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XHJcbiAgICAgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxyXG4gICAgICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxyXG4gICAgICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXHJcbiAgICAgKi9cblxuICAgIHRoaXMucHJvZHVjZSA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgIC8vIGN1cnJpZWQgaW52b2NhdGlvblxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBkZWZhdWx0QmFzZSA9IHJlY2lwZTtcbiAgICAgICAgcmVjaXBlID0gYmFzZTtcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJhc2UgPSBkZWZhdWx0QmFzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgICAgICAgdmFyIF9yZWNpcGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoX3JlY2lwZSA9IHJlY2lwZSkuY2FsbC5hcHBseShfcmVjaXBlLCBbX3RoaXMyLCBkcmFmdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9KTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg2KTtcbiAgICAgIGlmIChwYXRjaExpc3RlbmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikgZGllKDcpO1xuICAgICAgdmFyIHJlc3VsdDsgLy8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICB2YXIgc2NvcGUgPSBlbnRlclNjb3BlKF90aGlzKTtcbiAgICAgICAgdmFyIHByb3h5ID0gY3JlYXRlUHJveHkoX3RoaXMsIGJhc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBoYXNFcnJvciA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZWNpcGUocHJveHkpO1xuICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gZmluYWxseSBpbnN0ZWFkIG9mIGNhdGNoICsgcmV0aHJvdyBiZXR0ZXIgcHJlc2VydmVzIG9yaWdpbmFsIHN0YWNrXG4gICAgICAgICAgaWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSk7ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXN1bHQgPSByZWNpcGUoYmFzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgcmVzdWx0ID0gYmFzZTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORykgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoX3RoaXMuYXV0b0ZyZWV6ZV8pIGZyZWV6ZShyZXN1bHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgICB2YXIgaXAgPSBbXTtcbiAgICAgICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2UgZGllKDIxLCBiYXNlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMgPSBmdW5jdGlvbiAoYmFzZSwgcmVjaXBlKSB7XG4gICAgICAvLyBjdXJyaWVkIGludm9jYXRpb25cbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3RoaXMucHJvZHVjZVdpdGhQYXRjaGVzKHN0YXRlLCBmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmFwcGx5KHZvaWQgMCwgW2RyYWZ0XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgZnVuY3Rpb24gKHAsIGlwKSB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXh0U3RhdGUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbcmVzdWx0LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy51c2VQcm94aWVzKSA9PT0gXCJib29sZWFuXCIpIHRoaXMuc2V0VXNlUHJveGllcyhjb25maWcudXNlUHJveGllcyk7XG4gICAgaWYgKHR5cGVvZiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9GcmVlemUpID09PSBcImJvb2xlYW5cIikgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbW1lci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNyZWF0ZURyYWZ0ID0gZnVuY3Rpb24gY3JlYXRlRHJhZnQoYmFzZSkge1xuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpIGRpZSg4KTtcbiAgICBpZiAoaXNEcmFmdChiYXNlKSkgYmFzZSA9IGN1cnJlbnQoYmFzZSk7XG4gICAgdmFyIHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcbiAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eSh0aGlzLCBiYXNlLCB1bmRlZmluZWQpO1xuICAgIHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlO1xuICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcblxuICBfcHJvdG8uZmluaXNoRHJhZnQgPSBmdW5jdGlvbiBmaW5pc2hEcmFmdChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcblxuICAgIHtcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXykgZGllKDkpO1xuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8pIGRpZSgxMCk7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gc3RhdGUuc2NvcGVfO1xuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdCh1bmRlZmluZWQsIHNjb3BlKTtcbiAgfVxuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldEF1dG9GcmVlemUgPSBmdW5jdGlvbiBzZXRBdXRvRnJlZXplKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlO1xuICB9XG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xyXG4gICAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFVzZVByb3hpZXMgPSBmdW5jdGlvbiBzZXRVc2VQcm94aWVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICFoYXNQcm94aWVzKSB7XG4gICAgICBkaWUoMjApO1xuICAgIH1cblxuICAgIHRoaXMudXNlUHJveGllc18gPSB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uYXBwbHlQYXRjaGVzID0gZnVuY3Rpb24gYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcbiAgICAvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXG4gICAgLy8gYmVmb3JlIGFwcGx5aW5nIHBhdGNoZXNcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBwYXRjaCA9IHBhdGNoZXNbaV07XG5cbiAgICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgYmFzZSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoZXJlIHdhcyBhIHBhdGNoIHRoYXQgcmVwbGFjZWQgdGhlIGVudGlyZSBzdGF0ZSwgc3RhcnQgZnJvbSB0aGVcbiAgICAvLyBwYXRjaCBhZnRlciB0aGF0LlxuXG5cbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSk7XG4gICAgfVxuXG4gICAgdmFyIGFwcGx5UGF0Y2hlc0ltcGwgPSBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmFwcGx5UGF0Y2hlc187XG5cbiAgICBpZiAoaXNEcmFmdChiYXNlKSkge1xuICAgICAgLy8gTi5COiBuZXZlciBoaXRzIGlmIHNvbWUgcGF0Y2ggYSByZXBsYWNlbWVudCwgcGF0Y2hlcyBhcmUgbmV2ZXIgZHJhZnRzXG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgcHJvZHVjZSBhIGNvcHkgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cblxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChkcmFmdCwgcGF0Y2hlcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEltbWVyO1xufSgpO1xuZnVuY3Rpb24gY3JlYXRlUHJveHkoaW1tZXIsIHZhbHVlLCBwYXJlbnQpIHtcbiAgLy8gcHJlY29uZGl0aW9uOiBjcmVhdGVQcm94eSBzaG91bGQgYmUgZ3VhcmRlZCBieSBpc0RyYWZ0YWJsZSwgc28gd2Uga25vdyB3ZSBjYW4gc2FmZWx5IGRyYWZ0XG4gIHZhciBkcmFmdCA9IGlzTWFwKHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudCkgOiBpc1NldCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogaW1tZXIudXNlUHJveGllc18gPyBjcmVhdGVQcm94eVByb3h5KHZhbHVlLCBwYXJlbnQpIDogZ2V0UGx1Z2luKFwiRVM1XCIpLmNyZWF0ZUVTNVByb3h5Xyh2YWx1ZSwgcGFyZW50KTtcbiAgdmFyIHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpO1xuICBzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpO1xuICByZXR1cm4gZHJhZnQ7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDIyLCB2YWx1ZSk7XG4gIHJldHVybiBjdXJyZW50SW1wbCh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdGFibGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIHZhciBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgdmFyIGNvcHk7XG4gIHZhciBhcmNoVHlwZSA9IGdldEFyY2h0eXBlKHZhbHVlKTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXyAmJiAoc3RhdGUudHlwZV8gPCA0IHx8ICFnZXRQbHVnaW4oXCJFUzVcIikuaGFzQ2hhbmdlc18oc3RhdGUpKSkgcmV0dXJuIHN0YXRlLmJhc2VfOyAvLyBPcHRpbWl6YXRpb246IGF2b2lkIGdlbmVyYXRpbmcgbmV3IGRyYWZ0cyBkdXJpbmcgY29weWluZ1xuXG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgY29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKTtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKTtcbiAgfVxuXG4gIGVhY2goY29weSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xuICAgIGlmIChzdGF0ZSAmJiBnZXQoc3RhdGUuYmFzZV8sIGtleSkgPT09IGNoaWxkVmFsdWUpIHJldHVybjsgLy8gbm8gbmVlZCB0byBjb3B5IG9yIHNlYXJjaCBpbiBzb21ldGhpbmcgdGhhdCBkaWRuJ3QgY2hhbmdlXG5cbiAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XG4gIH0pOyAvLyBJbiB0aGUgZnV0dXJlLCB3ZSBtaWdodCBjb25zaWRlciBmcmVlemluZyBoZXJlLCBiYXNlZCBvbiB0aGUgY3VycmVudCBzZXR0aW5nc1xuXG4gIHJldHVybiBhcmNoVHlwZSA9PT0gM1xuICAvKiBTZXQgKi9cbiAgPyBuZXcgU2V0KGNvcHkpIDogY29weTtcbn1cblxuZnVuY3Rpb24gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpIHtcbiAgLy8gY3JlYXRlcyBhIHNoYWxsb3cgY29weSwgZXZlbiBpZiBpdCBpcyBhIG1hcCBvciBzZXRcbiAgc3dpdGNoIChhcmNoVHlwZSkge1xuICAgIGNhc2UgMlxuICAgIC8qIE1hcCAqL1xuICAgIDpcbiAgICAgIHJldHVybiBuZXcgTWFwKHZhbHVlKTtcblxuICAgIGNhc2UgM1xuICAgIC8qIFNldCAqL1xuICAgIDpcbiAgICAgIC8vIFNldCB3aWxsIGJlIGNsb25lZCBhcyBhcnJheSB0ZW1wb3JhcmlseSwgc28gdGhhdCB3ZSBjYW4gcmVwbGFjZSBpbmRpdmlkdWFsIGl0ZW1zXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gc2hhbGxvd0NvcHkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBlbmFibGVFUzUoKSB7XG4gIGZ1bmN0aW9uIHdpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCkge1xuICAgIGlmICghaXNSZXBsYWNlZCkge1xuICAgICAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICAgIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoc2NvcGUuZHJhZnRzX1swXSk7XG4gICAgICB9IC8vIFRoaXMgaXMgZmFzdGVyIHdoZW4gd2UgZG9uJ3QgY2FyZSBhYm91dCB3aGljaCBhdHRyaWJ1dGVzIGNoYW5nZWQuXG5cblxuICAgICAgbWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKTtcbiAgICB9IC8vIFdoZW4gYSBjaGlsZCBkcmFmdCBpcyByZXR1cm5lZCwgbG9vayBmb3IgY2hhbmdlcy5cbiAgICBlbHNlIGlmIChpc0RyYWZ0KHJlc3VsdCkgJiYgcmVzdWx0W0RSQUZUX1NUQVRFXS5zY29wZV8gPT09IHNjb3BlKSB7XG4gICAgICAgIG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXyk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFUzVEcmFmdChpc0FycmF5LCBiYXNlKSB7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIHZhciBkcmFmdCA9IG5ldyBBcnJheShiYXNlLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIFwiXCIgKyBpLCBwcm94eVByb3BlcnR5KGksIHRydWUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2Rlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcblxuICAgICAgZGVsZXRlIF9kZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gICAgICB2YXIga2V5cyA9IG93bktleXMoX2Rlc2NyaXB0b3JzKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW19pXTtcbiAgICAgICAgX2Rlc2NyaXB0b3JzW2tleV0gPSBwcm94eVByb3BlcnR5KGtleSwgaXNBcnJheSB8fCAhIV9kZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIF9kZXNjcmlwdG9ycyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRVM1UHJveHlfKGJhc2UsIHBhcmVudCkge1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgICB2YXIgZHJhZnQgPSBjcmVhdGVFUzVEcmFmdChpc0FycmF5LCBiYXNlKTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICB0eXBlXzogaXNBcnJheSA/IDVcbiAgICAgIC8qIEVTNUFycmF5ICovXG4gICAgICA6IDRcbiAgICAgIC8qIEVTNU9iamVjdCAqL1xuICAgICAgLFxuICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICBhc3NpZ25lZF86IHt9LFxuICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgLy8gYmFzZSBpcyB0aGUgb2JqZWN0IHdlIGFyZSBkcmFmdGluZ1xuICAgICAgYmFzZV86IGJhc2UsXG4gICAgICAvLyBkcmFmdCBpcyB0aGUgZHJhZnQgb2JqZWN0IGl0c2VsZiwgdGhhdCB0cmFwcyBhbGwgcmVhZHMgYW5kIHJlYWRzIGZyb20gZWl0aGVyIHRoZSBiYXNlIChpZiB1bm1vZGlmaWVkKSBvciBjb3B5IChpZiBtb2RpZmllZClcbiAgICAgIGRyYWZ0XzogZHJhZnQsXG4gICAgICBjb3B5XzogbnVsbCxcbiAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgIGlzTWFudWFsXzogZmFsc2VcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkcmFmdCwgRFJBRlRfU1RBVEUsIHtcbiAgICAgIHZhbHVlOiBzdGF0ZSxcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlIDwtIHRoZSBkZWZhdWx0XG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfSAvLyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBhcmUgcmVjeWNsZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGNyZWF0ZSBhIGdldCBhbmQgc2V0IGNsb3N1cmUgcGVyIHByb3BlcnR5LFxuICAvLyBidXQgc2hhcmUgdGhlbSBhbGwgaW5zdGVhZFxuXG5cbiAgdmFyIGRlc2NyaXB0b3JzID0ge307XG5cbiAgZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShwcm9wLCBlbnVtZXJhYmxlKSB7XG4gICAgdmFyIGRlc2MgPSBkZXNjcmlwdG9yc1twcm9wXTtcblxuICAgIGlmIChkZXNjKSB7XG4gICAgICBkZXNjLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdFRyYXBzLmdldChzdGF0ZSwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICAgICAgb2JqZWN0VHJhcHMuc2V0KHN0YXRlLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH0gLy8gVGhpcyBsb29rcyBleHBlbnNpdmUsIGJ1dCBvbmx5IHByb3hpZXMgYXJlIHZpc2l0ZWQsIGFuZCBvbmx5IG9iamVjdHMgd2l0aG91dCBrbm93biBjaGFuZ2VzIGFyZSBzY2FubmVkLlxuXG5cbiAgZnVuY3Rpb24gbWFya0NoYW5nZXNTd2VlcChkcmFmdHMpIHtcbiAgICAvLyBUaGUgbmF0dXJhbCBvcmRlciBvZiBkcmFmdHMgaW4gdGhlIGBzY29wZWAgYXJyYXkgaXMgYmFzZWQgb24gd2hlbiB0aGV5XG4gICAgLy8gd2VyZSBhY2Nlc3NlZC4gQnkgcHJvY2Vzc2luZyBkcmFmdHMgaW4gcmV2ZXJzZSBuYXR1cmFsIG9yZGVyLCB3ZSBoYXZlIGFcbiAgICAvLyBiZXR0ZXIgY2hhbmNlIG9mIHByb2Nlc3NpbmcgbGVhZiBub2RlcyBmaXJzdC4gV2hlbiBhIGxlYWYgbm9kZSBpcyBrbm93biB0b1xuICAgIC8vIGhhdmUgY2hhbmdlZCwgd2UgY2FuIGF2b2lkIGFueSB0cmF2ZXJzYWwgb2YgaXRzIGFuY2VzdG9yIG5vZGVzLlxuICAgIGZvciAodmFyIGkgPSBkcmFmdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBzdGF0ZSA9IGRyYWZ0c1tpXVtEUkFGVF9TVEFURV07XG5cbiAgICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcbiAgICAgICAgICBjYXNlIDVcbiAgICAgICAgICAvKiBFUzVBcnJheSAqL1xuICAgICAgICAgIDpcbiAgICAgICAgICAgIGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUpKSBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNFxuICAgICAgICAgIC8qIEVTNU9iamVjdCAqL1xuICAgICAgICAgIDpcbiAgICAgICAgICAgIGlmIChoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KG9iamVjdCkge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHJldHVybjtcbiAgICB2YXIgc3RhdGUgPSBvYmplY3RbRFJBRlRfU1RBVEVdO1xuICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgZHJhZnRfID0gc3RhdGUuZHJhZnRfLFxuICAgICAgICBhc3NpZ25lZF8gPSBzdGF0ZS5hc3NpZ25lZF8sXG4gICAgICAgIHR5cGVfID0gc3RhdGUudHlwZV87XG5cbiAgICBpZiAodHlwZV8gPT09IDRcbiAgICAvKiBFUzVPYmplY3QgKi9cbiAgICApIHtcbiAgICAgICAgLy8gTG9vayBmb3IgYWRkZWQga2V5cy5cbiAgICAgICAgLy8gcHJvYmFibHkgdGhlcmUgaXMgYSBmYXN0ZXIgd2F5IHRvIGRldGVjdCBjaGFuZ2VzLCBhcyBzd2VlcCArIHJlY3Vyc2Ugc2VlbXMgdG8gZG8gc29tZVxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrLlxuICAgICAgICAvLyBhbHNvOiBwcm9iYWJseSB3ZSBjYW4gc3RvcmUgdGhlIGluZm9ybWF0aW9uIHdlIGRldGVjdCBoZXJlLCB0byBzcGVlZCB1cCB0cmVlIGZpbmFsaXphdGlvbiFcbiAgICAgICAgZWFjaChkcmFmdF8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgcmV0dXJuOyAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXG4gICAgICAgICAgaWYgKGJhc2VfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGJhc2VfLCBrZXkpKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9ba2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYXNzaWduZWRfW2tleV0pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdW50b3VjaGVkIHByb3BlcnRpZXMgdHJpZ2dlciByZWN1cnNpb24uXG4gICAgICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cbiAgICAgICAgZWFjaChiYXNlXywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG4gICAgICAgICAgaWYgKGRyYWZ0X1trZXldID09PSB1bmRlZmluZWQgJiYgIWhhcyhkcmFmdF8sIGtleSkpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1trZXldID0gZmFsc2U7XG4gICAgICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZV8gPT09IDVcbiAgICAvKiBFUzVBcnJheSAqL1xuICAgICkge1xuICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkge1xuICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICBhc3NpZ25lZF8ubGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFmdF8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGRyYWZ0Xy5sZW5ndGg7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXNzaWduZWRfW2ldID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IGJhc2VfLmxlbmd0aDsgX2kyIDwgZHJhZnRfLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1tfaTJdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTWluaW11bSBjb3VudCBpcyBlbm91Z2gsIHRoZSBvdGhlciBwYXJ0cyBoYXMgYmVlbiBwcm9jZXNzZWQuXG5cblxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oZHJhZnRfLmxlbmd0aCwgYmFzZV8ubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBtaW47IF9pMysrKSB7XG4gICAgICAgICAgLy8gT25seSB1bnRvdWNoZWQgaW5kaWNlcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cbiAgICAgICAgICBpZiAoIWRyYWZ0Xy5oYXNPd25Qcm9wZXJ0eShfaTMpKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9bX2kzXSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFzc2lnbmVkX1tfaTNdID09PSB1bmRlZmluZWQpIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW19pM10pO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSB7XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XzsgLy8gU2VhcmNoIGZvciBhZGRlZCBrZXlzIGFuZCBjaGFuZ2VkIGtleXMuIFN0YXJ0IGF0IHRoZSBiYWNrLCBiZWNhdXNlXG4gICAgLy8gbm9uLW51bWVyaWMga2V5cyBhcmUgb3JkZXJlZCBieSB0aW1lIG9mIGRlZmluaXRpb24gb24gdGhlIG9iamVjdC5cblxuICAgIHZhciBrZXlzID0gb3duS2V5cyhkcmFmdF8pO1xuXG4gICAgZm9yICh2YXIgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIGNvbnRpbnVlO1xuICAgICAgdmFyIGJhc2VWYWx1ZSA9IGJhc2VfW2tleV07IC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cbiAgICAgIGlmIChiYXNlVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhaGFzKGJhc2VfLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBPbmNlIGEgYmFzZSBrZXkgaXMgZGVsZXRlZCwgZnV0dXJlIGNoYW5nZXMgZ28gdW5kZXRlY3RlZCwgYmVjYXVzZSBpdHNcbiAgICAgIC8vIGRlc2NyaXB0b3IgaXMgZXJhc2VkLiBUaGlzIGJyYW5jaCBkZXRlY3RzIGFueSBtaXNzZWQgY2hhbmdlcy5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRyYWZ0X1trZXldO1xuXG4gICAgICAgICAgdmFyIF9zdGF0ZSA9IHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXTtcblxuICAgICAgICAgIGlmIChfc3RhdGUgPyBfc3RhdGUuYmFzZV8gIT09IGJhc2VWYWx1ZSA6ICFpcyh2YWx1ZSwgYmFzZVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cbiAgICAvLyBDb21wYXJlIGtleSBjb3VudCB0byBkZXRlcm1pbmUgaWYga2V5cyB3ZXJlIGRlbGV0ZWQuXG5cblxuICAgIHZhciBiYXNlSXNEcmFmdCA9ICEhYmFzZV9bRFJBRlRfU1RBVEVdO1xuICAgIHJldHVybiBrZXlzLmxlbmd0aCAhPT0gb3duS2V5cyhiYXNlXykubGVuZ3RoICsgKGJhc2VJc0RyYWZ0ID8gMCA6IDEpOyAvLyArIDEgdG8gY29ycmVjdCBmb3IgRFJBRlRfU1RBVEVcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkge1xuICAgIHZhciBkcmFmdF8gPSBzdGF0ZS5kcmFmdF87XG4gICAgaWYgKGRyYWZ0Xy5sZW5ndGggIT09IHN0YXRlLmJhc2VfLmxlbmd0aCkgcmV0dXJuIHRydWU7IC8vIFNlZSAjMTE2XG4gICAgLy8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBhZnRlciB0aGF0IG5ldyBpdGVtcyBhcmUgYWRkZWQsIHJlc3VsdCBpbiB0aGUgc2FtZSBvcmlnaW5hbCBsZW5ndGgsXG4gICAgLy8gdGhvc2UgbGFzdCBpdGVtcyB3aWxsIGhhdmUgbm8gaW50ZXJjZXB0aW5nIHByb3BlcnR5LlxuICAgIC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuICAgIC8vIE4uQi46IHNwbGljZSwgdW5zaGlmdCwgZXRjIG9ubHkgc2hpZnQgdmFsdWVzIGFyb3VuZCwgYnV0IG5vdCBwcm9wIGRlc2NyaXB0b3JzLCBzbyB3ZSBvbmx5IGhhdmUgdG8gY2hlY2tcbiAgICAvLyB0aGUgbGFzdCBvbmVcbiAgICAvLyBsYXN0IGRlc2NyaXB0b3IgY2FuIGJlIG5vdCBhIHRyYXAsIGlmIHRoZSBhcnJheSB3YXMgZXh0ZW5kZWRcblxuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkcmFmdF8sIGRyYWZ0Xy5sZW5ndGggLSAxKTsgLy8gZGVzY3JpcHRvciBjYW4gYmUgbnVsbCwgYnV0IG9ubHkgZm9yIG5ld2x5IGNyZWF0ZWQgc3BhcnNlIGFycmF5cywgZWcuIG5ldyBBcnJheSgxMClcblxuICAgIGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmdldCkgcmV0dXJuIHRydWU7IC8vIGlmIHdlIG1pc3MgYSBwcm9wZXJ0eSwgaXQgaGFzIGJlZW4gZGVsZXRlZCwgc28gYXJyYXkgcHJvYm9iYWx5IGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZnRfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWRyYWZ0Xy5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBGb3IgYWxsIG90aGVyIGNhc2VzLCB3ZSBkb24ndCBoYXZlIHRvIGNvbXBhcmUsIGFzIHRoZXkgd291bGQgaGF2ZSBiZWVuIHBpY2tlZCB1cCBieSB0aGUgaW5kZXggc2V0dGVyc1xuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDaGFuZ2VzXyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS50eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgID8gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkgOiBoYXNBcnJheUNoYW5nZXMoc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlXG4gIC8qRVM1U3RhdGUgfCBNYXBTdGF0ZSB8IFNldFN0YXRlKi9cbiAgKSB7XG4gICAgaWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xuICB9XG5cbiAgbG9hZFBsdWdpbihcIkVTNVwiLCB7XG4gICAgY3JlYXRlRVM1UHJveHlfOiBjcmVhdGVFUzVQcm94eV8sXG4gICAgd2lsbEZpbmFsaXplRVM1Xzogd2lsbEZpbmFsaXplRVM1XyxcbiAgICBoYXNDaGFuZ2VzXzogaGFzQ2hhbmdlc19cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XG4gIHZhciBSRVBMQUNFID0gXCJyZXBsYWNlXCI7XG4gIHZhciBBREQgPSBcImFkZFwiO1xuICB2YXIgUkVNT1ZFID0gXCJyZW1vdmVcIjtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG4gICAgICBjYXNlIDBcbiAgICAgIC8qIFByb3h5T2JqZWN0ICovXG4gICAgICA6XG4gICAgICBjYXNlIDRcbiAgICAgIC8qIEVTNU9iamVjdCAqL1xuICAgICAgOlxuICAgICAgY2FzZSAyXG4gICAgICAvKiBNYXAgKi9cbiAgICAgIDpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcblxuICAgICAgY2FzZSA1XG4gICAgICAvKiBFUzVBcnJheSAqL1xuICAgICAgOlxuICAgICAgY2FzZSAxXG4gICAgICAvKiBQcm94eUFycmF5ICovXG4gICAgICA6XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcblxuICAgICAgY2FzZSAzXG4gICAgICAvKiBTZXQgKi9cbiAgICAgIDpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGFzc2lnbmVkXyA9IHN0YXRlLmFzc2lnbmVkXztcbiAgICB2YXIgY29weV8gPSBzdGF0ZS5jb3B5XzsgLy8gUmVkdWNlIGNvbXBsZXhpdHkgYnkgZW5zdXJpbmcgYGJhc2VgIGlzIG5ldmVyIGxvbmdlci5cblxuICAgIGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcbiAgICAgIHZhciBfcmVmID0gW2NvcHlfLCBiYXNlX107XG4gICAgICBiYXNlXyA9IF9yZWZbMF07XG4gICAgICBjb3B5XyA9IF9yZWZbMV07XG4gICAgICB2YXIgX3JlZjIgPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdO1xuICAgICAgcGF0Y2hlcyA9IF9yZWYyWzBdO1xuICAgICAgaW52ZXJzZVBhdGNoZXMgPSBfcmVmMlsxXTtcbiAgICB9IC8vIFByb2Nlc3MgcmVwbGFjZWQgaW5kaWNlcy5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2Nlc3MgYWRkZWQgaW5kaWNlcy5cblxuXG4gICAgZm9yICh2YXIgX2kgPSBiYXNlXy5sZW5ndGg7IF9pIDwgY29weV8ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoW19pXSk7XG5cbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBBREQsXG4gICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tfaV0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZV8ubGVuZ3RoIDwgY29weV8ubGVuZ3RoKSB7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgIHBhdGg6IGJhc2VQYXRoLmNvbmNhdChbXCJsZW5ndGhcIl0pLFxuICAgICAgICB2YWx1ZTogYmFzZV8ubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gVGhpcyBpcyB1c2VkIGZvciBib3RoIE1hcCBvYmplY3RzIGFuZCBub3JtYWwgb2JqZWN0cy5cblxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgZWFjaChzdGF0ZS5hc3NpZ25lZF8sIGZ1bmN0aW9uIChrZXksIGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgIHZhciBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSk7XG4gICAgICB2YXIgdmFsdWUgPSBnZXQoY29weV8sIGtleSk7XG4gICAgICB2YXIgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSkgcmV0dXJuO1xuICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5KTtcbiAgICAgIHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8ge1xuICAgICAgICBvcDogb3AsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0gOiB7XG4gICAgICAgIG9wOiBvcCxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2gob3AgPT09IEFERCA/IHtcbiAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSA6IG9wID09PSBSRU1PVkUgPyB7XG4gICAgICAgIG9wOiBBREQsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpXG4gICAgICB9IDoge1xuICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcbiAgICAgICAgY29weV8gPSBzdGF0ZS5jb3B5XztcbiAgICB2YXIgaSA9IDA7XG4gICAgYmFzZV8uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghY29weV8uaGFzKHZhbHVlKSkge1xuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICBpID0gMDtcbiAgICBjb3B5Xy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2VWYWx1ZSwgcmVwbGFjZW1lbnQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogcmVwbGFjZW1lbnQgPT09IE5PVEhJTkcgPyB1bmRlZmluZWQgOiByZXBsYWNlbWVudFxuICAgIH0pO1xuICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBiYXNlVmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc18oZHJhZnQsIHBhdGNoZXMpIHtcbiAgICBwYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGNoKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGNoLnBhdGgsXG4gICAgICAgICAgb3AgPSBwYXRjaC5vcDtcbiAgICAgIHZhciBiYXNlID0gZHJhZnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHAgPSBcIlwiICsgcDtcbiAgICAgICAgfSAvLyBTZWUgIzczOCwgYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuXG5cbiAgICAgICAgaWYgKChwYXJlbnRUeXBlID09PSAwXG4gICAgICAgIC8qIE9iamVjdCAqL1xuICAgICAgICB8fCBwYXJlbnRUeXBlID09PSAxXG4gICAgICAgIC8qIEFycmF5ICovXG4gICAgICAgICkgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKSkgZGllKDI0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgcCA9PT0gXCJwcm90b3R5cGVcIikgZGllKDI0KTtcbiAgICAgICAgYmFzZSA9IGdldChiYXNlLCBwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSBkaWUoMTUsIHBhdGguam9pbihcIi9cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgdmFyIHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7IC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblxuICAgICAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFJFUExBQ0U6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgICAgIGNhc2UgM1xuICAgICAgICAgICAgLyogU2V0ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIGRpZSgxNik7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgZm9sbG93aW5nIGFkZCBvciByZW1vdmUgb3BzLCB0aGUgdmFsdWUgZmllbGQgaW5zaWRlIHRoZSBwYXRjaCB3aWxsIGFsc28gYmUgbW9kaWZ5ZWRcbiAgICAgICAgICAgICAgLy8gc28gd2UgdXNlIHZhbHVlIGZyb20gdGhlIGNsb25lZCBwYXRjaFxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBBREQ6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDFcbiAgICAgICAgICAgIC8qIEFycmF5ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgM1xuICAgICAgICAgICAgLyogU2V0ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRU1PVkU6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDFcbiAgICAgICAgICAgIC8qIEFycmF5ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuXG4gICAgICAgICAgICBjYXNlIDJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgY2FzZSAzXG4gICAgICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBiYXNlW2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGllKDE3LCBvcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmo7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XG4gICAgaWYgKGlzTWFwKG9iaikpIHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSkubWFwKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIGsgPSBfcmVmM1swXSxcbiAgICAgICAgICB2ID0gX3JlZjNbMV07XG4gICAgICByZXR1cm4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildO1xuICAgIH0pKTtcbiAgICBpZiAoaXNTZXQob2JqKSkgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShvYmopLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKSk7XG4gICAgdmFyIGNsb25lZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzKG9iaiwgRFJBRlRBQkxFKSkgY2xvbmVkW0RSQUZUQUJMRV0gPSBvYmpbRFJBRlRBQkxFXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob2JqKSB7XG4gICAgaWYgKGlzRHJhZnQob2JqKSkge1xuICAgICAgcmV0dXJuIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKTtcbiAgICB9IGVsc2UgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcbiAgICBhcHBseVBhdGNoZXNfOiBhcHBseVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc186IGdlbmVyYXRlUGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfOiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cbiAgfSk7XG59XG5cbi8vIHR5cGVzIG9ubHkhXG5mdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgIF9fcHJvdG9fXzogW11cbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07IC8vIFVnbHkgaGFjayB0byByZXNvbHZlICM1MDIgYW5kIGluaGVyaXQgYnVpbHQgaW4gTWFwIC8gU2V0XG5cblxuICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9ICggLy8gQHRzLWlnbm9yZVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH1cblxuICB2YXIgRHJhZnRNYXAgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWZ0TWFwLCBfc3VwZXIpOyAvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblxuXG4gICAgZnVuY3Rpb24gRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMlxuICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHVuZGVmaW5lZCxcbiAgICAgICAgYXNzaWduZWRfOiB1bmRlZmluZWQsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBEcmFmdE1hcC5wcm90b3R5cGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwic2l6ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICAgIH0gLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAvLyBjb25maWd1cmFibGU6IHRydWVcblxuICAgIH0pO1xuXG4gICAgcC5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgICB9O1xuXG4gICAgcC5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAoIWxhdGVzdChzdGF0ZSkuaGFzKGtleSkgfHwgbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBwLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcblxuICAgICAgaWYgKHN0YXRlLmJhc2VfLmhhcyhrZXkpKSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uZGVsZXRlKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmNvcHlfLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZWFjaChzdGF0ZS5iYXNlXywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGtleSwgX21hcCkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIF90aGlzLmdldChrZXkpLCBrZXksIF90aGlzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHZhciB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTsgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXG4gICAgICB9IC8vIGRlc3BpdGUgd2hhdCBpdCBsb29rcywgdGhpcyBjcmVhdGVzIGEgZHJhZnQgb25seSBvbmNlLCBzZWUgYWJvdmUgY29uZGl0aW9uXG5cblxuICAgICAgdmFyIGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIGRyYWZ0KTtcbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9O1xuXG4gICAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpO1xuICAgIH07XG5cbiAgICBwLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzLFxuICAgICAgICAgIF9yZWY7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudmFsdWVzKCk7XG4gICAgICB9LCBfcmVmLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICBpZiAoci5kb25lKSByZXR1cm4gcjtcblxuICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczIuZ2V0KHIudmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9LCBfcmVmO1xuICAgIH07XG5cbiAgICBwLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcyxcbiAgICAgICAgICBfcmVmMjtcblxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmVudHJpZXMoKTtcbiAgICAgIH0sIF9yZWYyLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICBpZiAoci5kb25lKSByZXR1cm4gcjtcblxuICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczMuZ2V0KHIudmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH0sIF9yZWYyO1xuICAgIH07XG5cbiAgICBwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERyYWZ0TWFwO1xuICB9KE1hcCk7XG5cbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKCk7XG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBEcmFmdFNldCA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJhZnRTZXQsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXG5cbiAgICBmdW5jdGlvbiBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCkge1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAzXG4gICAgICAgIC8qIFNldCAqL1xuICAgICAgICAsXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5XzogdW5kZWZpbmVkLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGRyYWZ0c186IG5ldyBNYXAoKSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlLFxuICAgICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBEcmFmdFNldC5wcm90b3R5cGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwic2l6ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICAgIH0gLy8gZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIH0pO1xuXG4gICAgcC5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTsgLy8gYml0IG9mIHRyaWNrZXJ5IGhlcmUsIHRvIGJlIGFibGUgdG8gcmVjb2duaXplIGJvdGggdGhlIHZhbHVlLCBhbmQgdGhlIGRyYWZ0IG9mIGl0cyB2YWx1ZVxuXG4gICAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcC5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBwLmRlbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpID8gc3RhdGUuY29weV8uZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkgOlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgcC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8udmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHAuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZW50cmllcygpO1xuICAgIH07XG5cbiAgICBwLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9O1xuXG4gICAgcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9O1xuXG4gICAgcC5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIERyYWZ0U2V0O1xuICB9KFNldCk7XG5cbiAgZnVuY3Rpb24gcHJveHlTZXRfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVNldENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICAvLyBjcmVhdGUgZHJhZnRzIGZvciBhbGwgZW50cmllcyB0byBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXJcbiAgICAgIHN0YXRlLmNvcHlfID0gbmV3IFNldCgpO1xuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KTtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQoZHJhZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZVxuICAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovXG4gICkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcbiAgfVxuXG4gIGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwge1xuICAgIHByb3h5TWFwXzogcHJveHlNYXBfLFxuICAgIHByb3h5U2V0XzogcHJveHlTZXRfXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmFibGVBbGxQbHVnaW5zKCkge1xuICBlbmFibGVFUzUoKTtcbiAgZW5hYmxlTWFwU2V0KCk7XG4gIGVuYWJsZVBhdGNoZXMoKTtcbn1cblxudmFyIGltbWVyID1cbi8qI19fUFVSRV9fKi9cbm5ldyBJbW1lcigpO1xuLyoqXHJcbiAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxyXG4gKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcclxuICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXHJcbiAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXHJcbiAqXHJcbiAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxyXG4gKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxyXG4gKlxyXG4gKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcclxuICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9kdWNlciAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxyXG4gKi9cblxudmFyIHByb2R1Y2UgPSBpbW1lci5wcm9kdWNlO1xuLyoqXHJcbiAqIExpa2UgYHByb2R1Y2VgLCBidXQgYHByb2R1Y2VXaXRoUGF0Y2hlc2AgYWx3YXlzIHJldHVybnMgYSB0dXBsZVxyXG4gKiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gKGluc3RlYWQgb2YganVzdCB0aGUgbmV4dCBzdGF0ZSlcclxuICovXG5cbnZhciBwcm9kdWNlV2l0aFBhdGNoZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXHJcbiAqXHJcbiAqIEFsd2F5cyBmcmVlemUgYnkgZGVmYXVsdCwgZXZlbiBpbiBwcm9kdWN0aW9uIG1vZGVcclxuICovXG5cbnZhciBzZXRBdXRvRnJlZXplID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG4vKipcclxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICpcclxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAqL1xuXG52YXIgc2V0VXNlUHJveGllcyA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5zZXRVc2VQcm94aWVzLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIEFwcGx5IGFuIGFycmF5IG9mIEltbWVyIHBhdGNoZXMgdG8gdGhlIGZpcnN0IGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcHJvZHVjZXIsIHdoaWNoIG1lYW5zIGNvcHktb24td3JpdGUgaXMgaW4gZWZmZWN0LlxyXG4gKi9cblxudmFyIGFwcGx5UGF0Y2hlcyA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XG4vKipcclxuICogQ3JlYXRlIGFuIEltbWVyIGRyYWZ0IGZyb20gdGhlIGdpdmVuIGJhc2Ugc3RhdGUsIHdoaWNoIG1heSBiZSBhIGRyYWZ0IGl0c2VsZi5cclxuICogVGhlIGRyYWZ0IGNhbiBiZSBtb2RpZmllZCB1bnRpbCB5b3UgZmluYWxpemUgaXQgd2l0aCB0aGUgYGZpbmlzaERyYWZ0YCBmdW5jdGlvbi5cclxuICovXG5cbnZhciBjcmVhdGVEcmFmdCA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBGaW5hbGl6ZSBhbiBJbW1lciBkcmFmdCBmcm9tIGEgYGNyZWF0ZURyYWZ0YCBjYWxsLCByZXR1cm5pbmcgdGhlIGJhc2Ugc3RhdGVcclxuICogKGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlKSBvciBhIG1vZGlmaWVkIGNvcHkuIFRoZSBkcmFmdCBtdXN0ICpub3QqIGJlXHJcbiAqIG11dGF0ZWQgYWZ0ZXJ3YXJkcy5cclxuICpcclxuICogUGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSAybmQgYXJndW1lbnQgdG8gZ2VuZXJhdGUgSW1tZXIgcGF0Y2hlcyBiYXNlZCBvbiB0aGVcclxuICogY2hhbmdlcyB0aGF0IHdlcmUgbWFkZS5cclxuICovXG5cbnZhciBmaW5pc2hEcmFmdCA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGFuIGltbXV0YWJsZSB0eXBlXHJcbiAqIHRvIGFuIGRyYWZ0IHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3REcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhIG11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBpbW11dGFibGUgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cblxuZnVuY3Rpb24gY2FzdEltbXV0YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydHMuSW1tZXIgPSBJbW1lcjtcbmV4cG9ydHMuYXBwbHlQYXRjaGVzID0gYXBwbHlQYXRjaGVzO1xuZXhwb3J0cy5jYXN0RHJhZnQgPSBjYXN0RHJhZnQ7XG5leHBvcnRzLmNhc3RJbW11dGFibGUgPSBjYXN0SW1tdXRhYmxlO1xuZXhwb3J0cy5jcmVhdGVEcmFmdCA9IGNyZWF0ZURyYWZ0O1xuZXhwb3J0cy5jdXJyZW50ID0gY3VycmVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IHByb2R1Y2U7XG5leHBvcnRzLmVuYWJsZUFsbFBsdWdpbnMgPSBlbmFibGVBbGxQbHVnaW5zO1xuZXhwb3J0cy5lbmFibGVFUzUgPSBlbmFibGVFUzU7XG5leHBvcnRzLmVuYWJsZU1hcFNldCA9IGVuYWJsZU1hcFNldDtcbmV4cG9ydHMuZW5hYmxlUGF0Y2hlcyA9IGVuYWJsZVBhdGNoZXM7XG5leHBvcnRzLmZpbmlzaERyYWZ0ID0gZmluaXNoRHJhZnQ7XG5leHBvcnRzLmZyZWV6ZSA9IGZyZWV6ZTtcbmV4cG9ydHMuaW1tZXJhYmxlID0gRFJBRlRBQkxFO1xuZXhwb3J0cy5pc0RyYWZ0ID0gaXNEcmFmdDtcbmV4cG9ydHMuaXNEcmFmdGFibGUgPSBpc0RyYWZ0YWJsZTtcbmV4cG9ydHMubm90aGluZyA9IE5PVEhJTkc7XG5leHBvcnRzLm9yaWdpbmFsID0gb3JpZ2luYWw7XG5leHBvcnRzLnByb2R1Y2UgPSBwcm9kdWNlO1xuZXhwb3J0cy5wcm9kdWNlV2l0aFBhdGNoZXMgPSBwcm9kdWNlV2l0aFBhdGNoZXM7XG5leHBvcnRzLnNldEF1dG9GcmVlemUgPSBzZXRBdXRvRnJlZXplO1xuZXhwb3J0cy5zZXRVc2VQcm94aWVzID0gc2V0VXNlUHJveGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9yZWYiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJoYXNNYXAiLCJNYXAiLCJoYXNTZXQiLCJTZXQiLCJoYXNQcm94aWVzIiwiUHJveHkiLCJyZXZvY2FibGUiLCJSZWZsZWN0IiwiTk9USElORyIsImZvciIsIkRSQUZUQUJMRSIsIkRSQUZUX1NUQVRFIiwiaXRlcmF0b3JTeW1ib2wiLCJpdGVyYXRvciIsImVycm9ycyIsIl8iLCJkYXRhIiwicGF0aCIsIm9wIiwicGx1Z2luIiwidGhpbmciLCJkaWUiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiZSIsIm1zZyIsImFwcGx5IiwiRXJyb3IiLCJpc0RyYWZ0IiwiaXNEcmFmdGFibGUiLCJfdmFsdWUkY29uc3RydWN0b3IiLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsImNvbnN0cnVjdG9yIiwiaXNNYXAiLCJpc1NldCIsIm9iamVjdEN0b3JTdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJDdG9yIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRnVuY3Rpb24iLCJvcmlnaW5hbCIsImJhc2VfIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwidGFyZ2V0IiwicmVzIiwiZm9yRWFjaCIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVhY2giLCJpdGVyIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRBcmNodHlwZSIsImtleXMiLCJlbnRyeSIsImluZGV4Iiwic3RhdGUiLCJ0eXBlXyIsImhhcyIsInByb3AiLCJnZXQiLCJzZXQiLCJwcm9wT3JPbGRWYWx1ZSIsInQiLCJhZGQiLCJpcyIsIngiLCJ5IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJzbGljZSIsImRlc2NyaXB0b3JzIiwiaSIsImRlc2MiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJmcmVlemUiLCJkZWVwIiwiaXNGcm96ZW4iLCJjbGVhciIsImRlbGV0ZSIsImRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJ1c2VQYXRjaGVzSW5TY29wZSIsInNjb3BlIiwicGF0Y2hMaXN0ZW5lciIsInBhdGNoZXNfIiwiaW52ZXJzZVBhdGNoZXNfIiwicGF0Y2hMaXN0ZW5lcl8iLCJyZXZva2VTY29wZSIsImxlYXZlU2NvcGUiLCJyZXZva2VEcmFmdCIsImVudGVyU2NvcGUiLCJpbW1lciIsImRyYWZ0IiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsInJlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJ1bmRlZmluZWQiLCJ1c2VQcm94aWVzXyIsIndpbGxGaW5hbGl6ZUVTNV8iLCJtb2RpZmllZF8iLCJmaW5hbGl6ZSIsIm1heWJlRnJlZXplIiwiZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfIiwicm9vdFNjb3BlIiwiY2hpbGRWYWx1ZSIsImZpbmFsaXplUHJvcGVydHkiLCJzY29wZV8iLCJmaW5hbGl6ZWRfIiwiZHJhZnRfIiwicmVzdWx0RWFjaCIsImdlbmVyYXRlUGF0Y2hlc18iLCJwYXJlbnRTdGF0ZSIsInRhcmdldE9iamVjdCIsInJvb3RQYXRoIiwidGFyZ2V0SXNTZXQiLCJhc3NpZ25lZF8iLCJhdXRvRnJlZXplXyIsImNyZWF0ZVByb3h5UHJveHkiLCJwYXJlbnQiLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsIl9Qcm94eSRyZXZvY2FibGUiLCJyZXZva2UiLCJwcm94eSIsInNvdXJjZSIsInJlYWRQcm9wRnJvbVByb3RvIiwicGVlayIsInByZXBhcmVDb3B5IiwiY3JlYXRlUHJveHkiLCJnZXREZXNjcmlwdG9yRnJvbVByb3RvIiwiY3VycmVudCIsImN1cnJlbnRTdGF0ZSIsIm1hcmtDaGFuZ2VkIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxldGVQcm9wZXJ0eSIsIm93bmVyIiwic2V0UHJvdG90eXBlT2YiLCJmbiIsInBhcnNlSW50IiwiX2Rlc2MkZ2V0IiwiSW1tZXIiLCJjb25maWciLCJfdGhpcyIsInByb2R1Y2UiLCJyZWNpcGUiLCJkZWZhdWx0QmFzZSIsInNlbGYiLCJjdXJyaWVkUHJvZHVjZSIsIl90aGlzMiIsIl9yZWNpcGUiLCJoYXNFcnJvciIsIlByb21pc2UiLCJ0aGVuIiwicCIsImlwIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwiX2xlbjIiLCJfa2V5MiIsInBhdGNoZXMiLCJpbnZlcnNlUGF0Y2hlcyIsIm5leHRTdGF0ZSIsInVzZVByb3hpZXMiLCJzZXRVc2VQcm94aWVzIiwiYXV0b0ZyZWV6ZSIsInNldEF1dG9GcmVlemUiLCJfcHJvdG8iLCJjcmVhdGVEcmFmdCIsImZpbmlzaERyYWZ0IiwiYXBwbHlQYXRjaGVzIiwicGF0Y2giLCJhcHBseVBhdGNoZXNJbXBsIiwiYXBwbHlQYXRjaGVzXyIsInByb3h5TWFwXyIsInByb3h5U2V0XyIsImNyZWF0ZUVTNVByb3h5XyIsInB1c2giLCJjdXJyZW50SW1wbCIsImNvcHkiLCJhcmNoVHlwZSIsImhhc0NoYW5nZXNfIiwiY29weUhlbHBlciIsImZyb20iLCJlbmFibGVFUzUiLCJtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5IiwibWFya0NoYW5nZXNTd2VlcCIsImNyZWF0ZUVTNURyYWZ0IiwicHJveHlQcm9wZXJ0eSIsIl9kZXNjcmlwdG9ycyIsIl9pIiwiYXNzZXJ0VW5yZXZva2VkIiwiZHJhZnRzIiwiaGFzQXJyYXlDaGFuZ2VzIiwiaGFzT2JqZWN0Q2hhbmdlcyIsIm9iamVjdCIsIl9pMiIsIm1pbiIsIk1hdGgiLCJfaTMiLCJiYXNlVmFsdWUiLCJfc3RhdGUiLCJiYXNlSXNEcmFmdCIsImRlc2NyaXB0b3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5hYmxlUGF0Y2hlcyIsIlJFUExBQ0UiLCJBREQiLCJSRU1PVkUiLCJiYXNlUGF0aCIsImdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZCIsImdlbmVyYXRlQXJyYXlQYXRjaGVzIiwiZ2VuZXJhdGVTZXRQYXRjaGVzIiwiX3JlZjIiLCJjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZCIsIl9wYXRoIiwiYXNzaWduZWRWYWx1ZSIsIm9yaWdWYWx1ZSIsInVuc2hpZnQiLCJyZXBsYWNlbWVudCIsInBhcmVudFR5cGUiLCJqb2luIiwidHlwZSIsImRlZXBDbG9uZVBhdGNoVmFsdWUiLCJzcGxpY2UiLCJtYXAiLCJlbnRyaWVzIiwiX3JlZjMiLCJrIiwidiIsImNsb25lZCIsImVuYWJsZU1hcFNldCIsIl9leHRlbmRTdGF0aWNzIiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiX19wcm90b19fIiwiX19leHRlbmRzIiwiX18iLCJEcmFmdE1hcCIsIl9zdXBlciIsInNpemUiLCJwcmVwYXJlTWFwQ29weSIsImNiIiwidGhpc0FyZyIsIl92YWx1ZSIsIl9tYXAiLCJ2YWx1ZXMiLCJuZXh0IiwiciIsImRvbmUiLCJfdGhpczMiLCJEcmFmdFNldCIsInByZXBhcmVTZXRDb3B5IiwiZW5hYmxlQWxsUGx1Z2lucyIsImJpbmQiLCJjYXN0RHJhZnQiLCJjYXN0SW1tdXRhYmxlIiwiZGVmYXVsdCIsImltbWVyYWJsZSIsIm5vdGhpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.cjs.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/immer/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/immer/dist/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"(ssr)/./node_modules/immer/dist/immer.cjs.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFDQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxrSUFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmllbmRib29rLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW5kZXguanM/NzdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW1tZXIuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/immer/dist/immer.esm.mjs":
/*!***********************************************!*\
  !*** ./node_modules/immer/dist/immer.esm.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ un),\n/* harmony export */   applyPatches: () => (/* binding */ pn),\n/* harmony export */   castDraft: () => (/* binding */ K),\n/* harmony export */   castImmutable: () => (/* binding */ $),\n/* harmony export */   createDraft: () => (/* binding */ ln),\n/* harmony export */   current: () => (/* binding */ R),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   enableAllPlugins: () => (/* binding */ J),\n/* harmony export */   enableES5: () => (/* binding */ F),\n/* harmony export */   enableMapSet: () => (/* binding */ C),\n/* harmony export */   enablePatches: () => (/* binding */ T),\n/* harmony export */   finishDraft: () => (/* binding */ dn),\n/* harmony export */   freeze: () => (/* binding */ d),\n/* harmony export */   immerable: () => (/* binding */ L),\n/* harmony export */   isDraft: () => (/* binding */ r),\n/* harmony export */   isDraftable: () => (/* binding */ t),\n/* harmony export */   nothing: () => (/* binding */ H),\n/* harmony export */   original: () => (/* binding */ e),\n/* harmony export */   produce: () => (/* binding */ fn),\n/* harmony export */   produceWithPatches: () => (/* binding */ cn),\n/* harmony export */   setAutoFreeze: () => (/* binding */ sn),\n/* harmony export */   setUseProxies: () => (/* binding */ vn)\n/* harmony export */ });\nfunction n(n) {\n    for(var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++)t[e - 1] = arguments[e];\n    if (true) {\n        var i = Y[n], o = i ? \"function\" == typeof i ? i.apply(null, t) : i : \"unknown error nr: \" + n;\n        throw Error(\"[Immer] \" + o);\n    }\n    throw Error(\"[Immer] minified error nr: \" + n + (t.length ? \" \" + t.map(function(n) {\n        return \"'\" + n + \"'\";\n    }).join(\",\") : \"\") + \". Find the full error at: https://bit.ly/3cXEKWf\");\n}\nfunction r(n) {\n    return !!n && !!n[Q];\n}\nfunction t(n) {\n    var r;\n    return !!n && (function(n) {\n        if (!n || \"object\" != typeof n) return !1;\n        var r = Object.getPrototypeOf(n);\n        if (null === r) return !0;\n        var t = Object.hasOwnProperty.call(r, \"constructor\") && r.constructor;\n        return t === Object || \"function\" == typeof t && Function.toString.call(t) === Z;\n    }(n) || Array.isArray(n) || !!n[L] || !!(null === (r = n.constructor) || void 0 === r ? void 0 : r[L]) || s(n) || v(n));\n}\nfunction e(t) {\n    return r(t) || n(23, t), t[Q].t;\n}\nfunction i(n, r, t) {\n    void 0 === t && (t = !1), 0 === o(n) ? (t ? Object.keys : nn)(n).forEach(function(e) {\n        t && \"symbol\" == typeof e || r(e, n[e], n);\n    }) : n.forEach(function(t, e) {\n        return r(e, t, n);\n    });\n}\nfunction o(n) {\n    var r = n[Q];\n    return r ? r.i > 3 ? r.i - 4 : r.i : Array.isArray(n) ? 1 : s(n) ? 2 : v(n) ? 3 : 0;\n}\nfunction u(n, r) {\n    return 2 === o(n) ? n.has(r) : Object.prototype.hasOwnProperty.call(n, r);\n}\nfunction a(n, r) {\n    return 2 === o(n) ? n.get(r) : n[r];\n}\nfunction f(n, r, t) {\n    var e = o(n);\n    2 === e ? n.set(r, t) : 3 === e ? n.add(t) : n[r] = t;\n}\nfunction c(n, r) {\n    return n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r;\n}\nfunction s(n) {\n    return X && n instanceof Map;\n}\nfunction v(n) {\n    return q && n instanceof Set;\n}\nfunction p(n) {\n    return n.o || n.t;\n}\nfunction l(n) {\n    if (Array.isArray(n)) return Array.prototype.slice.call(n);\n    var r = rn(n);\n    delete r[Q];\n    for(var t = nn(r), e = 0; e < t.length; e++){\n        var i = t[e], o = r[i];\n        !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[i] = {\n            configurable: !0,\n            writable: !0,\n            enumerable: o.enumerable,\n            value: n[i]\n        });\n    }\n    return Object.create(Object.getPrototypeOf(n), r);\n}\nfunction d(n, e) {\n    return void 0 === e && (e = !1), y(n) || r(n) || !t(n) || (o(n) > 1 && (n.set = n.add = n.clear = n.delete = h), Object.freeze(n), e && i(n, function(n, r) {\n        return d(r, !0);\n    }, !0)), n;\n}\nfunction h() {\n    n(2);\n}\nfunction y(n) {\n    return null == n || \"object\" != typeof n || Object.isFrozen(n);\n}\nfunction b(r) {\n    var t = tn[r];\n    return t || n(18, r), t;\n}\nfunction m(n, r) {\n    tn[n] || (tn[n] = r);\n}\nfunction _() {\n    return  false || U || n(0), U;\n}\nfunction j(n, r) {\n    r && (b(\"Patches\"), n.u = [], n.s = [], n.v = r);\n}\nfunction g(n) {\n    O(n), n.p.forEach(S), n.p = null;\n}\nfunction O(n) {\n    n === U && (U = n.l);\n}\nfunction w(n) {\n    return U = {\n        p: [],\n        l: U,\n        h: n,\n        m: !0,\n        _: 0\n    };\n}\nfunction S(n) {\n    var r = n[Q];\n    0 === r.i || 1 === r.i ? r.j() : r.g = !0;\n}\nfunction P(r, e) {\n    e._ = e.p.length;\n    var i = e.p[0], o = void 0 !== r && r !== i;\n    return e.h.O || b(\"ES5\").S(e, r, o), o ? (i[Q].P && (g(e), n(4)), t(r) && (r = M(e, r), e.l || x(e, r)), e.u && b(\"Patches\").M(i[Q].t, r, e.u, e.s)) : r = M(e, i, []), g(e), e.u && e.v(e.u, e.s), r !== H ? r : void 0;\n}\nfunction M(n, r, t) {\n    if (y(r)) return r;\n    var e = r[Q];\n    if (!e) return i(r, function(i, o) {\n        return A(n, e, r, i, o, t);\n    }, !0), r;\n    if (e.A !== n) return r;\n    if (!e.P) return x(n, e.t, !0), e.t;\n    if (!e.I) {\n        e.I = !0, e.A._--;\n        var o = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u = o, a = !1;\n        3 === e.i && (u = new Set(o), o.clear(), a = !0), i(u, function(r, i) {\n            return A(n, e, o, r, i, t, a);\n        }), x(n, o, !1), t && n.u && b(\"Patches\").N(e, t, n.u, n.s);\n    }\n    return e.o;\n}\nfunction A(e, i, o, a, c, s, v) {\n    if ( true && c === o && n(5), r(c)) {\n        var p = M(e, c, s && i && 3 !== i.i && !u(i.R, a) ? s.concat(a) : void 0);\n        if (f(o, a, p), !r(p)) return;\n        e.m = !1;\n    } else v && o.add(c);\n    if (t(c) && !y(c)) {\n        if (!e.h.D && e._ < 1) return;\n        M(e, c), i && i.A.l || x(e, c);\n    }\n}\nfunction x(n, r, t) {\n    void 0 === t && (t = !1), !n.l && n.h.D && n.m && d(r, t);\n}\nfunction z(n, r) {\n    var t = n[Q];\n    return (t ? p(t) : n)[r];\n}\nfunction I(n, r) {\n    if (r in n) for(var t = Object.getPrototypeOf(n); t;){\n        var e = Object.getOwnPropertyDescriptor(t, r);\n        if (e) return e;\n        t = Object.getPrototypeOf(t);\n    }\n}\nfunction k(n) {\n    n.P || (n.P = !0, n.l && k(n.l));\n}\nfunction E(n) {\n    n.o || (n.o = l(n.t));\n}\nfunction N(n, r, t) {\n    var e = s(r) ? b(\"MapSet\").F(r, t) : v(r) ? b(\"MapSet\").T(r, t) : n.O ? function(n, r) {\n        var t = Array.isArray(n), e = {\n            i: t ? 1 : 0,\n            A: r ? r.A : _(),\n            P: !1,\n            I: !1,\n            R: {},\n            l: r,\n            t: n,\n            k: null,\n            o: null,\n            j: null,\n            C: !1\n        }, i = e, o = en;\n        t && (i = [\n            e\n        ], o = on);\n        var u = Proxy.revocable(i, o), a = u.revoke, f = u.proxy;\n        return e.k = f, e.j = a, f;\n    }(r, t) : b(\"ES5\").J(r, t);\n    return (t ? t.A : _()).p.push(e), e;\n}\nfunction R(e) {\n    return r(e) || n(22, e), function n(r) {\n        if (!t(r)) return r;\n        var e, u = r[Q], c = o(r);\n        if (u) {\n            if (!u.P && (u.i < 4 || !b(\"ES5\").K(u))) return u.t;\n            u.I = !0, e = D(r, c), u.I = !1;\n        } else e = D(r, c);\n        return i(e, function(r, t) {\n            u && a(u.t, r) === t || f(e, r, n(t));\n        }), 3 === c ? new Set(e) : e;\n    }(e);\n}\nfunction D(n, r) {\n    switch(r){\n        case 2:\n            return new Map(n);\n        case 3:\n            return Array.from(n);\n    }\n    return l(n);\n}\nfunction F() {\n    function t(n, r) {\n        var t = s[n];\n        return t ? t.enumerable = r : s[n] = t = {\n            configurable: !0,\n            enumerable: r,\n            get: function() {\n                var r = this[Q];\n                return  true && f(r), en.get(r, n);\n            },\n            set: function(r) {\n                var t = this[Q];\n                 true && f(t), en.set(t, n, r);\n            }\n        }, t;\n    }\n    function e(n) {\n        for(var r = n.length - 1; r >= 0; r--){\n            var t = n[r][Q];\n            if (!t.P) switch(t.i){\n                case 5:\n                    a(t) && k(t);\n                    break;\n                case 4:\n                    o(t) && k(t);\n            }\n        }\n    }\n    function o(n) {\n        for(var r = n.t, t = n.k, e = nn(t), i = e.length - 1; i >= 0; i--){\n            var o = e[i];\n            if (o !== Q) {\n                var a = r[o];\n                if (void 0 === a && !u(r, o)) return !0;\n                var f = t[o], s = f && f[Q];\n                if (s ? s.t !== a : !c(f, a)) return !0;\n            }\n        }\n        var v = !!r[Q];\n        return e.length !== nn(r).length + (v ? 0 : 1);\n    }\n    function a(n) {\n        var r = n.k;\n        if (r.length !== n.t.length) return !0;\n        var t = Object.getOwnPropertyDescriptor(r, r.length - 1);\n        if (t && !t.get) return !0;\n        for(var e = 0; e < r.length; e++)if (!r.hasOwnProperty(e)) return !0;\n        return !1;\n    }\n    function f(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var s = {};\n    m(\"ES5\", {\n        J: function(n, r) {\n            var e = Array.isArray(n), i = function(n, r) {\n                if (n) {\n                    for(var e = Array(r.length), i = 0; i < r.length; i++)Object.defineProperty(e, \"\" + i, t(i, !0));\n                    return e;\n                }\n                var o = rn(r);\n                delete o[Q];\n                for(var u = nn(o), a = 0; a < u.length; a++){\n                    var f = u[a];\n                    o[f] = t(f, n || !!o[f].enumerable);\n                }\n                return Object.create(Object.getPrototypeOf(r), o);\n            }(e, n), o = {\n                i: e ? 5 : 4,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                R: {},\n                l: r,\n                t: n,\n                k: i,\n                o: null,\n                g: !1,\n                C: !1\n            };\n            return Object.defineProperty(i, Q, {\n                value: o,\n                writable: !0\n            }), i;\n        },\n        S: function(n, t, o) {\n            o ? r(t) && t[Q].A === n && e(n.p) : (n.u && function n(r) {\n                if (r && \"object\" == typeof r) {\n                    var t = r[Q];\n                    if (t) {\n                        var e = t.t, o = t.k, f = t.R, c = t.i;\n                        if (4 === c) i(o, function(r) {\n                            r !== Q && (void 0 !== e[r] || u(e, r) ? f[r] || n(o[r]) : (f[r] = !0, k(t)));\n                        }), i(e, function(n) {\n                            void 0 !== o[n] || u(o, n) || (f[n] = !1, k(t));\n                        });\n                        else if (5 === c) {\n                            if (a(t) && (k(t), f.length = !0), o.length < e.length) for(var s = o.length; s < e.length; s++)f[s] = !1;\n                            else for(var v = e.length; v < o.length; v++)f[v] = !0;\n                            for(var p = Math.min(o.length, e.length), l = 0; l < p; l++)o.hasOwnProperty(l) || (f[l] = !0), void 0 === f[l] && n(o[l]);\n                        }\n                    }\n                }\n            }(n.p[0]), e(n.p));\n        },\n        K: function(n) {\n            return 4 === n.i ? o(n) : a(n);\n        }\n    });\n}\nfunction T() {\n    function e(n) {\n        if (!t(n)) return n;\n        if (Array.isArray(n)) return n.map(e);\n        if (s(n)) return new Map(Array.from(n.entries()).map(function(n) {\n            return [\n                n[0],\n                e(n[1])\n            ];\n        }));\n        if (v(n)) return new Set(Array.from(n).map(e));\n        var r = Object.create(Object.getPrototypeOf(n));\n        for(var i in n)r[i] = e(n[i]);\n        return u(n, L) && (r[L] = n[L]), r;\n    }\n    function f(n) {\n        return r(n) ? e(n) : n;\n    }\n    var c = \"add\";\n    m(\"Patches\", {\n        $: function(r, t) {\n            return t.forEach(function(t) {\n                for(var i = t.path, u = t.op, f = r, s = 0; s < i.length - 1; s++){\n                    var v = o(f), p = i[s];\n                    \"string\" != typeof p && \"number\" != typeof p && (p = \"\" + p), 0 !== v && 1 !== v || \"__proto__\" !== p && \"constructor\" !== p || n(24), \"function\" == typeof f && \"prototype\" === p && n(24), \"object\" != typeof (f = a(f, p)) && n(15, i.join(\"/\"));\n                }\n                var l = o(f), d = e(t.value), h = i[i.length - 1];\n                switch(u){\n                    case \"replace\":\n                        switch(l){\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                n(16);\n                            default:\n                                return f[h] = d;\n                        }\n                    case c:\n                        switch(l){\n                            case 1:\n                                return \"-\" === h ? f.push(d) : f.splice(h, 0, d);\n                            case 2:\n                                return f.set(h, d);\n                            case 3:\n                                return f.add(d);\n                            default:\n                                return f[h] = d;\n                        }\n                    case \"remove\":\n                        switch(l){\n                            case 1:\n                                return f.splice(h, 1);\n                            case 2:\n                                return f.delete(h);\n                            case 3:\n                                return f.delete(t.value);\n                            default:\n                                return delete f[h];\n                        }\n                    default:\n                        n(17, u);\n                }\n            }), r;\n        },\n        N: function(n, r, t, e) {\n            switch(n.i){\n                case 0:\n                case 4:\n                case 2:\n                    return function(n, r, t, e) {\n                        var o = n.t, s = n.o;\n                        i(n.R, function(n, i) {\n                            var v = a(o, n), p = a(s, n), l = i ? u(o, n) ? \"replace\" : c : \"remove\";\n                            if (v !== p || \"replace\" !== l) {\n                                var d = r.concat(n);\n                                t.push(\"remove\" === l ? {\n                                    op: l,\n                                    path: d\n                                } : {\n                                    op: l,\n                                    path: d,\n                                    value: p\n                                }), e.push(l === c ? {\n                                    op: \"remove\",\n                                    path: d\n                                } : \"remove\" === l ? {\n                                    op: c,\n                                    path: d,\n                                    value: f(v)\n                                } : {\n                                    op: \"replace\",\n                                    path: d,\n                                    value: f(v)\n                                });\n                            }\n                        });\n                    }(n, r, t, e);\n                case 5:\n                case 1:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.R, u = n.o;\n                        if (u.length < i.length) {\n                            var a = [\n                                u,\n                                i\n                            ];\n                            i = a[0], u = a[1];\n                            var s = [\n                                e,\n                                t\n                            ];\n                            t = s[0], e = s[1];\n                        }\n                        for(var v = 0; v < i.length; v++)if (o[v] && u[v] !== i[v]) {\n                            var p = r.concat([\n                                v\n                            ]);\n                            t.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(u[v])\n                            }), e.push({\n                                op: \"replace\",\n                                path: p,\n                                value: f(i[v])\n                            });\n                        }\n                        for(var l = i.length; l < u.length; l++){\n                            var d = r.concat([\n                                l\n                            ]);\n                            t.push({\n                                op: c,\n                                path: d,\n                                value: f(u[l])\n                            });\n                        }\n                        i.length < u.length && e.push({\n                            op: \"replace\",\n                            path: r.concat([\n                                \"length\"\n                            ]),\n                            value: i.length\n                        });\n                    }(n, r, t, e);\n                case 3:\n                    return function(n, r, t, e) {\n                        var i = n.t, o = n.o, u = 0;\n                        i.forEach(function(n) {\n                            if (!o.has(n)) {\n                                var i = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: \"remove\",\n                                    path: i,\n                                    value: n\n                                }), e.unshift({\n                                    op: c,\n                                    path: i,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        }), u = 0, o.forEach(function(n) {\n                            if (!i.has(n)) {\n                                var o = r.concat([\n                                    u\n                                ]);\n                                t.push({\n                                    op: c,\n                                    path: o,\n                                    value: n\n                                }), e.unshift({\n                                    op: \"remove\",\n                                    path: o,\n                                    value: n\n                                });\n                            }\n                            u++;\n                        });\n                    }(n, r, t, e);\n            }\n        },\n        M: function(n, r, t, e) {\n            t.push({\n                op: \"replace\",\n                path: [],\n                value: r === H ? void 0 : r\n            }), e.push({\n                op: \"replace\",\n                path: [],\n                value: n\n            });\n        }\n    });\n}\nfunction C() {\n    function r(n, r) {\n        function t() {\n            this.constructor = n;\n        }\n        a(n, r), n.prototype = (t.prototype = r.prototype, new t);\n    }\n    function e(n) {\n        n.o || (n.R = new Map, n.o = new Map(n.t));\n    }\n    function o(n) {\n        n.o || (n.o = new Set, n.t.forEach(function(r) {\n            if (t(r)) {\n                var e = N(n.A.h, r, n);\n                n.p.set(r, e), n.o.add(e);\n            } else n.o.add(r);\n        }));\n    }\n    function u(r) {\n        r.g && n(3, JSON.stringify(p(r)));\n    }\n    var a = function(n, r) {\n        return (a = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(n, r) {\n            n.__proto__ = r;\n        } || function(n, r) {\n            for(var t in r)r.hasOwnProperty(t) && (n[t] = r[t]);\n        })(n, r);\n    }, f = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 2,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                R: void 0,\n                t: n,\n                k: this,\n                C: !1,\n                g: !1\n            }, this;\n        }\n        r(n, Map);\n        var o = n.prototype;\n        return Object.defineProperty(o, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), o.has = function(n) {\n            return p(this[Q]).has(n);\n        }, o.set = function(n, r) {\n            var t = this[Q];\n            return u(t), p(t).has(n) && p(t).get(n) === r || (e(t), k(t), t.R.set(n, !0), t.o.set(n, r), t.R.set(n, !0)), this;\n        }, o.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), e(r), k(r), r.t.has(n) ? r.R.set(n, !1) : r.R.delete(n), r.o.delete(n), !0;\n        }, o.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (e(n), k(n), n.R = new Map, i(n.t, function(r) {\n                n.R.set(r, !1);\n            }), n.o.clear());\n        }, o.forEach = function(n, r) {\n            var t = this;\n            p(this[Q]).forEach(function(e, i) {\n                n.call(r, t.get(i), i, t);\n            });\n        }, o.get = function(n) {\n            var r = this[Q];\n            u(r);\n            var i = p(r).get(n);\n            if (r.I || !t(i)) return i;\n            if (i !== r.t.get(n)) return i;\n            var o = N(r.A.h, i, r);\n            return e(r), r.o.set(n, o), o;\n        }, o.keys = function() {\n            return p(this[Q]).keys();\n        }, o.values = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.values();\n            }, n.next = function() {\n                var n = t.next();\n                return n.done ? n : {\n                    done: !1,\n                    value: r.get(n.value)\n                };\n            }, n;\n        }, o.entries = function() {\n            var n, r = this, t = this.keys();\n            return (n = {})[V] = function() {\n                return r.entries();\n            }, n.next = function() {\n                var n = t.next();\n                if (n.done) return n;\n                var e = r.get(n.value);\n                return {\n                    done: !1,\n                    value: [\n                        n.value,\n                        e\n                    ]\n                };\n            }, n;\n        }, o[V] = function() {\n            return this.entries();\n        }, n;\n    }(), c = function() {\n        function n(n, r) {\n            return this[Q] = {\n                i: 3,\n                l: r,\n                A: r ? r.A : _(),\n                P: !1,\n                I: !1,\n                o: void 0,\n                t: n,\n                k: this,\n                p: new Map,\n                g: !1,\n                C: !1\n            }, this;\n        }\n        r(n, Set);\n        var t = n.prototype;\n        return Object.defineProperty(t, \"size\", {\n            get: function() {\n                return p(this[Q]).size;\n            }\n        }), t.has = function(n) {\n            var r = this[Q];\n            return u(r), r.o ? !!r.o.has(n) || !(!r.p.has(n) || !r.o.has(r.p.get(n))) : r.t.has(n);\n        }, t.add = function(n) {\n            var r = this[Q];\n            return u(r), this.has(n) || (o(r), k(r), r.o.add(n)), this;\n        }, t.delete = function(n) {\n            if (!this.has(n)) return !1;\n            var r = this[Q];\n            return u(r), o(r), k(r), r.o.delete(n) || !!r.p.has(n) && r.o.delete(r.p.get(n));\n        }, t.clear = function() {\n            var n = this[Q];\n            u(n), p(n).size && (o(n), k(n), n.o.clear());\n        }, t.values = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.values();\n        }, t.entries = function() {\n            var n = this[Q];\n            return u(n), o(n), n.o.entries();\n        }, t.keys = function() {\n            return this.values();\n        }, t[V] = function() {\n            return this.values();\n        }, t.forEach = function(n, r) {\n            for(var t = this.values(), e = t.next(); !e.done;)n.call(r, e.value, e.value, this), e = t.next();\n        }, n;\n    }();\n    m(\"MapSet\", {\n        F: function(n, r) {\n            return new f(n, r);\n        },\n        T: function(n, r) {\n            return new c(n, r);\n        }\n    });\n}\nfunction J() {\n    F(), C(), T();\n}\nfunction K(n) {\n    return n;\n}\nfunction $(n) {\n    return n;\n}\nvar G, U, W = \"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol(\"x\"), X = \"undefined\" != typeof Map, q = \"undefined\" != typeof Set, B = \"undefined\" != typeof Proxy && void 0 !== Proxy.revocable && \"undefined\" != typeof Reflect, H = W ? Symbol.for(\"immer-nothing\") : ((G = {})[\"immer-nothing\"] = !0, G), L = W ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\", Q = W ? Symbol.for(\"immer-state\") : \"__$immer_state\", V = \"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\", Y = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function(n) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + n;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function(n) {\n        return \"Cannot apply patch, path doesn't resolve: \" + n;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function(n) {\n        return \"Unsupported patch operation: \" + n;\n    },\n    18: function(n) {\n        return \"The plugin for '\" + n + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + n + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function(n) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + n + \"'\";\n    },\n    22: function(n) {\n        return \"'current' expects a draft, got: \" + n;\n    },\n    23: function(n) {\n        return \"'original' expects a draft, got: \" + n;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n}, Z = \"\" + Object.prototype.constructor, nn = \"undefined\" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n) {\n    return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));\n} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n) {\n    var r = {};\n    return nn(n).forEach(function(t) {\n        r[t] = Object.getOwnPropertyDescriptor(n, t);\n    }), r;\n}, tn = {}, en = {\n    get: function(n, r) {\n        if (r === Q) return n;\n        var e = p(n);\n        if (!u(e, r)) return function(n, r, t) {\n            var e, i = I(r, t);\n            return i ? \"value\" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;\n        }(n, e, r);\n        var i = e[r];\n        return n.I || !t(i) ? i : i === z(n.t, r) ? (E(n), n.o[r] = N(n.A.h, i, n)) : i;\n    },\n    has: function(n, r) {\n        return r in p(n);\n    },\n    ownKeys: function(n) {\n        return Reflect.ownKeys(p(n));\n    },\n    set: function(n, r, t) {\n        var e = I(p(n), r);\n        if (null == e ? void 0 : e.set) return e.set.call(n.k, t), !0;\n        if (!n.P) {\n            var i = z(p(n), r), o = null == i ? void 0 : i[Q];\n            if (o && o.t === t) return n.o[r] = t, n.R[r] = !1, !0;\n            if (c(t, i) && (void 0 !== t || u(n.t, r))) return !0;\n            E(n), k(n);\n        }\n        return n.o[r] === t && (void 0 !== t || r in n.o) || Number.isNaN(t) && Number.isNaN(n.o[r]) || (n.o[r] = t, n.R[r] = !0), !0;\n    },\n    deleteProperty: function(n, r) {\n        return void 0 !== z(n.t, r) || r in n.t ? (n.R[r] = !1, E(n), k(n)) : delete n.R[r], n.o && delete n.o[r], !0;\n    },\n    getOwnPropertyDescriptor: function(n, r) {\n        var t = p(n), e = Reflect.getOwnPropertyDescriptor(t, r);\n        return e ? {\n            writable: !0,\n            configurable: 1 !== n.i || \"length\" !== r,\n            enumerable: e.enumerable,\n            value: t[r]\n        } : e;\n    },\n    defineProperty: function() {\n        n(11);\n    },\n    getPrototypeOf: function(n) {\n        return Object.getPrototypeOf(n.t);\n    },\n    setPrototypeOf: function() {\n        n(12);\n    }\n}, on = {};\ni(en, function(n, r) {\n    on[n] = function() {\n        return arguments[0] = arguments[0][0], r.apply(this, arguments);\n    };\n}), on.deleteProperty = function(r, t) {\n    return  true && isNaN(parseInt(t)) && n(13), on.set.call(this, r, t, void 0);\n}, on.set = function(r, t, e) {\n    return  true && \"length\" !== t && isNaN(parseInt(t)) && n(14), en.set.call(this, r[0], t, e, r[0]);\n};\nvar un = function() {\n    function e(r) {\n        var e = this;\n        this.O = B, this.D = !0, this.produce = function(r, i, o) {\n            if (\"function\" == typeof r && \"function\" != typeof i) {\n                var u = i;\n                i = r;\n                var a = e;\n                return function(n) {\n                    var r = this;\n                    void 0 === n && (n = u);\n                    for(var t = arguments.length, e = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)e[o - 1] = arguments[o];\n                    return a.produce(n, function(n) {\n                        var t;\n                        return (t = i).call.apply(t, [\n                            r,\n                            n\n                        ].concat(e));\n                    });\n                };\n            }\n            var f;\n            if (\"function\" != typeof i && n(6), void 0 !== o && \"function\" != typeof o && n(7), t(r)) {\n                var c = w(e), s = N(e, r, void 0), v = !0;\n                try {\n                    f = i(s), v = !1;\n                } finally{\n                    v ? g(c) : O(c);\n                }\n                return \"undefined\" != typeof Promise && f instanceof Promise ? f.then(function(n) {\n                    return j(c, o), P(n, c);\n                }, function(n) {\n                    throw g(c), n;\n                }) : (j(c, o), P(f, c));\n            }\n            if (!r || \"object\" != typeof r) {\n                if (void 0 === (f = i(r)) && (f = r), f === H && (f = void 0), e.D && d(f, !0), o) {\n                    var p = [], l = [];\n                    b(\"Patches\").M(r, f, p, l), o(p, l);\n                }\n                return f;\n            }\n            n(21, r);\n        }, this.produceWithPatches = function(n, r) {\n            if (\"function\" == typeof n) return function(r) {\n                for(var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)i[o - 1] = arguments[o];\n                return e.produceWithPatches(r, function(r) {\n                    return n.apply(void 0, [\n                        r\n                    ].concat(i));\n                });\n            };\n            var t, i, o = e.produce(n, r, function(n, r) {\n                t = n, i = r;\n            });\n            return \"undefined\" != typeof Promise && o instanceof Promise ? o.then(function(n) {\n                return [\n                    n,\n                    t,\n                    i\n                ];\n            }) : [\n                o,\n                t,\n                i\n            ];\n        }, \"boolean\" == typeof (null == r ? void 0 : r.useProxies) && this.setUseProxies(r.useProxies), \"boolean\" == typeof (null == r ? void 0 : r.autoFreeze) && this.setAutoFreeze(r.autoFreeze);\n    }\n    var i = e.prototype;\n    return i.createDraft = function(e) {\n        t(e) || n(8), r(e) && (e = R(e));\n        var i = w(this), o = N(this, e, void 0);\n        return o[Q].C = !0, O(i), o;\n    }, i.finishDraft = function(r, t) {\n        var e = r && r[Q];\n         true && (e && e.C || n(9), e.I && n(10));\n        var i = e.A;\n        return j(i, t), P(void 0, i);\n    }, i.setAutoFreeze = function(n) {\n        this.D = n;\n    }, i.setUseProxies = function(r) {\n        r && !B && n(20), this.O = r;\n    }, i.applyPatches = function(n, t) {\n        var e;\n        for(e = t.length - 1; e >= 0; e--){\n            var i = t[e];\n            if (0 === i.path.length && \"replace\" === i.op) {\n                n = i.value;\n                break;\n            }\n        }\n        e > -1 && (t = t.slice(e + 1));\n        var o = b(\"Patches\").$;\n        return r(n) ? o(n, t) : this.produce(n, function(n) {\n            return o(n, t);\n        });\n    }, e;\n}(), an = new un, fn = an.produce, cn = an.produceWithPatches.bind(an), sn = an.setAutoFreeze.bind(an), vn = an.setUseProxies.bind(an), pn = an.applyPatches.bind(an), ln = an.createDraft.bind(an), dn = an.finishDraft.bind(an);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fn);\n //# sourceMappingURL=immer.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxFQUFFQSxDQUFDO0lBQUUsSUFBSSxJQUFJQyxJQUFFQyxVQUFVQyxNQUFNLEVBQUNDLElBQUVDLE1BQU1KLElBQUUsSUFBRUEsSUFBRSxJQUFFLElBQUdLLElBQUUsR0FBRUEsSUFBRUwsR0FBRUssSUFBSUYsQ0FBQyxDQUFDRSxJQUFFLEVBQUUsR0FBQ0osU0FBUyxDQUFDSSxFQUFFO0lBQUMsSUFBRyxJQUEvRixFQUFtSTtRQUFDLElBQUlDLElBQUVDLENBQUMsQ0FBQ1IsRUFBRSxFQUFDUyxJQUFFRixJQUFFLGNBQVksT0FBT0EsSUFBRUEsRUFBRUcsS0FBSyxDQUFDLE1BQUtOLEtBQUdHLElBQUUsdUJBQXFCUDtRQUFFLE1BQU1XLE1BQU0sYUFBV0Y7SUFBRTtJQUFDLE1BQU1FLE1BQU0sZ0NBQThCWCxJQUFHSSxDQUFBQSxFQUFFRCxNQUFNLEdBQUMsTUFBSUMsRUFBRVEsR0FBRyxDQUFFLFNBQVNaLENBQUM7UUFBRSxPQUFNLE1BQUlBLElBQUU7SUFBRyxHQUFJYSxJQUFJLENBQUMsT0FBSyxFQUFDLElBQUc7QUFBbUQ7QUFBQyxTQUFTWixFQUFFRCxDQUFDO0lBQUUsT0FBTSxDQUFDLENBQUNBLEtBQUcsQ0FBQyxDQUFDQSxDQUFDLENBQUNjLEVBQUU7QUFBQTtBQUFDLFNBQVNWLEVBQUVKLENBQUM7SUFBRSxJQUFJQztJQUFFLE9BQU0sQ0FBQyxDQUFDRCxLQUFJLFVBQVNBLENBQUM7UUFBRSxJQUFHLENBQUNBLEtBQUcsWUFBVSxPQUFPQSxHQUFFLE9BQU0sQ0FBQztRQUFFLElBQUlDLElBQUVjLE9BQU9DLGNBQWMsQ0FBQ2hCO1FBQUcsSUFBRyxTQUFPQyxHQUFFLE9BQU0sQ0FBQztRQUFFLElBQUlHLElBQUVXLE9BQU9FLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDakIsR0FBRSxrQkFB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QUVFO0FBQUMsS0FBSXVJLEtBQUcsSUFBSVosSUFBR2EsS0FBR0QsR0FBR1gsT0FBTyxFQUFDYSxLQUFHRixHQUFHUixrQkFBa0IsQ0FBQ1csSUFBSSxDQUFDSCxLQUFJSSxLQUFHSixHQUFHSixhQUFhLENBQUNPLElBQUksQ0FBQ0gsS0FBSUssS0FBR0wsR0FBR04sYUFBYSxDQUFDUyxJQUFJLENBQUNILEtBQUlNLEtBQUdOLEdBQUdELFlBQVksQ0FBQ0ksSUFBSSxDQUFDSCxLQUFJTyxLQUFHUCxHQUFHSCxXQUFXLENBQUNNLElBQUksQ0FBQ0gsS0FBSVEsS0FBR1IsR0FBR0YsV0FBVyxDQUFDSyxJQUFJLENBQUNIO0FBQUksaUVBQWVDLEVBQUVBLEVBQUM7QUFBdVcsQ0FDajlqQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmllbmRib29rLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIuZXNtLm1qcz8xMGJmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG4obil7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsdD1BcnJheShyPjE/ci0xOjApLGU9MTtlPHI7ZSsrKXRbZS0xXT1hcmd1bWVudHNbZV07aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVil7dmFyIGk9WVtuXSxvPWk/XCJmdW5jdGlvblwiPT10eXBlb2YgaT9pLmFwcGx5KG51bGwsdCk6aTpcInVua25vd24gZXJyb3IgbnI6IFwiK247dGhyb3cgRXJyb3IoXCJbSW1tZXJdIFwiK28pfXRocm93IEVycm9yKFwiW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogXCIrbisodC5sZW5ndGg/XCIgXCIrdC5tYXAoKGZ1bmN0aW9uKG4pe3JldHVyblwiJ1wiK24rXCInXCJ9KSkuam9pbihcIixcIik6XCJcIikrXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZcIil9ZnVuY3Rpb24gcihuKXtyZXR1cm4hIW4mJiEhbltRXX1mdW5jdGlvbiB0KG4pe3ZhciByO3JldHVybiEhbiYmKGZ1bmN0aW9uKG4pe2lmKCFufHxcIm9iamVjdFwiIT10eXBlb2YgbilyZXR1cm4hMTt2YXIgcj1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7aWYobnVsbD09PXIpcmV0dXJuITA7dmFyIHQ9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcImNvbnN0cnVjdG9yXCIpJiZyLmNvbnN0cnVjdG9yO3JldHVybiB0PT09T2JqZWN0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpPT09Wn0obil8fEFycmF5LmlzQXJyYXkobil8fCEhbltMXXx8ISEobnVsbD09PShyPW4uY29uc3RydWN0b3IpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyW0xdKXx8cyhuKXx8dihuKSl9ZnVuY3Rpb24gZSh0KXtyZXR1cm4gcih0KXx8bigyMyx0KSx0W1FdLnR9ZnVuY3Rpb24gaShuLHIsdCl7dm9pZCAwPT09dCYmKHQ9ITEpLDA9PT1vKG4pPyh0P09iamVjdC5rZXlzOm5uKShuKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0JiZcInN5bWJvbFwiPT10eXBlb2YgZXx8cihlLG5bZV0sbil9KSk6bi5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3JldHVybiByKGUsdCxuKX0pKX1mdW5jdGlvbiBvKG4pe3ZhciByPW5bUV07cmV0dXJuIHI/ci5pPjM/ci5pLTQ6ci5pOkFycmF5LmlzQXJyYXkobik/MTpzKG4pPzI6dihuKT8zOjB9ZnVuY3Rpb24gdShuLHIpe3JldHVybiAyPT09byhuKT9uLmhhcyhyKTpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKX1mdW5jdGlvbiBhKG4scil7cmV0dXJuIDI9PT1vKG4pP24uZ2V0KHIpOm5bcl19ZnVuY3Rpb24gZihuLHIsdCl7dmFyIGU9byhuKTsyPT09ZT9uLnNldChyLHQpOjM9PT1lP24uYWRkKHQpOm5bcl09dH1mdW5jdGlvbiBjKG4scil7cmV0dXJuIG49PT1yPzAhPT1ufHwxL249PTEvcjpuIT1uJiZyIT1yfWZ1bmN0aW9uIHMobil7cmV0dXJuIFgmJm4gaW5zdGFuY2VvZiBNYXB9ZnVuY3Rpb24gdihuKXtyZXR1cm4gcSYmbiBpbnN0YW5jZW9mIFNldH1mdW5jdGlvbiBwKG4pe3JldHVybiBuLm98fG4udH1mdW5jdGlvbiBsKG4pe2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pO3ZhciByPXJuKG4pO2RlbGV0ZSByW1FdO2Zvcih2YXIgdD1ubihyKSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBpPXRbZV0sbz1yW2ldOyExPT09by53cml0YWJsZSYmKG8ud3JpdGFibGU9ITAsby5jb25maWd1cmFibGU9ITApLChvLmdldHx8by5zZXQpJiYocltpXT17Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLGVudW1lcmFibGU6by5lbnVtZXJhYmxlLHZhbHVlOm5baV19KX1yZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yobikscil9ZnVuY3Rpb24gZChuLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSkseShuKXx8cihuKXx8IXQobil8fChvKG4pPjEmJihuLnNldD1uLmFkZD1uLmNsZWFyPW4uZGVsZXRlPWgpLE9iamVjdC5mcmVlemUobiksZSYmaShuLChmdW5jdGlvbihuLHIpe3JldHVybiBkKHIsITApfSksITApKSxufWZ1bmN0aW9uIGgoKXtuKDIpfWZ1bmN0aW9uIHkobil7cmV0dXJuIG51bGw9PW58fFwib2JqZWN0XCIhPXR5cGVvZiBufHxPYmplY3QuaXNGcm96ZW4obil9ZnVuY3Rpb24gYihyKXt2YXIgdD10bltyXTtyZXR1cm4gdHx8bigxOCxyKSx0fWZ1bmN0aW9uIG0obixyKXt0bltuXXx8KHRuW25dPXIpfWZ1bmN0aW9uIF8oKXtyZXR1cm5cInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WfHxVfHxuKDApLFV9ZnVuY3Rpb24gaihuLHIpe3ImJihiKFwiUGF0Y2hlc1wiKSxuLnU9W10sbi5zPVtdLG4udj1yKX1mdW5jdGlvbiBnKG4pe08obiksbi5wLmZvckVhY2goUyksbi5wPW51bGx9ZnVuY3Rpb24gTyhuKXtuPT09VSYmKFU9bi5sKX1mdW5jdGlvbiB3KG4pe3JldHVybiBVPXtwOltdLGw6VSxoOm4sbTohMCxfOjB9fWZ1bmN0aW9uIFMobil7dmFyIHI9bltRXTswPT09ci5pfHwxPT09ci5pP3IuaigpOnIuZz0hMH1mdW5jdGlvbiBQKHIsZSl7ZS5fPWUucC5sZW5ndGg7dmFyIGk9ZS5wWzBdLG89dm9pZCAwIT09ciYmciE9PWk7cmV0dXJuIGUuaC5PfHxiKFwiRVM1XCIpLlMoZSxyLG8pLG8/KGlbUV0uUCYmKGcoZSksbig0KSksdChyKSYmKHI9TShlLHIpLGUubHx8eChlLHIpKSxlLnUmJmIoXCJQYXRjaGVzXCIpLk0oaVtRXS50LHIsZS51LGUucykpOnI9TShlLGksW10pLGcoZSksZS51JiZlLnYoZS51LGUucyksciE9PUg/cjp2b2lkIDB9ZnVuY3Rpb24gTShuLHIsdCl7aWYoeShyKSlyZXR1cm4gcjt2YXIgZT1yW1FdO2lmKCFlKXJldHVybiBpKHIsKGZ1bmN0aW9uKGksbyl7cmV0dXJuIEEobixlLHIsaSxvLHQpfSksITApLHI7aWYoZS5BIT09bilyZXR1cm4gcjtpZighZS5QKXJldHVybiB4KG4sZS50LCEwKSxlLnQ7aWYoIWUuSSl7ZS5JPSEwLGUuQS5fLS07dmFyIG89ND09PWUuaXx8NT09PWUuaT9lLm89bChlLmspOmUubyx1PW8sYT0hMTszPT09ZS5pJiYodT1uZXcgU2V0KG8pLG8uY2xlYXIoKSxhPSEwKSxpKHUsKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIEEobixlLG8scixpLHQsYSl9KSkseChuLG8sITEpLHQmJm4udSYmYihcIlBhdGNoZXNcIikuTihlLHQsbi51LG4ucyl9cmV0dXJuIGUub31mdW5jdGlvbiBBKGUsaSxvLGEsYyxzLHYpe2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmM9PT1vJiZuKDUpLHIoYykpe3ZhciBwPU0oZSxjLHMmJmkmJjMhPT1pLmkmJiF1KGkuUixhKT9zLmNvbmNhdChhKTp2b2lkIDApO2lmKGYobyxhLHApLCFyKHApKXJldHVybjtlLm09ITF9ZWxzZSB2JiZvLmFkZChjKTtpZih0KGMpJiYheShjKSl7aWYoIWUuaC5EJiZlLl88MSlyZXR1cm47TShlLGMpLGkmJmkuQS5sfHx4KGUsYyl9fWZ1bmN0aW9uIHgobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSwhbi5sJiZuLmguRCYmbi5tJiZkKHIsdCl9ZnVuY3Rpb24geihuLHIpe3ZhciB0PW5bUV07cmV0dXJuKHQ/cCh0KTpuKVtyXX1mdW5jdGlvbiBJKG4scil7aWYociBpbiBuKWZvcih2YXIgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7dDspe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtpZihlKXJldHVybiBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfX1mdW5jdGlvbiBrKG4pe24uUHx8KG4uUD0hMCxuLmwmJmsobi5sKSl9ZnVuY3Rpb24gRShuKXtuLm98fChuLm89bChuLnQpKX1mdW5jdGlvbiBOKG4scix0KXt2YXIgZT1zKHIpP2IoXCJNYXBTZXRcIikuRihyLHQpOnYocik/YihcIk1hcFNldFwiKS5UKHIsdCk6bi5PP2Z1bmN0aW9uKG4scil7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxlPXtpOnQ/MTowLEE6cj9yLkE6XygpLFA6ITEsSTohMSxSOnt9LGw6cix0Om4sazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0saT1lLG89ZW47dCYmKGk9W2VdLG89b24pO3ZhciB1PVByb3h5LnJldm9jYWJsZShpLG8pLGE9dS5yZXZva2UsZj11LnByb3h5O3JldHVybiBlLms9ZixlLmo9YSxmfShyLHQpOmIoXCJFUzVcIikuSihyLHQpO3JldHVybih0P3QuQTpfKCkpLnAucHVzaChlKSxlfWZ1bmN0aW9uIFIoZSl7cmV0dXJuIHIoZSl8fG4oMjIsZSksZnVuY3Rpb24gbihyKXtpZighdChyKSlyZXR1cm4gcjt2YXIgZSx1PXJbUV0sYz1vKHIpO2lmKHUpe2lmKCF1LlAmJih1Lmk8NHx8IWIoXCJFUzVcIikuSyh1KSkpcmV0dXJuIHUudDt1Lkk9ITAsZT1EKHIsYyksdS5JPSExfWVsc2UgZT1EKHIsYyk7cmV0dXJuIGkoZSwoZnVuY3Rpb24ocix0KXt1JiZhKHUudCxyKT09PXR8fGYoZSxyLG4odCkpfSkpLDM9PT1jP25ldyBTZXQoZSk6ZX0oZSl9ZnVuY3Rpb24gRChuLHIpe3N3aXRjaChyKXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAobik7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKG4pfXJldHVybiBsKG4pfWZ1bmN0aW9uIEYoKXtmdW5jdGlvbiB0KG4scil7dmFyIHQ9c1tuXTtyZXR1cm4gdD90LmVudW1lcmFibGU9cjpzW25dPXQ9e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHI9dGhpc1tRXTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHIpLGVuLmdldChyLG4pfSxzZXQ6ZnVuY3Rpb24ocil7dmFyIHQ9dGhpc1tRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHQpLGVuLnNldCh0LG4scil9fSx0fWZ1bmN0aW9uIGUobil7Zm9yKHZhciByPW4ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciB0PW5bcl1bUV07aWYoIXQuUClzd2l0Y2godC5pKXtjYXNlIDU6YSh0KSYmayh0KTticmVhaztjYXNlIDQ6byh0KSYmayh0KX19fWZ1bmN0aW9uIG8obil7Zm9yKHZhciByPW4udCx0PW4uayxlPW5uKHQpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIG89ZVtpXTtpZihvIT09USl7dmFyIGE9cltvXTtpZih2b2lkIDA9PT1hJiYhdShyLG8pKXJldHVybiEwO3ZhciBmPXRbb10scz1mJiZmW1FdO2lmKHM/cy50IT09YTohYyhmLGEpKXJldHVybiEwfX12YXIgdj0hIXJbUV07cmV0dXJuIGUubGVuZ3RoIT09bm4ocikubGVuZ3RoKyh2PzA6MSl9ZnVuY3Rpb24gYShuKXt2YXIgcj1uLms7aWYoci5sZW5ndGghPT1uLnQubGVuZ3RoKXJldHVybiEwO3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixyLmxlbmd0aC0xKTtpZih0JiYhdC5nZXQpcmV0dXJuITA7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspaWYoIXIuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZihyKXtyLmcmJm4oMyxKU09OLnN0cmluZ2lmeShwKHIpKSl9dmFyIHM9e307bShcIkVTNVwiLHtKOmZ1bmN0aW9uKG4scil7dmFyIGU9QXJyYXkuaXNBcnJheShuKSxpPWZ1bmN0aW9uKG4scil7aWYobil7Zm9yKHZhciBlPUFycmF5KHIubGVuZ3RoKSxpPTA7aTxyLmxlbmd0aDtpKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJcIitpLHQoaSwhMCkpO3JldHVybiBlfXZhciBvPXJuKHIpO2RlbGV0ZSBvW1FdO2Zvcih2YXIgdT1ubihvKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBmPXVbYV07b1tmXT10KGYsbnx8ISFvW2ZdLmVudW1lcmFibGUpfXJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSxvKX0oZSxuKSxvPXtpOmU/NTo0LEE6cj9yLkE6XygpLFA6ITEsSTohMSxSOnt9LGw6cix0Om4sazppLG86bnVsbCxnOiExLEM6ITF9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxRLHt2YWx1ZTpvLHdyaXRhYmxlOiEwfSksaX0sUzpmdW5jdGlvbihuLHQsbyl7bz9yKHQpJiZ0W1FdLkE9PT1uJiZlKG4ucCk6KG4udSYmZnVuY3Rpb24gbihyKXtpZihyJiZcIm9iamVjdFwiPT10eXBlb2Ygcil7dmFyIHQ9cltRXTtpZih0KXt2YXIgZT10LnQsbz10LmssZj10LlIsYz10Lmk7aWYoND09PWMpaShvLChmdW5jdGlvbihyKXtyIT09USYmKHZvaWQgMCE9PWVbcl18fHUoZSxyKT9mW3JdfHxuKG9bcl0pOihmW3JdPSEwLGsodCkpKX0pKSxpKGUsKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PW9bbl18fHUobyxuKXx8KGZbbl09ITEsayh0KSl9KSk7ZWxzZSBpZig1PT09Yyl7aWYoYSh0KSYmKGsodCksZi5sZW5ndGg9ITApLG8ubGVuZ3RoPGUubGVuZ3RoKWZvcih2YXIgcz1vLmxlbmd0aDtzPGUubGVuZ3RoO3MrKylmW3NdPSExO2Vsc2UgZm9yKHZhciB2PWUubGVuZ3RoO3Y8by5sZW5ndGg7disrKWZbdl09ITA7Zm9yKHZhciBwPU1hdGgubWluKG8ubGVuZ3RoLGUubGVuZ3RoKSxsPTA7bDxwO2wrKylvLmhhc093blByb3BlcnR5KGwpfHwoZltsXT0hMCksdm9pZCAwPT09ZltsXSYmbihvW2xdKX19fX0obi5wWzBdKSxlKG4ucCkpfSxLOmZ1bmN0aW9uKG4pe3JldHVybiA0PT09bi5pP28obik6YShuKX19KX1mdW5jdGlvbiBUKCl7ZnVuY3Rpb24gZShuKXtpZighdChuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuLm1hcChlKTtpZihzKG4pKXJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obi5lbnRyaWVzKCkpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuW25bMF0sZShuWzFdKV19KSkpO2lmKHYobikpcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShuKS5tYXAoZSkpO3ZhciByPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKTtmb3IodmFyIGkgaW4gbilyW2ldPWUobltpXSk7cmV0dXJuIHUobixMKSYmKHJbTF09bltMXSkscn1mdW5jdGlvbiBmKG4pe3JldHVybiByKG4pP2Uobik6bn12YXIgYz1cImFkZFwiO20oXCJQYXRjaGVzXCIseyQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGk9dC5wYXRoLHU9dC5vcCxmPXIscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciB2PW8oZikscD1pW3NdO1wic3RyaW5nXCIhPXR5cGVvZiBwJiZcIm51bWJlclwiIT10eXBlb2YgcCYmKHA9XCJcIitwKSwwIT09diYmMSE9PXZ8fFwiX19wcm90b19fXCIhPT1wJiZcImNvbnN0cnVjdG9yXCIhPT1wfHxuKDI0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiZcInByb3RvdHlwZVwiPT09cCYmbigyNCksXCJvYmplY3RcIiE9dHlwZW9mKGY9YShmLHApKSYmbigxNSxpLmpvaW4oXCIvXCIpKX12YXIgbD1vKGYpLGQ9ZSh0LnZhbHVlKSxoPWlbaS5sZW5ndGgtMV07c3dpdGNoKHUpe2Nhc2VcInJlcGxhY2VcIjpzd2l0Y2gobCl7Y2FzZSAyOnJldHVybiBmLnNldChoLGQpO2Nhc2UgMzpuKDE2KTtkZWZhdWx0OnJldHVybiBmW2hdPWR9Y2FzZSBjOnN3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCItXCI9PT1oP2YucHVzaChkKTpmLnNwbGljZShoLDAsZCk7Y2FzZSAyOnJldHVybiBmLnNldChoLGQpO2Nhc2UgMzpyZXR1cm4gZi5hZGQoZCk7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2VcInJlbW92ZVwiOnN3aXRjaChsKXtjYXNlIDE6cmV0dXJuIGYuc3BsaWNlKGgsMSk7Y2FzZSAyOnJldHVybiBmLmRlbGV0ZShoKTtjYXNlIDM6cmV0dXJuIGYuZGVsZXRlKHQudmFsdWUpO2RlZmF1bHQ6cmV0dXJuIGRlbGV0ZSBmW2hdfWRlZmF1bHQ6bigxNyx1KX19KSkscn0sTjpmdW5jdGlvbihuLHIsdCxlKXtzd2l0Y2gobi5pKXtjYXNlIDA6Y2FzZSA0OmNhc2UgMjpyZXR1cm4gZnVuY3Rpb24obixyLHQsZSl7dmFyIG89bi50LHM9bi5vO2kobi5SLChmdW5jdGlvbihuLGkpe3ZhciB2PWEobyxuKSxwPWEocyxuKSxsPWk/dShvLG4pP1wicmVwbGFjZVwiOmM6XCJyZW1vdmVcIjtpZih2IT09cHx8XCJyZXBsYWNlXCIhPT1sKXt2YXIgZD1yLmNvbmNhdChuKTt0LnB1c2goXCJyZW1vdmVcIj09PWw/e29wOmwscGF0aDpkfTp7b3A6bCxwYXRoOmQsdmFsdWU6cH0pLGUucHVzaChsPT09Yz97b3A6XCJyZW1vdmVcIixwYXRoOmR9OlwicmVtb3ZlXCI9PT1sP3tvcDpjLHBhdGg6ZCx2YWx1ZTpmKHYpfTp7b3A6XCJyZXBsYWNlXCIscGF0aDpkLHZhbHVlOmYodil9KX19KSl9KG4scix0LGUpO2Nhc2UgNTpjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBpPW4udCxvPW4uUix1PW4ubztpZih1Lmxlbmd0aDxpLmxlbmd0aCl7dmFyIGE9W3UsaV07aT1hWzBdLHU9YVsxXTt2YXIgcz1bZSx0XTt0PXNbMF0sZT1zWzFdfWZvcih2YXIgdj0wO3Y8aS5sZW5ndGg7disrKWlmKG9bdl0mJnVbdl0hPT1pW3ZdKXt2YXIgcD1yLmNvbmNhdChbdl0pO3QucHVzaCh7b3A6XCJyZXBsYWNlXCIscGF0aDpwLHZhbHVlOmYodVt2XSl9KSxlLnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKGlbdl0pfSl9Zm9yKHZhciBsPWkubGVuZ3RoO2w8dS5sZW5ndGg7bCsrKXt2YXIgZD1yLmNvbmNhdChbbF0pO3QucHVzaCh7b3A6YyxwYXRoOmQsdmFsdWU6Zih1W2xdKX0pfWkubGVuZ3RoPHUubGVuZ3RoJiZlLnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6ci5jb25jYXQoW1wibGVuZ3RoXCJdKSx2YWx1ZTppLmxlbmd0aH0pfShuLHIsdCxlKTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBpPW4udCxvPW4ubyx1PTA7aS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighby5oYXMobikpe3ZhciBpPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpcInJlbW92ZVwiLHBhdGg6aSx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpjLHBhdGg6aSx2YWx1ZTpufSl9dSsrfSkpLHU9MCxvLmZvckVhY2goKGZ1bmN0aW9uKG4pe2lmKCFpLmhhcyhuKSl7dmFyIG89ci5jb25jYXQoW3VdKTt0LnB1c2goe29wOmMscGF0aDpvLHZhbHVlOm59KSxlLnVuc2hpZnQoe29wOlwicmVtb3ZlXCIscGF0aDpvLHZhbHVlOm59KX11Kyt9KSl9KG4scix0LGUpfX0sTTpmdW5jdGlvbihuLHIsdCxlKXt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6W10sdmFsdWU6cj09PUg/dm9pZCAwOnJ9KSxlLnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6W10sdmFsdWU6bn0pfX0pfWZ1bmN0aW9uIEMoKXtmdW5jdGlvbiByKG4scil7ZnVuY3Rpb24gdCgpe3RoaXMuY29uc3RydWN0b3I9bn1hKG4sciksbi5wcm90b3R5cGU9KHQucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyB0KX1mdW5jdGlvbiBlKG4pe24ub3x8KG4uUj1uZXcgTWFwLG4ubz1uZXcgTWFwKG4udCkpfWZ1bmN0aW9uIG8obil7bi5vfHwobi5vPW5ldyBTZXQsbi50LmZvckVhY2goKGZ1bmN0aW9uKHIpe2lmKHQocikpe3ZhciBlPU4obi5BLmgscixuKTtuLnAuc2V0KHIsZSksbi5vLmFkZChlKX1lbHNlIG4uby5hZGQocil9KSkpfWZ1bmN0aW9uIHUocil7ci5nJiZuKDMsSlNPTi5zdHJpbmdpZnkocChyKSkpfXZhciBhPWZ1bmN0aW9uKG4scil7cmV0dXJuKGE9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKG4scil7bi5fX3Byb3RvX189cn18fGZ1bmN0aW9uKG4scil7Zm9yKHZhciB0IGluIHIpci5oYXNPd25Qcm9wZXJ0eSh0KSYmKG5bdF09clt0XSl9KShuLHIpfSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjIsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCxSOnZvaWQgMCx0Om4sazp0aGlzLEM6ITEsZzohMX0sdGhpc31yKG4sTWFwKTt2YXIgbz1uLnByb3RvdHlwZTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJzaXplXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBwKHRoaXNbUV0pLnNpemV9fSksby5oYXM9ZnVuY3Rpb24obil7cmV0dXJuIHAodGhpc1tRXSkuaGFzKG4pfSxvLnNldD1mdW5jdGlvbihuLHIpe3ZhciB0PXRoaXNbUV07cmV0dXJuIHUodCkscCh0KS5oYXMobikmJnAodCkuZ2V0KG4pPT09cnx8KGUodCksayh0KSx0LlIuc2V0KG4sITApLHQuby5zZXQobixyKSx0LlIuc2V0KG4sITApKSx0aGlzfSxvLmRlbGV0ZT1mdW5jdGlvbihuKXtpZighdGhpcy5oYXMobikpcmV0dXJuITE7dmFyIHI9dGhpc1tRXTtyZXR1cm4gdShyKSxlKHIpLGsociksci50LmhhcyhuKT9yLlIuc2V0KG4sITEpOnIuUi5kZWxldGUobiksci5vLmRlbGV0ZShuKSwhMH0sby5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihlKG4pLGsobiksbi5SPW5ldyBNYXAsaShuLnQsKGZ1bmN0aW9uKHIpe24uUi5zZXQociwhMSl9KSksbi5vLmNsZWFyKCkpfSxvLmZvckVhY2g9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzO3AodGhpc1tRXSkuZm9yRWFjaCgoZnVuY3Rpb24oZSxpKXtuLmNhbGwocix0LmdldChpKSxpLHQpfSkpfSxvLmdldD1mdW5jdGlvbihuKXt2YXIgcj10aGlzW1FdO3Uocik7dmFyIGk9cChyKS5nZXQobik7aWYoci5JfHwhdChpKSlyZXR1cm4gaTtpZihpIT09ci50LmdldChuKSlyZXR1cm4gaTt2YXIgbz1OKHIuQS5oLGkscik7cmV0dXJuIGUociksci5vLnNldChuLG8pLG99LG8ua2V5cz1mdW5jdGlvbigpe3JldHVybiBwKHRoaXNbUV0pLmtleXMoKX0sby52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgbixyPXRoaXMsdD10aGlzLmtleXMoKTtyZXR1cm4obj17fSlbVl09ZnVuY3Rpb24oKXtyZXR1cm4gci52YWx1ZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7cmV0dXJuIG4uZG9uZT9uOntkb25lOiExLHZhbHVlOnIuZ2V0KG4udmFsdWUpfX0sbn0sby5lbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZW50cmllcygpfSxuLm5leHQ9ZnVuY3Rpb24oKXt2YXIgbj10Lm5leHQoKTtpZihuLmRvbmUpcmV0dXJuIG47dmFyIGU9ci5nZXQobi52YWx1ZSk7cmV0dXJue2RvbmU6ITEsdmFsdWU6W24udmFsdWUsZV19fSxufSxvW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cmllcygpfSxufSgpLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4scil7cmV0dXJuIHRoaXNbUV09e2k6MyxsOnIsQTpyP3IuQTpfKCksUDohMSxJOiExLG86dm9pZCAwLHQ6bixrOnRoaXMscDpuZXcgTWFwLGc6ITEsQzohMX0sdGhpc31yKG4sU2V0KTt2YXIgdD1uLnByb3RvdHlwZTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJzaXplXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBwKHRoaXNbUV0pLnNpemV9fSksdC5oYXM9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTtyZXR1cm4gdShyKSxyLm8/ISFyLm8uaGFzKG4pfHwhKCFyLnAuaGFzKG4pfHwhci5vLmhhcyhyLnAuZ2V0KG4pKSk6ci50LmhhcyhuKX0sdC5hZGQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTtyZXR1cm4gdShyKSx0aGlzLmhhcyhuKXx8KG8ociksayhyKSxyLm8uYWRkKG4pKSx0aGlzfSx0LmRlbGV0ZT1mdW5jdGlvbihuKXtpZighdGhpcy5oYXMobikpcmV0dXJuITE7dmFyIHI9dGhpc1tRXTtyZXR1cm4gdShyKSxvKHIpLGsociksci5vLmRlbGV0ZShuKXx8ISFyLnAuaGFzKG4pJiZyLm8uZGVsZXRlKHIucC5nZXQobikpfSx0LmNsZWFyPWZ1bmN0aW9uKCl7dmFyIG49dGhpc1tRXTt1KG4pLHAobikuc2l6ZSYmKG8obiksayhuKSxuLm8uY2xlYXIoKSl9LHQudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG49dGhpc1tRXTtyZXR1cm4gdShuKSxvKG4pLG4uby52YWx1ZXMoKX0sdC5lbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIG49dGhpc1tRXTtyZXR1cm4gdShuKSxvKG4pLG4uby5lbnRyaWVzKCl9LHQua2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0W1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVzKCl9LHQuZm9yRWFjaD1mdW5jdGlvbihuLHIpe2Zvcih2YXIgdD10aGlzLnZhbHVlcygpLGU9dC5uZXh0KCk7IWUuZG9uZTspbi5jYWxsKHIsZS52YWx1ZSxlLnZhbHVlLHRoaXMpLGU9dC5uZXh0KCl9LG59KCk7bShcIk1hcFNldFwiLHtGOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBmKG4scil9LFQ6ZnVuY3Rpb24obixyKXtyZXR1cm4gbmV3IGMobixyKX19KX1mdW5jdGlvbiBKKCl7RigpLEMoKSxUKCl9ZnVuY3Rpb24gSyhuKXtyZXR1cm4gbn1mdW5jdGlvbiAkKG4pe3JldHVybiBufXZhciBHLFUsVz1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKFwieFwiKSxYPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXAscT1cInVuZGVmaW5lZFwiIT10eXBlb2YgU2V0LEI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb3h5JiZ2b2lkIDAhPT1Qcm94eS5yZXZvY2FibGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0LEg9Vz9TeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKTooKEc9e30pW1wiaW1tZXItbm90aGluZ1wiXT0hMCxHKSxMPVc/U3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKTpcIl9fJGltbWVyX2RyYWZ0YWJsZVwiLFE9Vz9TeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik6XCJfXyRpbW1lcl9zdGF0ZVwiLFY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yfHxcIkBAaXRlcmF0b3JcIixZPXswOlwiSWxsZWdhbCBzdGF0ZVwiLDE6XCJJbW1lciBkcmFmdHMgY2Fubm90IGhhdmUgY29tcHV0ZWQgcHJvcGVydGllc1wiLDI6XCJUaGlzIG9iamVjdCBoYXMgYmVlbiBmcm96ZW4gYW5kIHNob3VsZCBub3QgYmUgbXV0YXRlZFwiLDM6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiK259LDQ6XCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLDU6XCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIiw2OlwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsNzpcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLDg6XCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsOTpcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIiwxMDpcIlRoZSBnaXZlbiBkcmFmdCBpcyBhbHJlYWR5IGZpbmFsaXplZFwiLDExOlwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIiwxMjpcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTM6XCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIiwxNDpcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIiwxNTpmdW5jdGlvbihuKXtyZXR1cm5cIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiK259LDE2OidTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJywxNzpmdW5jdGlvbihuKXtyZXR1cm5cIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIrbn0sMTg6ZnVuY3Rpb24obil7cmV0dXJuXCJUaGUgcGx1Z2luIGZvciAnXCIrbitcIicgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIGBlbmFibGVcIituK1wiKClgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uXCJ9LDIwOlwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLDIxOmZ1bmN0aW9uKG4pe3JldHVyblwicHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnXCIrbitcIidcIn0sMjI6ZnVuY3Rpb24obil7cmV0dXJuXCInY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDIzOmZ1bmN0aW9uKG4pe3JldHVyblwiJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIrbn0sMjQ6XCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJ9LFo9XCJcIitPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLG5uPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0Lm93bktleXM/UmVmbGVjdC5vd25LZXlzOnZvaWQgMCE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24obil7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG4pLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG4pKX06T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMscm49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uKG4pe3ZhciByPXt9O3JldHVybiBubihuKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyW3RdPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KX0pKSxyfSx0bj17fSxlbj17Z2V0OmZ1bmN0aW9uKG4scil7aWYocj09PVEpcmV0dXJuIG47dmFyIGU9cChuKTtpZighdShlLHIpKXJldHVybiBmdW5jdGlvbihuLHIsdCl7dmFyIGUsaT1JKHIsdCk7cmV0dXJuIGk/XCJ2YWx1ZVwiaW4gaT9pLnZhbHVlOm51bGw9PT0oZT1pLmdldCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuY2FsbChuLmspOnZvaWQgMH0obixlLHIpO3ZhciBpPWVbcl07cmV0dXJuIG4uSXx8IXQoaSk/aTppPT09eihuLnQscik/KEUobiksbi5vW3JdPU4obi5BLmgsaSxuKSk6aX0saGFzOmZ1bmN0aW9uKG4scil7cmV0dXJuIHIgaW4gcChuKX0sb3duS2V5czpmdW5jdGlvbihuKXtyZXR1cm4gUmVmbGVjdC5vd25LZXlzKHAobikpfSxzZXQ6ZnVuY3Rpb24obixyLHQpe3ZhciBlPUkocChuKSxyKTtpZihudWxsPT1lP3ZvaWQgMDplLnNldClyZXR1cm4gZS5zZXQuY2FsbChuLmssdCksITA7aWYoIW4uUCl7dmFyIGk9eihwKG4pLHIpLG89bnVsbD09aT92b2lkIDA6aVtRXTtpZihvJiZvLnQ9PT10KXJldHVybiBuLm9bcl09dCxuLlJbcl09ITEsITA7aWYoYyh0LGkpJiYodm9pZCAwIT09dHx8dShuLnQscikpKXJldHVybiEwO0UobiksayhuKX1yZXR1cm4gbi5vW3JdPT09dCYmKHZvaWQgMCE9PXR8fHIgaW4gbi5vKXx8TnVtYmVyLmlzTmFOKHQpJiZOdW1iZXIuaXNOYU4obi5vW3JdKXx8KG4ub1tyXT10LG4uUltyXT0hMCksITB9LGRlbGV0ZVByb3BlcnR5OmZ1bmN0aW9uKG4scil7cmV0dXJuIHZvaWQgMCE9PXoobi50LHIpfHxyIGluIG4udD8obi5SW3JdPSExLEUobiksayhuKSk6ZGVsZXRlIG4uUltyXSxuLm8mJmRlbGV0ZSBuLm9bcl0sITB9LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpmdW5jdGlvbihuLHIpe3ZhciB0PXAobiksZT1SZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO3JldHVybiBlP3t3cml0YWJsZTohMCxjb25maWd1cmFibGU6MSE9PW4uaXx8XCJsZW5ndGhcIiE9PXIsZW51bWVyYWJsZTplLmVudW1lcmFibGUsdmFsdWU6dFtyXX06ZX0sZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oKXtuKDExKX0sZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24obil7cmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuLnQpfSxzZXRQcm90b3R5cGVPZjpmdW5jdGlvbigpe24oMTIpfX0sb249e307aShlbiwoZnVuY3Rpb24obixyKXtvbltuXT1mdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHNbMF09YXJndW1lbnRzWzBdWzBdLHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pKSxvbi5kZWxldGVQcm9wZXJ0eT1mdW5jdGlvbihyLHQpe3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmlzTmFOKHBhcnNlSW50KHQpKSYmbigxMyksb24uc2V0LmNhbGwodGhpcyxyLHQsdm9pZCAwKX0sb24uc2V0PWZ1bmN0aW9uKHIsdCxlKXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcImxlbmd0aFwiIT09dCYmaXNOYU4ocGFyc2VJbnQodCkpJiZuKDE0KSxlbi5zZXQuY2FsbCh0aGlzLHJbMF0sdCxlLHJbMF0pfTt2YXIgdW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIpe3ZhciBlPXRoaXM7dGhpcy5PPUIsdGhpcy5EPSEwLHRoaXMucHJvZHVjZT1mdW5jdGlvbihyLGksbyl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgciYmXCJmdW5jdGlvblwiIT10eXBlb2YgaSl7dmFyIHU9aTtpPXI7dmFyIGE9ZTtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHI9dGhpczt2b2lkIDA9PT1uJiYobj11KTtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPUFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspZVtvLTFdPWFyZ3VtZW50c1tvXTtyZXR1cm4gYS5wcm9kdWNlKG4sKGZ1bmN0aW9uKG4pe3ZhciB0O3JldHVybih0PWkpLmNhbGwuYXBwbHkodCxbcixuXS5jb25jYXQoZSkpfSkpfX12YXIgZjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpJiZuKDYpLHZvaWQgMCE9PW8mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG8mJm4oNyksdChyKSl7dmFyIGM9dyhlKSxzPU4oZSxyLHZvaWQgMCksdj0hMDt0cnl7Zj1pKHMpLHY9ITF9ZmluYWxseXt2P2coYyk6TyhjKX1yZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSYmZiBpbnN0YW5jZW9mIFByb21pc2U/Zi50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gaihjLG8pLFAobixjKX0pLChmdW5jdGlvbihuKXt0aHJvdyBnKGMpLG59KSk6KGooYyxvKSxQKGYsYykpfWlmKCFyfHxcIm9iamVjdFwiIT10eXBlb2Ygcil7aWYodm9pZCAwPT09KGY9aShyKSkmJihmPXIpLGY9PT1IJiYoZj12b2lkIDApLGUuRCYmZChmLCEwKSxvKXt2YXIgcD1bXSxsPVtdO2IoXCJQYXRjaGVzXCIpLk0ocixmLHAsbCksbyhwLGwpfXJldHVybiBmfW4oMjEscil9LHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzPWZ1bmN0aW9uKG4scil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbilyZXR1cm4gZnVuY3Rpb24ocil7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsaT1BcnJheSh0PjE/dC0xOjApLG89MTtvPHQ7bysrKWlbby0xXT1hcmd1bWVudHNbb107cmV0dXJuIGUucHJvZHVjZVdpdGhQYXRjaGVzKHIsKGZ1bmN0aW9uKHIpe3JldHVybiBuLmFwcGx5KHZvaWQgMCxbcl0uY29uY2F0KGkpKX0pKX07dmFyIHQsaSxvPWUucHJvZHVjZShuLHIsKGZ1bmN0aW9uKG4scil7dD1uLGk9cn0pKTtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSYmbyBpbnN0YW5jZW9mIFByb21pc2U/by50aGVuKChmdW5jdGlvbihuKXtyZXR1cm5bbix0LGldfSkpOltvLHQsaV19LFwiYm9vbGVhblwiPT10eXBlb2YobnVsbD09cj92b2lkIDA6ci51c2VQcm94aWVzKSYmdGhpcy5zZXRVc2VQcm94aWVzKHIudXNlUHJveGllcyksXCJib29sZWFuXCI9PXR5cGVvZihudWxsPT1yP3ZvaWQgMDpyLmF1dG9GcmVlemUpJiZ0aGlzLnNldEF1dG9GcmVlemUoci5hdXRvRnJlZXplKX12YXIgaT1lLnByb3RvdHlwZTtyZXR1cm4gaS5jcmVhdGVEcmFmdD1mdW5jdGlvbihlKXt0KGUpfHxuKDgpLHIoZSkmJihlPVIoZSkpO3ZhciBpPXcodGhpcyksbz1OKHRoaXMsZSx2b2lkIDApO3JldHVybiBvW1FdLkM9ITAsTyhpKSxvfSxpLmZpbmlzaERyYWZ0PWZ1bmN0aW9uKHIsdCl7dmFyIGU9ciYmcltRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYoZSYmZS5DfHxuKDkpLGUuSSYmbigxMCkpO3ZhciBpPWUuQTtyZXR1cm4gaihpLHQpLFAodm9pZCAwLGkpfSxpLnNldEF1dG9GcmVlemU9ZnVuY3Rpb24obil7dGhpcy5EPW59LGkuc2V0VXNlUHJveGllcz1mdW5jdGlvbihyKXtyJiYhQiYmbigyMCksdGhpcy5PPXJ9LGkuYXBwbHlQYXRjaGVzPWZ1bmN0aW9uKG4sdCl7dmFyIGU7Zm9yKGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7dmFyIGk9dFtlXTtpZigwPT09aS5wYXRoLmxlbmd0aCYmXCJyZXBsYWNlXCI9PT1pLm9wKXtuPWkudmFsdWU7YnJlYWt9fWU+LTEmJih0PXQuc2xpY2UoZSsxKSk7dmFyIG89YihcIlBhdGNoZXNcIikuJDtyZXR1cm4gcihuKT9vKG4sdCk6dGhpcy5wcm9kdWNlKG4sKGZ1bmN0aW9uKG4pe3JldHVybiBvKG4sdCl9KSl9LGV9KCksYW49bmV3IHVuLGZuPWFuLnByb2R1Y2UsY249YW4ucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoYW4pLHNuPWFuLnNldEF1dG9GcmVlemUuYmluZChhbiksdm49YW4uc2V0VXNlUHJveGllcy5iaW5kKGFuKSxwbj1hbi5hcHBseVBhdGNoZXMuYmluZChhbiksbG49YW4uY3JlYXRlRHJhZnQuYmluZChhbiksZG49YW4uZmluaXNoRHJhZnQuYmluZChhbik7ZXhwb3J0IGRlZmF1bHQgZm47ZXhwb3J0e3VuIGFzIEltbWVyLHBuIGFzIGFwcGx5UGF0Y2hlcyxLIGFzIGNhc3REcmFmdCwkIGFzIGNhc3RJbW11dGFibGUsbG4gYXMgY3JlYXRlRHJhZnQsUiBhcyBjdXJyZW50LEogYXMgZW5hYmxlQWxsUGx1Z2lucyxGIGFzIGVuYWJsZUVTNSxDIGFzIGVuYWJsZU1hcFNldCxUIGFzIGVuYWJsZVBhdGNoZXMsZG4gYXMgZmluaXNoRHJhZnQsZCBhcyBmcmVlemUsTCBhcyBpbW1lcmFibGUsciBhcyBpc0RyYWZ0LHQgYXMgaXNEcmFmdGFibGUsSCBhcyBub3RoaW5nLGUgYXMgb3JpZ2luYWwsZm4gYXMgcHJvZHVjZSxjbiBhcyBwcm9kdWNlV2l0aFBhdGNoZXMsc24gYXMgc2V0QXV0b0ZyZWV6ZSx2biBhcyBzZXRVc2VQcm94aWVzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbWVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJuIiwiciIsImFyZ3VtZW50cyIsImxlbmd0aCIsInQiLCJBcnJheSIsImUiLCJpIiwiWSIsIm8iLCJhcHBseSIsIkVycm9yIiwibWFwIiwiam9pbiIsIlEiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNvbnN0cnVjdG9yIiwiRnVuY3Rpb24iLCJ0b1N0cmluZyIsIloiLCJpc0FycmF5IiwiTCIsInMiLCJ2Iiwia2V5cyIsIm5uIiwiZm9yRWFjaCIsInUiLCJoYXMiLCJwcm90b3R5cGUiLCJhIiwiZ2V0IiwiZiIsInNldCIsImFkZCIsImMiLCJYIiwiTWFwIiwicSIsIlNldCIsInAiLCJsIiwic2xpY2UiLCJybiIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsInZhbHVlIiwiY3JlYXRlIiwiZCIsInkiLCJjbGVhciIsImRlbGV0ZSIsImgiLCJmcmVlemUiLCJpc0Zyb3plbiIsImIiLCJ0biIsIm0iLCJfIiwiVSIsImoiLCJnIiwiTyIsIlMiLCJ3IiwiUCIsIk0iLCJ4IiwiSCIsIkEiLCJJIiwiayIsIk4iLCJSIiwiY29uY2F0IiwiRCIsInoiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJFIiwiRiIsIlQiLCJDIiwiZW4iLCJvbiIsIlByb3h5IiwicmV2b2NhYmxlIiwicmV2b2tlIiwicHJveHkiLCJKIiwicHVzaCIsIksiLCJmcm9tIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlZmluZVByb3BlcnR5IiwiTWF0aCIsIm1pbiIsImVudHJpZXMiLCIkIiwicGF0aCIsIm9wIiwic3BsaWNlIiwidW5zaGlmdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwic2l6ZSIsInZhbHVlcyIsIlYiLCJuZXh0IiwiZG9uZSIsIkciLCJXIiwiU3ltYm9sIiwiQiIsIlJlZmxlY3QiLCJmb3IiLCJpdGVyYXRvciIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIk51bWJlciIsImlzTmFOIiwiZGVsZXRlUHJvcGVydHkiLCJwYXJzZUludCIsInVuIiwicHJvZHVjZSIsIlByb21pc2UiLCJ0aGVuIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwidXNlUHJveGllcyIsInNldFVzZVByb3hpZXMiLCJhdXRvRnJlZXplIiwic2V0QXV0b0ZyZWV6ZSIsImNyZWF0ZURyYWZ0IiwiZmluaXNoRHJhZnQiLCJhcHBseVBhdGNoZXMiLCJhbiIsImZuIiwiY24iLCJiaW5kIiwic24iLCJ2biIsInBuIiwibG4iLCJkbiIsIkltbWVyIiwiY2FzdERyYWZ0IiwiY2FzdEltbXV0YWJsZSIsImN1cnJlbnQiLCJlbmFibGVBbGxQbHVnaW5zIiwiZW5hYmxlRVM1IiwiZW5hYmxlTWFwU2V0IiwiZW5hYmxlUGF0Y2hlcyIsImltbWVyYWJsZSIsImlzRHJhZnQiLCJpc0RyYWZ0YWJsZSIsIm5vdGhpbmciLCJvcmlnaW5hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.esm.mjs\n");

/***/ })

};
;